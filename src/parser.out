Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ALSE
    AND
    AS
    AUTO
    BREAK
    CASE
    CLASS
    CLOSE
    CONST
    CONTINUE
    DECREMENT
    DEFAULT
    DEL
    DIVEQUAL
    EXCEPT
    FROM
    GLOBAL
    IMPORT
    IN
    INCREMENT
    INPUT
    INT
    IS
    LAMBDA
    LEN
    LENGTH
    LSHIFT
    MINUSEQUAL
    MODEQUAL
    NONLOCAL
    NOT
    NULL
    ONE
    OPEN
    OR
    PASS
    PERIOD
    PLUSEQUAL
    RAISE
    RANGE
    READ
    RSHIFT
    RUE
    SIZEOF
    STATIC
    STR
    STRUCT
    SWITCH
    TIMESEQUAL
    TRY
    VECTOR
    VOID
    WITH
    WRITE
    XOR

Grammar

Rule 0     S' -> prog
Rule 1     prog -> empty
Rule 2     prog -> func prog
Rule 3     func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
Rule 4     func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
Rule 5     body -> empty
Rule 6     body -> stmt body
Rule 7     stmt -> expr SEMI
Rule 8     stmt -> defvar SEMI
Rule 9     stmt -> return_instr SEMI
Rule 10    stmt -> single_if
Rule 11    stmt -> if_with_else
Rule 12    stmt -> while_loop
Rule 13    stmt -> for_loop
Rule 14    stmt -> block
Rule 15    stmt -> func
Rule 16    single_if -> IF LPAREN expr RPAREN stmt
Rule 17    if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt
Rule 18    while_loop -> WHILE LPAREN expr RPAREN stmt
Rule 19    for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
Rule 20    block -> LBRACE body RBRACE
Rule 21    return_instr -> RETURN expr
Rule 22    defvar -> VAR TYPE ID
Rule 23    defvar -> VAR TYPE ID EQUALS expr
Rule 24    flist -> empty
Rule 25    flist -> TYPE ID
Rule 26    flist -> TYPE ID COMMA flist
Rule 27    clist -> empty
Rule 28    clist -> expr
Rule 29    clist -> expr COMMA clist
Rule 30    expr -> operation_on_list
Rule 31    expr -> expr_list
Rule 32    expr -> ternary_expr
Rule 33    expr -> LNOT expr
Rule 34    expr -> PLUS expr
Rule 35    expr -> MINUS expr
Rule 36    expr -> binary_expr
Rule 37    expr -> ID
Rule 38    expr -> assignment
Rule 39    expr -> function_call
Rule 40    expr -> NUMBER
Rule 41    expr -> STRING
Rule 42    expr_list -> LBRACKET clist RBRACKET
Rule 43    operation_on_list -> expr LBRACKET expr RBRACKET
Rule 44    operation_on_list -> ID LBRACKET expr RBRACKET
Rule 45    assignment -> ID EQUALS expr
Rule 46    assignment -> ID LBRACKET expr RBRACKET EQUALS expr
Rule 47    ternary_expr -> expr QUESTIONMARK expr COLON expr
Rule 48    function_call -> ID LPAREN clist RPAREN
Rule 49    binary_expr -> expr PLUS expr
Rule 50    binary_expr -> expr MINUS expr
Rule 51    binary_expr -> expr TIMES expr
Rule 52    binary_expr -> expr DIVIDE expr
Rule 53    binary_expr -> expr MODULO expr
Rule 54    binary_expr -> expr GT expr
Rule 55    binary_expr -> expr LT expr
Rule 56    binary_expr -> expr EQ expr
Rule 57    binary_expr -> expr LE expr
Rule 58    binary_expr -> expr GE expr
Rule 59    binary_expr -> expr NE expr
Rule 60    binary_expr -> expr LOR expr
Rule 61    binary_expr -> expr LAND expr
Rule 62    empty -> <empty>

Terminals, with rules where they appear

ALSE                 : 
AND                  : 
AS                   : 
AUTO                 : 
BREAK                : 
CASE                 : 
CLASS                : 
CLOSE                : 
COLON                : 47
COMMA                : 26 29
CONST                : 
CONTINUE             : 
DECREMENT            : 
DEF                  : 3 4
DEFAULT              : 
DEL                  : 
DIVEQUAL             : 
DIVIDE               : 52
ELSE                 : 17
EQ                   : 56
EQUALS               : 19 23 45 46
EXCEPT               : 
FOR                  : 19
FROM                 : 
GE                   : 58
GLOBAL               : 
GT                   : 54
ID                   : 3 4 19 22 23 25 26 37 44 45 46 48
IF                   : 16 17
IMPORT               : 
IN                   : 
INCREMENT            : 
INPUT                : 
INT                  : 
IS                   : 
LAMBDA               : 
LAND                 : 61
LBRACE               : 3 20
LBRACKET             : 42 43 44 46
LE                   : 57
LEN                  : 
LENGTH               : 
LNOT                 : 33
LOR                  : 60
LPAREN               : 3 4 16 17 18 19 48
LSHIFT               : 
LT                   : 55
MINUS                : 35 50
MINUSEQUAL           : 
MODEQUAL             : 
MODULO               : 53
NE                   : 59
NONLOCAL             : 
NOT                  : 
NULL                 : 
NUMBER               : 40
ONE                  : 
OPEN                 : 
OR                   : 
PASS                 : 
PERIOD               : 
PLUS                 : 34 49
PLUSEQUAL            : 
QUESTIONMARK         : 47
RAISE                : 
RANGE                : 
RBRACE               : 3 20
RBRACKET             : 42 43 44 46
READ                 : 
RETURN               : 4 21
RPAREN               : 3 4 16 17 18 19 48
RSHIFT               : 
RUE                  : 
SEMI                 : 4 7 8 9
SIZEOF               : 
STATIC               : 
STR                  : 
STRING               : 41
STRUCT               : 
SWITCH               : 
TIMES                : 51
TIMESEQUAL           : 
TO                   : 19
TRY                  : 
TYPE                 : 3 4 22 23 25 26
VAR                  : 22 23
VECTOR               : 
VOID                 : 
WHILE                : 18
WITH                 : 
WRITE                : 
XOR                  : 
error                : 

Nonterminals, with rules where they appear

assignment           : 38
binary_expr          : 36
block                : 14
body                 : 3 6 20
clist                : 29 42 48
defvar               : 8
empty                : 1 5 24 27
expr                 : 4 7 16 17 18 19 19 21 23 28 29 33 34 35 43 43 44 45 46 46 47 47 47 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61
expr_list            : 31
flist                : 3 4 26
for_loop             : 13
func                 : 2 15
function_call        : 39
if_with_else         : 11
operation_on_list    : 30
prog                 : 2 0
return_instr         : 9
single_if            : 10
stmt                 : 6 16 17 17 18 19
ternary_expr         : 32
while_loop           : 12

Parsing method: LALR

state 0

    (0) S' -> . prog
    (1) prog -> . empty
    (2) prog -> . func prog
    (62) empty -> .
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI

    $end            reduce using rule 62 (empty -> .)
    DEF             shift and go to state 4

    prog                           shift and go to state 1
    empty                          shift and go to state 2
    func                           shift and go to state 3

state 1

    (0) S' -> prog .



state 2

    (1) prog -> empty .

    $end            reduce using rule 1 (prog -> empty .)


state 3

    (2) prog -> func . prog
    (1) prog -> . empty
    (2) prog -> . func prog
    (62) empty -> .
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI

    $end            reduce using rule 62 (empty -> .)
    DEF             shift and go to state 4

    func                           shift and go to state 3
    prog                           shift and go to state 5
    empty                          shift and go to state 2

state 4

    (3) func -> DEF . TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> DEF . TYPE ID LPAREN flist RPAREN RETURN expr SEMI

    TYPE            shift and go to state 6


state 5

    (2) prog -> func prog .

    $end            reduce using rule 2 (prog -> func prog .)


state 6

    (3) func -> DEF TYPE . ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> DEF TYPE . ID LPAREN flist RPAREN RETURN expr SEMI

    ID              shift and go to state 7


state 7

    (3) func -> DEF TYPE ID . LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> DEF TYPE ID . LPAREN flist RPAREN RETURN expr SEMI

    LPAREN          shift and go to state 8


state 8

    (3) func -> DEF TYPE ID LPAREN . flist RPAREN LBRACE body RBRACE
    (4) func -> DEF TYPE ID LPAREN . flist RPAREN RETURN expr SEMI
    (24) flist -> . empty
    (25) flist -> . TYPE ID
    (26) flist -> . TYPE ID COMMA flist
    (62) empty -> .

    TYPE            shift and go to state 9
    RPAREN          reduce using rule 62 (empty -> .)

    flist                          shift and go to state 10
    empty                          shift and go to state 11

state 9

    (25) flist -> TYPE . ID
    (26) flist -> TYPE . ID COMMA flist

    ID              shift and go to state 12


state 10

    (3) func -> DEF TYPE ID LPAREN flist . RPAREN LBRACE body RBRACE
    (4) func -> DEF TYPE ID LPAREN flist . RPAREN RETURN expr SEMI

    RPAREN          shift and go to state 13


state 11

    (24) flist -> empty .

    RPAREN          reduce using rule 24 (flist -> empty .)


state 12

    (25) flist -> TYPE ID .
    (26) flist -> TYPE ID . COMMA flist

    RPAREN          reduce using rule 25 (flist -> TYPE ID .)
    COMMA           shift and go to state 14


state 13

    (3) func -> DEF TYPE ID LPAREN flist RPAREN . LBRACE body RBRACE
    (4) func -> DEF TYPE ID LPAREN flist RPAREN . RETURN expr SEMI

    LBRACE          shift and go to state 15
    RETURN          shift and go to state 16


state 14

    (26) flist -> TYPE ID COMMA . flist
    (24) flist -> . empty
    (25) flist -> . TYPE ID
    (26) flist -> . TYPE ID COMMA flist
    (62) empty -> .

    TYPE            shift and go to state 9
    RPAREN          reduce using rule 62 (empty -> .)

    flist                          shift and go to state 17
    empty                          shift and go to state 11

state 15

    (3) func -> DEF TYPE ID LPAREN flist RPAREN LBRACE . body RBRACE
    (5) body -> . empty
    (6) body -> . stmt body
    (62) empty -> .
    (7) stmt -> . expr SEMI
    (8) stmt -> . defvar SEMI
    (9) stmt -> . return_instr SEMI
    (10) stmt -> . single_if
    (11) stmt -> . if_with_else
    (12) stmt -> . while_loop
    (13) stmt -> . for_loop
    (14) stmt -> . block
    (15) stmt -> . func
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (22) defvar -> . VAR TYPE ID
    (23) defvar -> . VAR TYPE ID EQUALS expr
    (21) return_instr -> . RETURN expr
    (16) single_if -> . IF LPAREN expr RPAREN stmt
    (17) if_with_else -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (18) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (19) for_loop -> . FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
    (20) block -> . LBRACE body RBRACE
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    RBRACE          reduce using rule 62 (empty -> .)
    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    VAR             shift and go to state 43
    RETURN          shift and go to state 44
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    FOR             shift and go to state 47
    LBRACE          shift and go to state 19
    DEF             shift and go to state 4
    LBRACKET        shift and go to state 48

    body                           shift and go to state 20
    empty                          shift and go to state 21
    stmt                           shift and go to state 22
    expr                           shift and go to state 23
    defvar                         shift and go to state 24
    return_instr                   shift and go to state 25
    single_if                      shift and go to state 26
    if_with_else                   shift and go to state 27
    while_loop                     shift and go to state 28
    for_loop                       shift and go to state 29
    block                          shift and go to state 30
    func                           shift and go to state 31
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 16

    (4) func -> DEF TYPE ID LPAREN flist RPAREN RETURN . expr SEMI
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 49
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 17

    (26) flist -> TYPE ID COMMA flist .

    RPAREN          reduce using rule 26 (flist -> TYPE ID COMMA flist .)


state 18

    (37) expr -> ID .
    (44) operation_on_list -> ID . LBRACKET expr RBRACKET
    (45) assignment -> ID . EQUALS expr
    (46) assignment -> ID . LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> ID . LPAREN clist RPAREN

  ! shift/reduce conflict for LBRACKET resolved as shift
    SEMI            reduce using rule 37 (expr -> ID .)
    QUESTIONMARK    reduce using rule 37 (expr -> ID .)
    PLUS            reduce using rule 37 (expr -> ID .)
    MINUS           reduce using rule 37 (expr -> ID .)
    TIMES           reduce using rule 37 (expr -> ID .)
    DIVIDE          reduce using rule 37 (expr -> ID .)
    MODULO          reduce using rule 37 (expr -> ID .)
    GT              reduce using rule 37 (expr -> ID .)
    LT              reduce using rule 37 (expr -> ID .)
    EQ              reduce using rule 37 (expr -> ID .)
    LE              reduce using rule 37 (expr -> ID .)
    GE              reduce using rule 37 (expr -> ID .)
    NE              reduce using rule 37 (expr -> ID .)
    LOR             reduce using rule 37 (expr -> ID .)
    LAND            reduce using rule 37 (expr -> ID .)
    COMMA           reduce using rule 37 (expr -> ID .)
    RBRACKET        reduce using rule 37 (expr -> ID .)
    RPAREN          reduce using rule 37 (expr -> ID .)
    COLON           reduce using rule 37 (expr -> ID .)
    TO              reduce using rule 37 (expr -> ID .)
    LBRACKET        shift and go to state 50
    EQUALS          shift and go to state 51
    LPAREN          shift and go to state 52

  ! LBRACKET        [ reduce using rule 37 (expr -> ID .) ]


state 19

    (20) block -> LBRACE . body RBRACE
    (5) body -> . empty
    (6) body -> . stmt body
    (62) empty -> .
    (7) stmt -> . expr SEMI
    (8) stmt -> . defvar SEMI
    (9) stmt -> . return_instr SEMI
    (10) stmt -> . single_if
    (11) stmt -> . if_with_else
    (12) stmt -> . while_loop
    (13) stmt -> . for_loop
    (14) stmt -> . block
    (15) stmt -> . func
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (22) defvar -> . VAR TYPE ID
    (23) defvar -> . VAR TYPE ID EQUALS expr
    (21) return_instr -> . RETURN expr
    (16) single_if -> . IF LPAREN expr RPAREN stmt
    (17) if_with_else -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (18) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (19) for_loop -> . FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
    (20) block -> . LBRACE body RBRACE
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    RBRACE          reduce using rule 62 (empty -> .)
    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    VAR             shift and go to state 43
    RETURN          shift and go to state 44
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    FOR             shift and go to state 47
    LBRACE          shift and go to state 19
    DEF             shift and go to state 4
    LBRACKET        shift and go to state 48

    body                           shift and go to state 53
    empty                          shift and go to state 21
    stmt                           shift and go to state 22
    expr                           shift and go to state 23
    defvar                         shift and go to state 24
    return_instr                   shift and go to state 25
    single_if                      shift and go to state 26
    if_with_else                   shift and go to state 27
    while_loop                     shift and go to state 28
    for_loop                       shift and go to state 29
    block                          shift and go to state 30
    func                           shift and go to state 31
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 20

    (3) func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 54


state 21

    (5) body -> empty .

    RBRACE          reduce using rule 5 (body -> empty .)


state 22

    (6) body -> stmt . body
    (5) body -> . empty
    (6) body -> . stmt body
    (62) empty -> .
    (7) stmt -> . expr SEMI
    (8) stmt -> . defvar SEMI
    (9) stmt -> . return_instr SEMI
    (10) stmt -> . single_if
    (11) stmt -> . if_with_else
    (12) stmt -> . while_loop
    (13) stmt -> . for_loop
    (14) stmt -> . block
    (15) stmt -> . func
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (22) defvar -> . VAR TYPE ID
    (23) defvar -> . VAR TYPE ID EQUALS expr
    (21) return_instr -> . RETURN expr
    (16) single_if -> . IF LPAREN expr RPAREN stmt
    (17) if_with_else -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (18) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (19) for_loop -> . FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
    (20) block -> . LBRACE body RBRACE
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    RBRACE          reduce using rule 62 (empty -> .)
    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    VAR             shift and go to state 43
    RETURN          shift and go to state 44
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    FOR             shift and go to state 47
    LBRACE          shift and go to state 19
    DEF             shift and go to state 4
    LBRACKET        shift and go to state 48

    stmt                           shift and go to state 22
    body                           shift and go to state 55
    empty                          shift and go to state 21
    expr                           shift and go to state 23
    defvar                         shift and go to state 24
    return_instr                   shift and go to state 25
    single_if                      shift and go to state 26
    if_with_else                   shift and go to state 27
    while_loop                     shift and go to state 28
    for_loop                       shift and go to state 29
    block                          shift and go to state 30
    func                           shift and go to state 31
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 23

    (7) stmt -> expr . SEMI
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    SEMI            shift and go to state 56
    LBRACKET        shift and go to state 57
    QUESTIONMARK    shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULO          shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    EQ              shift and go to state 66
    LE              shift and go to state 67
    GE              shift and go to state 68
    NE              shift and go to state 69
    LOR             shift and go to state 70
    LAND            shift and go to state 71


state 24

    (8) stmt -> defvar . SEMI

    SEMI            shift and go to state 72


state 25

    (9) stmt -> return_instr . SEMI

    SEMI            shift and go to state 73


state 26

    (10) stmt -> single_if .

    LNOT            reduce using rule 10 (stmt -> single_if .)
    PLUS            reduce using rule 10 (stmt -> single_if .)
    MINUS           reduce using rule 10 (stmt -> single_if .)
    ID              reduce using rule 10 (stmt -> single_if .)
    NUMBER          reduce using rule 10 (stmt -> single_if .)
    STRING          reduce using rule 10 (stmt -> single_if .)
    VAR             reduce using rule 10 (stmt -> single_if .)
    RETURN          reduce using rule 10 (stmt -> single_if .)
    IF              reduce using rule 10 (stmt -> single_if .)
    WHILE           reduce using rule 10 (stmt -> single_if .)
    FOR             reduce using rule 10 (stmt -> single_if .)
    LBRACE          reduce using rule 10 (stmt -> single_if .)
    DEF             reduce using rule 10 (stmt -> single_if .)
    LBRACKET        reduce using rule 10 (stmt -> single_if .)
    RBRACE          reduce using rule 10 (stmt -> single_if .)
    ELSE            reduce using rule 10 (stmt -> single_if .)


state 27

    (11) stmt -> if_with_else .

    LNOT            reduce using rule 11 (stmt -> if_with_else .)
    PLUS            reduce using rule 11 (stmt -> if_with_else .)
    MINUS           reduce using rule 11 (stmt -> if_with_else .)
    ID              reduce using rule 11 (stmt -> if_with_else .)
    NUMBER          reduce using rule 11 (stmt -> if_with_else .)
    STRING          reduce using rule 11 (stmt -> if_with_else .)
    VAR             reduce using rule 11 (stmt -> if_with_else .)
    RETURN          reduce using rule 11 (stmt -> if_with_else .)
    IF              reduce using rule 11 (stmt -> if_with_else .)
    WHILE           reduce using rule 11 (stmt -> if_with_else .)
    FOR             reduce using rule 11 (stmt -> if_with_else .)
    LBRACE          reduce using rule 11 (stmt -> if_with_else .)
    DEF             reduce using rule 11 (stmt -> if_with_else .)
    LBRACKET        reduce using rule 11 (stmt -> if_with_else .)
    RBRACE          reduce using rule 11 (stmt -> if_with_else .)
    ELSE            reduce using rule 11 (stmt -> if_with_else .)


state 28

    (12) stmt -> while_loop .

    LNOT            reduce using rule 12 (stmt -> while_loop .)
    PLUS            reduce using rule 12 (stmt -> while_loop .)
    MINUS           reduce using rule 12 (stmt -> while_loop .)
    ID              reduce using rule 12 (stmt -> while_loop .)
    NUMBER          reduce using rule 12 (stmt -> while_loop .)
    STRING          reduce using rule 12 (stmt -> while_loop .)
    VAR             reduce using rule 12 (stmt -> while_loop .)
    RETURN          reduce using rule 12 (stmt -> while_loop .)
    IF              reduce using rule 12 (stmt -> while_loop .)
    WHILE           reduce using rule 12 (stmt -> while_loop .)
    FOR             reduce using rule 12 (stmt -> while_loop .)
    LBRACE          reduce using rule 12 (stmt -> while_loop .)
    DEF             reduce using rule 12 (stmt -> while_loop .)
    LBRACKET        reduce using rule 12 (stmt -> while_loop .)
    RBRACE          reduce using rule 12 (stmt -> while_loop .)
    ELSE            reduce using rule 12 (stmt -> while_loop .)


state 29

    (13) stmt -> for_loop .

    LNOT            reduce using rule 13 (stmt -> for_loop .)
    PLUS            reduce using rule 13 (stmt -> for_loop .)
    MINUS           reduce using rule 13 (stmt -> for_loop .)
    ID              reduce using rule 13 (stmt -> for_loop .)
    NUMBER          reduce using rule 13 (stmt -> for_loop .)
    STRING          reduce using rule 13 (stmt -> for_loop .)
    VAR             reduce using rule 13 (stmt -> for_loop .)
    RETURN          reduce using rule 13 (stmt -> for_loop .)
    IF              reduce using rule 13 (stmt -> for_loop .)
    WHILE           reduce using rule 13 (stmt -> for_loop .)
    FOR             reduce using rule 13 (stmt -> for_loop .)
    LBRACE          reduce using rule 13 (stmt -> for_loop .)
    DEF             reduce using rule 13 (stmt -> for_loop .)
    LBRACKET        reduce using rule 13 (stmt -> for_loop .)
    RBRACE          reduce using rule 13 (stmt -> for_loop .)
    ELSE            reduce using rule 13 (stmt -> for_loop .)


state 30

    (14) stmt -> block .

    LNOT            reduce using rule 14 (stmt -> block .)
    PLUS            reduce using rule 14 (stmt -> block .)
    MINUS           reduce using rule 14 (stmt -> block .)
    ID              reduce using rule 14 (stmt -> block .)
    NUMBER          reduce using rule 14 (stmt -> block .)
    STRING          reduce using rule 14 (stmt -> block .)
    VAR             reduce using rule 14 (stmt -> block .)
    RETURN          reduce using rule 14 (stmt -> block .)
    IF              reduce using rule 14 (stmt -> block .)
    WHILE           reduce using rule 14 (stmt -> block .)
    FOR             reduce using rule 14 (stmt -> block .)
    LBRACE          reduce using rule 14 (stmt -> block .)
    DEF             reduce using rule 14 (stmt -> block .)
    LBRACKET        reduce using rule 14 (stmt -> block .)
    RBRACE          reduce using rule 14 (stmt -> block .)
    ELSE            reduce using rule 14 (stmt -> block .)


state 31

    (15) stmt -> func .

    LNOT            reduce using rule 15 (stmt -> func .)
    PLUS            reduce using rule 15 (stmt -> func .)
    MINUS           reduce using rule 15 (stmt -> func .)
    ID              reduce using rule 15 (stmt -> func .)
    NUMBER          reduce using rule 15 (stmt -> func .)
    STRING          reduce using rule 15 (stmt -> func .)
    VAR             reduce using rule 15 (stmt -> func .)
    RETURN          reduce using rule 15 (stmt -> func .)
    IF              reduce using rule 15 (stmt -> func .)
    WHILE           reduce using rule 15 (stmt -> func .)
    FOR             reduce using rule 15 (stmt -> func .)
    LBRACE          reduce using rule 15 (stmt -> func .)
    DEF             reduce using rule 15 (stmt -> func .)
    LBRACKET        reduce using rule 15 (stmt -> func .)
    RBRACE          reduce using rule 15 (stmt -> func .)
    ELSE            reduce using rule 15 (stmt -> func .)


state 32

    (30) expr -> operation_on_list .

    SEMI            reduce using rule 30 (expr -> operation_on_list .)
    LBRACKET        reduce using rule 30 (expr -> operation_on_list .)
    QUESTIONMARK    reduce using rule 30 (expr -> operation_on_list .)
    PLUS            reduce using rule 30 (expr -> operation_on_list .)
    MINUS           reduce using rule 30 (expr -> operation_on_list .)
    TIMES           reduce using rule 30 (expr -> operation_on_list .)
    DIVIDE          reduce using rule 30 (expr -> operation_on_list .)
    MODULO          reduce using rule 30 (expr -> operation_on_list .)
    GT              reduce using rule 30 (expr -> operation_on_list .)
    LT              reduce using rule 30 (expr -> operation_on_list .)
    EQ              reduce using rule 30 (expr -> operation_on_list .)
    LE              reduce using rule 30 (expr -> operation_on_list .)
    GE              reduce using rule 30 (expr -> operation_on_list .)
    NE              reduce using rule 30 (expr -> operation_on_list .)
    LOR             reduce using rule 30 (expr -> operation_on_list .)
    LAND            reduce using rule 30 (expr -> operation_on_list .)
    COMMA           reduce using rule 30 (expr -> operation_on_list .)
    RBRACKET        reduce using rule 30 (expr -> operation_on_list .)
    RPAREN          reduce using rule 30 (expr -> operation_on_list .)
    COLON           reduce using rule 30 (expr -> operation_on_list .)
    TO              reduce using rule 30 (expr -> operation_on_list .)


state 33

    (31) expr -> expr_list .

    SEMI            reduce using rule 31 (expr -> expr_list .)
    LBRACKET        reduce using rule 31 (expr -> expr_list .)
    QUESTIONMARK    reduce using rule 31 (expr -> expr_list .)
    PLUS            reduce using rule 31 (expr -> expr_list .)
    MINUS           reduce using rule 31 (expr -> expr_list .)
    TIMES           reduce using rule 31 (expr -> expr_list .)
    DIVIDE          reduce using rule 31 (expr -> expr_list .)
    MODULO          reduce using rule 31 (expr -> expr_list .)
    GT              reduce using rule 31 (expr -> expr_list .)
    LT              reduce using rule 31 (expr -> expr_list .)
    EQ              reduce using rule 31 (expr -> expr_list .)
    LE              reduce using rule 31 (expr -> expr_list .)
    GE              reduce using rule 31 (expr -> expr_list .)
    NE              reduce using rule 31 (expr -> expr_list .)
    LOR             reduce using rule 31 (expr -> expr_list .)
    LAND            reduce using rule 31 (expr -> expr_list .)
    COMMA           reduce using rule 31 (expr -> expr_list .)
    RBRACKET        reduce using rule 31 (expr -> expr_list .)
    RPAREN          reduce using rule 31 (expr -> expr_list .)
    COLON           reduce using rule 31 (expr -> expr_list .)
    TO              reduce using rule 31 (expr -> expr_list .)


state 34

    (32) expr -> ternary_expr .

    SEMI            reduce using rule 32 (expr -> ternary_expr .)
    LBRACKET        reduce using rule 32 (expr -> ternary_expr .)
    QUESTIONMARK    reduce using rule 32 (expr -> ternary_expr .)
    PLUS            reduce using rule 32 (expr -> ternary_expr .)
    MINUS           reduce using rule 32 (expr -> ternary_expr .)
    TIMES           reduce using rule 32 (expr -> ternary_expr .)
    DIVIDE          reduce using rule 32 (expr -> ternary_expr .)
    MODULO          reduce using rule 32 (expr -> ternary_expr .)
    GT              reduce using rule 32 (expr -> ternary_expr .)
    LT              reduce using rule 32 (expr -> ternary_expr .)
    EQ              reduce using rule 32 (expr -> ternary_expr .)
    LE              reduce using rule 32 (expr -> ternary_expr .)
    GE              reduce using rule 32 (expr -> ternary_expr .)
    NE              reduce using rule 32 (expr -> ternary_expr .)
    LOR             reduce using rule 32 (expr -> ternary_expr .)
    LAND            reduce using rule 32 (expr -> ternary_expr .)
    COMMA           reduce using rule 32 (expr -> ternary_expr .)
    RBRACKET        reduce using rule 32 (expr -> ternary_expr .)
    RPAREN          reduce using rule 32 (expr -> ternary_expr .)
    COLON           reduce using rule 32 (expr -> ternary_expr .)
    TO              reduce using rule 32 (expr -> ternary_expr .)


state 35

    (33) expr -> LNOT . expr
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 74
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 36

    (34) expr -> PLUS . expr
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 75
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 37

    (35) expr -> MINUS . expr
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 76
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 38

    (36) expr -> binary_expr .

    SEMI            reduce using rule 36 (expr -> binary_expr .)
    LBRACKET        reduce using rule 36 (expr -> binary_expr .)
    QUESTIONMARK    reduce using rule 36 (expr -> binary_expr .)
    PLUS            reduce using rule 36 (expr -> binary_expr .)
    MINUS           reduce using rule 36 (expr -> binary_expr .)
    TIMES           reduce using rule 36 (expr -> binary_expr .)
    DIVIDE          reduce using rule 36 (expr -> binary_expr .)
    MODULO          reduce using rule 36 (expr -> binary_expr .)
    GT              reduce using rule 36 (expr -> binary_expr .)
    LT              reduce using rule 36 (expr -> binary_expr .)
    EQ              reduce using rule 36 (expr -> binary_expr .)
    LE              reduce using rule 36 (expr -> binary_expr .)
    GE              reduce using rule 36 (expr -> binary_expr .)
    NE              reduce using rule 36 (expr -> binary_expr .)
    LOR             reduce using rule 36 (expr -> binary_expr .)
    LAND            reduce using rule 36 (expr -> binary_expr .)
    COMMA           reduce using rule 36 (expr -> binary_expr .)
    RBRACKET        reduce using rule 36 (expr -> binary_expr .)
    RPAREN          reduce using rule 36 (expr -> binary_expr .)
    COLON           reduce using rule 36 (expr -> binary_expr .)
    TO              reduce using rule 36 (expr -> binary_expr .)


state 39

    (38) expr -> assignment .

    SEMI            reduce using rule 38 (expr -> assignment .)
    LBRACKET        reduce using rule 38 (expr -> assignment .)
    QUESTIONMARK    reduce using rule 38 (expr -> assignment .)
    PLUS            reduce using rule 38 (expr -> assignment .)
    MINUS           reduce using rule 38 (expr -> assignment .)
    TIMES           reduce using rule 38 (expr -> assignment .)
    DIVIDE          reduce using rule 38 (expr -> assignment .)
    MODULO          reduce using rule 38 (expr -> assignment .)
    GT              reduce using rule 38 (expr -> assignment .)
    LT              reduce using rule 38 (expr -> assignment .)
    EQ              reduce using rule 38 (expr -> assignment .)
    LE              reduce using rule 38 (expr -> assignment .)
    GE              reduce using rule 38 (expr -> assignment .)
    NE              reduce using rule 38 (expr -> assignment .)
    LOR             reduce using rule 38 (expr -> assignment .)
    LAND            reduce using rule 38 (expr -> assignment .)
    COMMA           reduce using rule 38 (expr -> assignment .)
    RBRACKET        reduce using rule 38 (expr -> assignment .)
    RPAREN          reduce using rule 38 (expr -> assignment .)
    COLON           reduce using rule 38 (expr -> assignment .)
    TO              reduce using rule 38 (expr -> assignment .)


state 40

    (39) expr -> function_call .

    SEMI            reduce using rule 39 (expr -> function_call .)
    LBRACKET        reduce using rule 39 (expr -> function_call .)
    QUESTIONMARK    reduce using rule 39 (expr -> function_call .)
    PLUS            reduce using rule 39 (expr -> function_call .)
    MINUS           reduce using rule 39 (expr -> function_call .)
    TIMES           reduce using rule 39 (expr -> function_call .)
    DIVIDE          reduce using rule 39 (expr -> function_call .)
    MODULO          reduce using rule 39 (expr -> function_call .)
    GT              reduce using rule 39 (expr -> function_call .)
    LT              reduce using rule 39 (expr -> function_call .)
    EQ              reduce using rule 39 (expr -> function_call .)
    LE              reduce using rule 39 (expr -> function_call .)
    GE              reduce using rule 39 (expr -> function_call .)
    NE              reduce using rule 39 (expr -> function_call .)
    LOR             reduce using rule 39 (expr -> function_call .)
    LAND            reduce using rule 39 (expr -> function_call .)
    COMMA           reduce using rule 39 (expr -> function_call .)
    RBRACKET        reduce using rule 39 (expr -> function_call .)
    RPAREN          reduce using rule 39 (expr -> function_call .)
    COLON           reduce using rule 39 (expr -> function_call .)
    TO              reduce using rule 39 (expr -> function_call .)


state 41

    (40) expr -> NUMBER .

    SEMI            reduce using rule 40 (expr -> NUMBER .)
    LBRACKET        reduce using rule 40 (expr -> NUMBER .)
    QUESTIONMARK    reduce using rule 40 (expr -> NUMBER .)
    PLUS            reduce using rule 40 (expr -> NUMBER .)
    MINUS           reduce using rule 40 (expr -> NUMBER .)
    TIMES           reduce using rule 40 (expr -> NUMBER .)
    DIVIDE          reduce using rule 40 (expr -> NUMBER .)
    MODULO          reduce using rule 40 (expr -> NUMBER .)
    GT              reduce using rule 40 (expr -> NUMBER .)
    LT              reduce using rule 40 (expr -> NUMBER .)
    EQ              reduce using rule 40 (expr -> NUMBER .)
    LE              reduce using rule 40 (expr -> NUMBER .)
    GE              reduce using rule 40 (expr -> NUMBER .)
    NE              reduce using rule 40 (expr -> NUMBER .)
    LOR             reduce using rule 40 (expr -> NUMBER .)
    LAND            reduce using rule 40 (expr -> NUMBER .)
    COMMA           reduce using rule 40 (expr -> NUMBER .)
    RBRACKET        reduce using rule 40 (expr -> NUMBER .)
    RPAREN          reduce using rule 40 (expr -> NUMBER .)
    COLON           reduce using rule 40 (expr -> NUMBER .)
    TO              reduce using rule 40 (expr -> NUMBER .)


state 42

    (41) expr -> STRING .

    SEMI            reduce using rule 41 (expr -> STRING .)
    LBRACKET        reduce using rule 41 (expr -> STRING .)
    QUESTIONMARK    reduce using rule 41 (expr -> STRING .)
    PLUS            reduce using rule 41 (expr -> STRING .)
    MINUS           reduce using rule 41 (expr -> STRING .)
    TIMES           reduce using rule 41 (expr -> STRING .)
    DIVIDE          reduce using rule 41 (expr -> STRING .)
    MODULO          reduce using rule 41 (expr -> STRING .)
    GT              reduce using rule 41 (expr -> STRING .)
    LT              reduce using rule 41 (expr -> STRING .)
    EQ              reduce using rule 41 (expr -> STRING .)
    LE              reduce using rule 41 (expr -> STRING .)
    GE              reduce using rule 41 (expr -> STRING .)
    NE              reduce using rule 41 (expr -> STRING .)
    LOR             reduce using rule 41 (expr -> STRING .)
    LAND            reduce using rule 41 (expr -> STRING .)
    COMMA           reduce using rule 41 (expr -> STRING .)
    RBRACKET        reduce using rule 41 (expr -> STRING .)
    RPAREN          reduce using rule 41 (expr -> STRING .)
    COLON           reduce using rule 41 (expr -> STRING .)
    TO              reduce using rule 41 (expr -> STRING .)


state 43

    (22) defvar -> VAR . TYPE ID
    (23) defvar -> VAR . TYPE ID EQUALS expr

    TYPE            shift and go to state 77


state 44

    (21) return_instr -> RETURN . expr
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 78
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 45

    (16) single_if -> IF . LPAREN expr RPAREN stmt
    (17) if_with_else -> IF . LPAREN expr RPAREN stmt ELSE stmt

    LPAREN          shift and go to state 79


state 46

    (18) while_loop -> WHILE . LPAREN expr RPAREN stmt

    LPAREN          shift and go to state 80


state 47

    (19) for_loop -> FOR . LPAREN ID EQUALS expr TO expr RPAREN stmt

    LPAREN          shift and go to state 81


state 48

    (42) expr_list -> LBRACKET . clist RBRACKET
    (27) clist -> . empty
    (28) clist -> . expr
    (29) clist -> . expr COMMA clist
    (62) empty -> .
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    RBRACKET        reduce using rule 62 (empty -> .)
    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    clist                          shift and go to state 82
    empty                          shift and go to state 83
    expr                           shift and go to state 84
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 49

    (4) func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr . SEMI
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    SEMI            shift and go to state 85
    LBRACKET        shift and go to state 57
    QUESTIONMARK    shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULO          shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    EQ              shift and go to state 66
    LE              shift and go to state 67
    GE              shift and go to state 68
    NE              shift and go to state 69
    LOR             shift and go to state 70
    LAND            shift and go to state 71


state 50

    (44) operation_on_list -> ID LBRACKET . expr RBRACKET
    (46) assignment -> ID LBRACKET . expr RBRACKET EQUALS expr
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 86
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 51

    (45) assignment -> ID EQUALS . expr
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 87
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 52

    (48) function_call -> ID LPAREN . clist RPAREN
    (27) clist -> . empty
    (28) clist -> . expr
    (29) clist -> . expr COMMA clist
    (62) empty -> .
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    RPAREN          reduce using rule 62 (empty -> .)
    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    clist                          shift and go to state 88
    empty                          shift and go to state 83
    expr                           shift and go to state 84
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 53

    (20) block -> LBRACE body . RBRACE

    RBRACE          shift and go to state 89


state 54

    (3) func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .

    DEF             reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    $end            reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    LNOT            reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    PLUS            reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    MINUS           reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    ID              reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    NUMBER          reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    STRING          reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    VAR             reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    RETURN          reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    LBRACE          reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    LBRACKET        reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    ELSE            reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)


state 55

    (6) body -> stmt body .

    RBRACE          reduce using rule 6 (body -> stmt body .)


state 56

    (7) stmt -> expr SEMI .

    LNOT            reduce using rule 7 (stmt -> expr SEMI .)
    PLUS            reduce using rule 7 (stmt -> expr SEMI .)
    MINUS           reduce using rule 7 (stmt -> expr SEMI .)
    ID              reduce using rule 7 (stmt -> expr SEMI .)
    NUMBER          reduce using rule 7 (stmt -> expr SEMI .)
    STRING          reduce using rule 7 (stmt -> expr SEMI .)
    VAR             reduce using rule 7 (stmt -> expr SEMI .)
    RETURN          reduce using rule 7 (stmt -> expr SEMI .)
    IF              reduce using rule 7 (stmt -> expr SEMI .)
    WHILE           reduce using rule 7 (stmt -> expr SEMI .)
    FOR             reduce using rule 7 (stmt -> expr SEMI .)
    LBRACE          reduce using rule 7 (stmt -> expr SEMI .)
    DEF             reduce using rule 7 (stmt -> expr SEMI .)
    LBRACKET        reduce using rule 7 (stmt -> expr SEMI .)
    RBRACE          reduce using rule 7 (stmt -> expr SEMI .)
    ELSE            reduce using rule 7 (stmt -> expr SEMI .)


state 57

    (43) operation_on_list -> expr LBRACKET . expr RBRACKET
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 90
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 58

    (47) ternary_expr -> expr QUESTIONMARK . expr COLON expr
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 91
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 59

    (49) binary_expr -> expr PLUS . expr
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 92
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 60

    (50) binary_expr -> expr MINUS . expr
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 93
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 61

    (51) binary_expr -> expr TIMES . expr
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 94
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 62

    (52) binary_expr -> expr DIVIDE . expr
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 95
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 63

    (53) binary_expr -> expr MODULO . expr
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 96
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 64

    (54) binary_expr -> expr GT . expr
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 97
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 65

    (55) binary_expr -> expr LT . expr
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 98
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 66

    (56) binary_expr -> expr EQ . expr
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 99
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 67

    (57) binary_expr -> expr LE . expr
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 100
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 68

    (58) binary_expr -> expr GE . expr
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 101
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 69

    (59) binary_expr -> expr NE . expr
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 102
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 70

    (60) binary_expr -> expr LOR . expr
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 103
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 71

    (61) binary_expr -> expr LAND . expr
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 104
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 72

    (8) stmt -> defvar SEMI .

    LNOT            reduce using rule 8 (stmt -> defvar SEMI .)
    PLUS            reduce using rule 8 (stmt -> defvar SEMI .)
    MINUS           reduce using rule 8 (stmt -> defvar SEMI .)
    ID              reduce using rule 8 (stmt -> defvar SEMI .)
    NUMBER          reduce using rule 8 (stmt -> defvar SEMI .)
    STRING          reduce using rule 8 (stmt -> defvar SEMI .)
    VAR             reduce using rule 8 (stmt -> defvar SEMI .)
    RETURN          reduce using rule 8 (stmt -> defvar SEMI .)
    IF              reduce using rule 8 (stmt -> defvar SEMI .)
    WHILE           reduce using rule 8 (stmt -> defvar SEMI .)
    FOR             reduce using rule 8 (stmt -> defvar SEMI .)
    LBRACE          reduce using rule 8 (stmt -> defvar SEMI .)
    DEF             reduce using rule 8 (stmt -> defvar SEMI .)
    LBRACKET        reduce using rule 8 (stmt -> defvar SEMI .)
    RBRACE          reduce using rule 8 (stmt -> defvar SEMI .)
    ELSE            reduce using rule 8 (stmt -> defvar SEMI .)


state 73

    (9) stmt -> return_instr SEMI .

    LNOT            reduce using rule 9 (stmt -> return_instr SEMI .)
    PLUS            reduce using rule 9 (stmt -> return_instr SEMI .)
    MINUS           reduce using rule 9 (stmt -> return_instr SEMI .)
    ID              reduce using rule 9 (stmt -> return_instr SEMI .)
    NUMBER          reduce using rule 9 (stmt -> return_instr SEMI .)
    STRING          reduce using rule 9 (stmt -> return_instr SEMI .)
    VAR             reduce using rule 9 (stmt -> return_instr SEMI .)
    RETURN          reduce using rule 9 (stmt -> return_instr SEMI .)
    IF              reduce using rule 9 (stmt -> return_instr SEMI .)
    WHILE           reduce using rule 9 (stmt -> return_instr SEMI .)
    FOR             reduce using rule 9 (stmt -> return_instr SEMI .)
    LBRACE          reduce using rule 9 (stmt -> return_instr SEMI .)
    DEF             reduce using rule 9 (stmt -> return_instr SEMI .)
    LBRACKET        reduce using rule 9 (stmt -> return_instr SEMI .)
    RBRACE          reduce using rule 9 (stmt -> return_instr SEMI .)
    ELSE            reduce using rule 9 (stmt -> return_instr SEMI .)


state 74

    (33) expr -> LNOT expr .
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 33 (expr -> LNOT expr .)
    LBRACKET        reduce using rule 33 (expr -> LNOT expr .)
    QUESTIONMARK    reduce using rule 33 (expr -> LNOT expr .)
    PLUS            reduce using rule 33 (expr -> LNOT expr .)
    MINUS           reduce using rule 33 (expr -> LNOT expr .)
    TIMES           reduce using rule 33 (expr -> LNOT expr .)
    DIVIDE          reduce using rule 33 (expr -> LNOT expr .)
    MODULO          reduce using rule 33 (expr -> LNOT expr .)
    GT              reduce using rule 33 (expr -> LNOT expr .)
    LT              reduce using rule 33 (expr -> LNOT expr .)
    EQ              reduce using rule 33 (expr -> LNOT expr .)
    LE              reduce using rule 33 (expr -> LNOT expr .)
    GE              reduce using rule 33 (expr -> LNOT expr .)
    NE              reduce using rule 33 (expr -> LNOT expr .)
    LOR             reduce using rule 33 (expr -> LNOT expr .)
    LAND            reduce using rule 33 (expr -> LNOT expr .)
    COMMA           reduce using rule 33 (expr -> LNOT expr .)
    RBRACKET        reduce using rule 33 (expr -> LNOT expr .)
    RPAREN          reduce using rule 33 (expr -> LNOT expr .)
    COLON           reduce using rule 33 (expr -> LNOT expr .)
    TO              reduce using rule 33 (expr -> LNOT expr .)

  ! LBRACKET        [ shift and go to state 57 ]
  ! QUESTIONMARK    [ shift and go to state 58 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 60 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 62 ]
  ! MODULO          [ shift and go to state 63 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! EQ              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! NE              [ shift and go to state 69 ]
  ! LOR             [ shift and go to state 70 ]
  ! LAND            [ shift and go to state 71 ]


state 75

    (34) expr -> PLUS expr .
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 34 (expr -> PLUS expr .)
    LBRACKET        reduce using rule 34 (expr -> PLUS expr .)
    PLUS            reduce using rule 34 (expr -> PLUS expr .)
    MINUS           reduce using rule 34 (expr -> PLUS expr .)
    GT              reduce using rule 34 (expr -> PLUS expr .)
    LT              reduce using rule 34 (expr -> PLUS expr .)
    EQ              reduce using rule 34 (expr -> PLUS expr .)
    LE              reduce using rule 34 (expr -> PLUS expr .)
    GE              reduce using rule 34 (expr -> PLUS expr .)
    NE              reduce using rule 34 (expr -> PLUS expr .)
    LOR             reduce using rule 34 (expr -> PLUS expr .)
    LAND            reduce using rule 34 (expr -> PLUS expr .)
    COMMA           reduce using rule 34 (expr -> PLUS expr .)
    RBRACKET        reduce using rule 34 (expr -> PLUS expr .)
    RPAREN          reduce using rule 34 (expr -> PLUS expr .)
    COLON           reduce using rule 34 (expr -> PLUS expr .)
    TO              reduce using rule 34 (expr -> PLUS expr .)
    QUESTIONMARK    shift and go to state 58
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULO          shift and go to state 63

  ! QUESTIONMARK    [ reduce using rule 34 (expr -> PLUS expr .) ]
  ! TIMES           [ reduce using rule 34 (expr -> PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 34 (expr -> PLUS expr .) ]
  ! MODULO          [ reduce using rule 34 (expr -> PLUS expr .) ]
  ! LBRACKET        [ shift and go to state 57 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 60 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! EQ              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! NE              [ shift and go to state 69 ]
  ! LOR             [ shift and go to state 70 ]
  ! LAND            [ shift and go to state 71 ]


state 76

    (35) expr -> MINUS expr .
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 35 (expr -> MINUS expr .)
    LBRACKET        reduce using rule 35 (expr -> MINUS expr .)
    PLUS            reduce using rule 35 (expr -> MINUS expr .)
    MINUS           reduce using rule 35 (expr -> MINUS expr .)
    TIMES           reduce using rule 35 (expr -> MINUS expr .)
    DIVIDE          reduce using rule 35 (expr -> MINUS expr .)
    MODULO          reduce using rule 35 (expr -> MINUS expr .)
    GT              reduce using rule 35 (expr -> MINUS expr .)
    LT              reduce using rule 35 (expr -> MINUS expr .)
    EQ              reduce using rule 35 (expr -> MINUS expr .)
    LE              reduce using rule 35 (expr -> MINUS expr .)
    GE              reduce using rule 35 (expr -> MINUS expr .)
    NE              reduce using rule 35 (expr -> MINUS expr .)
    LOR             reduce using rule 35 (expr -> MINUS expr .)
    LAND            reduce using rule 35 (expr -> MINUS expr .)
    COMMA           reduce using rule 35 (expr -> MINUS expr .)
    RBRACKET        reduce using rule 35 (expr -> MINUS expr .)
    RPAREN          reduce using rule 35 (expr -> MINUS expr .)
    COLON           reduce using rule 35 (expr -> MINUS expr .)
    TO              reduce using rule 35 (expr -> MINUS expr .)
    QUESTIONMARK    shift and go to state 58

  ! QUESTIONMARK    [ reduce using rule 35 (expr -> MINUS expr .) ]
  ! LBRACKET        [ shift and go to state 57 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 60 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 62 ]
  ! MODULO          [ shift and go to state 63 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! EQ              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! NE              [ shift and go to state 69 ]
  ! LOR             [ shift and go to state 70 ]
  ! LAND            [ shift and go to state 71 ]


state 77

    (22) defvar -> VAR TYPE . ID
    (23) defvar -> VAR TYPE . ID EQUALS expr

    ID              shift and go to state 105


state 78

    (21) return_instr -> RETURN expr .
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 21 (return_instr -> RETURN expr .)
    LBRACKET        shift and go to state 57
    QUESTIONMARK    shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULO          shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    EQ              shift and go to state 66
    LE              shift and go to state 67
    GE              shift and go to state 68
    NE              shift and go to state 69
    LOR             shift and go to state 70
    LAND            shift and go to state 71


state 79

    (16) single_if -> IF LPAREN . expr RPAREN stmt
    (17) if_with_else -> IF LPAREN . expr RPAREN stmt ELSE stmt
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 106
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 80

    (18) while_loop -> WHILE LPAREN . expr RPAREN stmt
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 107
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 81

    (19) for_loop -> FOR LPAREN . ID EQUALS expr TO expr RPAREN stmt

    ID              shift and go to state 108


state 82

    (42) expr_list -> LBRACKET clist . RBRACKET

    RBRACKET        shift and go to state 109


state 83

    (27) clist -> empty .

    RBRACKET        reduce using rule 27 (clist -> empty .)
    RPAREN          reduce using rule 27 (clist -> empty .)


state 84

    (28) clist -> expr .
    (29) clist -> expr . COMMA clist
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    RBRACKET        reduce using rule 28 (clist -> expr .)
    RPAREN          reduce using rule 28 (clist -> expr .)
    COMMA           shift and go to state 110
    LBRACKET        shift and go to state 57
    QUESTIONMARK    shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULO          shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    EQ              shift and go to state 66
    LE              shift and go to state 67
    GE              shift and go to state 68
    NE              shift and go to state 69
    LOR             shift and go to state 70
    LAND            shift and go to state 71


state 85

    (4) func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .

    DEF             reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    $end            reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    LNOT            reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    PLUS            reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    MINUS           reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    ID              reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    NUMBER          reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    STRING          reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    VAR             reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    RETURN          reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    IF              reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    WHILE           reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    FOR             reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    LBRACE          reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    LBRACKET        reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    RBRACE          reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    ELSE            reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)


state 86

    (44) operation_on_list -> ID LBRACKET expr . RBRACKET
    (46) assignment -> ID LBRACKET expr . RBRACKET EQUALS expr
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    RBRACKET        shift and go to state 111
    LBRACKET        shift and go to state 57
    QUESTIONMARK    shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULO          shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    EQ              shift and go to state 66
    LE              shift and go to state 67
    GE              shift and go to state 68
    NE              shift and go to state 69
    LOR             shift and go to state 70
    LAND            shift and go to state 71


state 87

    (45) assignment -> ID EQUALS expr .
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 45 (assignment -> ID EQUALS expr .)
    LBRACKET        reduce using rule 45 (assignment -> ID EQUALS expr .)
    QUESTIONMARK    reduce using rule 45 (assignment -> ID EQUALS expr .)
    PLUS            reduce using rule 45 (assignment -> ID EQUALS expr .)
    MINUS           reduce using rule 45 (assignment -> ID EQUALS expr .)
    TIMES           reduce using rule 45 (assignment -> ID EQUALS expr .)
    DIVIDE          reduce using rule 45 (assignment -> ID EQUALS expr .)
    MODULO          reduce using rule 45 (assignment -> ID EQUALS expr .)
    GT              reduce using rule 45 (assignment -> ID EQUALS expr .)
    LT              reduce using rule 45 (assignment -> ID EQUALS expr .)
    EQ              reduce using rule 45 (assignment -> ID EQUALS expr .)
    LE              reduce using rule 45 (assignment -> ID EQUALS expr .)
    GE              reduce using rule 45 (assignment -> ID EQUALS expr .)
    NE              reduce using rule 45 (assignment -> ID EQUALS expr .)
    LOR             reduce using rule 45 (assignment -> ID EQUALS expr .)
    LAND            reduce using rule 45 (assignment -> ID EQUALS expr .)
    COMMA           reduce using rule 45 (assignment -> ID EQUALS expr .)
    RBRACKET        reduce using rule 45 (assignment -> ID EQUALS expr .)
    RPAREN          reduce using rule 45 (assignment -> ID EQUALS expr .)
    COLON           reduce using rule 45 (assignment -> ID EQUALS expr .)
    TO              reduce using rule 45 (assignment -> ID EQUALS expr .)

  ! LBRACKET        [ shift and go to state 57 ]
  ! QUESTIONMARK    [ shift and go to state 58 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 60 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 62 ]
  ! MODULO          [ shift and go to state 63 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! EQ              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! NE              [ shift and go to state 69 ]
  ! LOR             [ shift and go to state 70 ]
  ! LAND            [ shift and go to state 71 ]


state 88

    (48) function_call -> ID LPAREN clist . RPAREN

    RPAREN          shift and go to state 112


state 89

    (20) block -> LBRACE body RBRACE .

    LNOT            reduce using rule 20 (block -> LBRACE body RBRACE .)
    PLUS            reduce using rule 20 (block -> LBRACE body RBRACE .)
    MINUS           reduce using rule 20 (block -> LBRACE body RBRACE .)
    ID              reduce using rule 20 (block -> LBRACE body RBRACE .)
    NUMBER          reduce using rule 20 (block -> LBRACE body RBRACE .)
    STRING          reduce using rule 20 (block -> LBRACE body RBRACE .)
    VAR             reduce using rule 20 (block -> LBRACE body RBRACE .)
    RETURN          reduce using rule 20 (block -> LBRACE body RBRACE .)
    IF              reduce using rule 20 (block -> LBRACE body RBRACE .)
    WHILE           reduce using rule 20 (block -> LBRACE body RBRACE .)
    FOR             reduce using rule 20 (block -> LBRACE body RBRACE .)
    LBRACE          reduce using rule 20 (block -> LBRACE body RBRACE .)
    DEF             reduce using rule 20 (block -> LBRACE body RBRACE .)
    LBRACKET        reduce using rule 20 (block -> LBRACE body RBRACE .)
    RBRACE          reduce using rule 20 (block -> LBRACE body RBRACE .)
    ELSE            reduce using rule 20 (block -> LBRACE body RBRACE .)


state 90

    (43) operation_on_list -> expr LBRACKET expr . RBRACKET
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    RBRACKET        shift and go to state 113
    LBRACKET        shift and go to state 57
    QUESTIONMARK    shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULO          shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    EQ              shift and go to state 66
    LE              shift and go to state 67
    GE              shift and go to state 68
    NE              shift and go to state 69
    LOR             shift and go to state 70
    LAND            shift and go to state 71


state 91

    (47) ternary_expr -> expr QUESTIONMARK expr . COLON expr
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    COLON           shift and go to state 114
    LBRACKET        shift and go to state 57
    QUESTIONMARK    shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULO          shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    EQ              shift and go to state 66
    LE              shift and go to state 67
    GE              shift and go to state 68
    NE              shift and go to state 69
    LOR             shift and go to state 70
    LAND            shift and go to state 71


state 92

    (49) binary_expr -> expr PLUS expr .
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 49 (binary_expr -> expr PLUS expr .)
    LBRACKET        reduce using rule 49 (binary_expr -> expr PLUS expr .)
    PLUS            reduce using rule 49 (binary_expr -> expr PLUS expr .)
    MINUS           reduce using rule 49 (binary_expr -> expr PLUS expr .)
    GT              reduce using rule 49 (binary_expr -> expr PLUS expr .)
    LT              reduce using rule 49 (binary_expr -> expr PLUS expr .)
    EQ              reduce using rule 49 (binary_expr -> expr PLUS expr .)
    LE              reduce using rule 49 (binary_expr -> expr PLUS expr .)
    GE              reduce using rule 49 (binary_expr -> expr PLUS expr .)
    NE              reduce using rule 49 (binary_expr -> expr PLUS expr .)
    LOR             reduce using rule 49 (binary_expr -> expr PLUS expr .)
    LAND            reduce using rule 49 (binary_expr -> expr PLUS expr .)
    COMMA           reduce using rule 49 (binary_expr -> expr PLUS expr .)
    RBRACKET        reduce using rule 49 (binary_expr -> expr PLUS expr .)
    RPAREN          reduce using rule 49 (binary_expr -> expr PLUS expr .)
    COLON           reduce using rule 49 (binary_expr -> expr PLUS expr .)
    TO              reduce using rule 49 (binary_expr -> expr PLUS expr .)
    QUESTIONMARK    shift and go to state 58
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULO          shift and go to state 63

  ! QUESTIONMARK    [ reduce using rule 49 (binary_expr -> expr PLUS expr .) ]
  ! TIMES           [ reduce using rule 49 (binary_expr -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 49 (binary_expr -> expr PLUS expr .) ]
  ! MODULO          [ reduce using rule 49 (binary_expr -> expr PLUS expr .) ]
  ! LBRACKET        [ shift and go to state 57 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 60 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! EQ              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! NE              [ shift and go to state 69 ]
  ! LOR             [ shift and go to state 70 ]
  ! LAND            [ shift and go to state 71 ]


state 93

    (50) binary_expr -> expr MINUS expr .
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 50 (binary_expr -> expr MINUS expr .)
    LBRACKET        reduce using rule 50 (binary_expr -> expr MINUS expr .)
    PLUS            reduce using rule 50 (binary_expr -> expr MINUS expr .)
    MINUS           reduce using rule 50 (binary_expr -> expr MINUS expr .)
    GT              reduce using rule 50 (binary_expr -> expr MINUS expr .)
    LT              reduce using rule 50 (binary_expr -> expr MINUS expr .)
    EQ              reduce using rule 50 (binary_expr -> expr MINUS expr .)
    LE              reduce using rule 50 (binary_expr -> expr MINUS expr .)
    GE              reduce using rule 50 (binary_expr -> expr MINUS expr .)
    NE              reduce using rule 50 (binary_expr -> expr MINUS expr .)
    LOR             reduce using rule 50 (binary_expr -> expr MINUS expr .)
    LAND            reduce using rule 50 (binary_expr -> expr MINUS expr .)
    COMMA           reduce using rule 50 (binary_expr -> expr MINUS expr .)
    RBRACKET        reduce using rule 50 (binary_expr -> expr MINUS expr .)
    RPAREN          reduce using rule 50 (binary_expr -> expr MINUS expr .)
    COLON           reduce using rule 50 (binary_expr -> expr MINUS expr .)
    TO              reduce using rule 50 (binary_expr -> expr MINUS expr .)
    QUESTIONMARK    shift and go to state 58
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULO          shift and go to state 63

  ! QUESTIONMARK    [ reduce using rule 50 (binary_expr -> expr MINUS expr .) ]
  ! TIMES           [ reduce using rule 50 (binary_expr -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 50 (binary_expr -> expr MINUS expr .) ]
  ! MODULO          [ reduce using rule 50 (binary_expr -> expr MINUS expr .) ]
  ! LBRACKET        [ shift and go to state 57 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 60 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! EQ              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! NE              [ shift and go to state 69 ]
  ! LOR             [ shift and go to state 70 ]
  ! LAND            [ shift and go to state 71 ]


state 94

    (51) binary_expr -> expr TIMES expr .
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 51 (binary_expr -> expr TIMES expr .)
    LBRACKET        reduce using rule 51 (binary_expr -> expr TIMES expr .)
    PLUS            reduce using rule 51 (binary_expr -> expr TIMES expr .)
    MINUS           reduce using rule 51 (binary_expr -> expr TIMES expr .)
    TIMES           reduce using rule 51 (binary_expr -> expr TIMES expr .)
    DIVIDE          reduce using rule 51 (binary_expr -> expr TIMES expr .)
    MODULO          reduce using rule 51 (binary_expr -> expr TIMES expr .)
    GT              reduce using rule 51 (binary_expr -> expr TIMES expr .)
    LT              reduce using rule 51 (binary_expr -> expr TIMES expr .)
    EQ              reduce using rule 51 (binary_expr -> expr TIMES expr .)
    LE              reduce using rule 51 (binary_expr -> expr TIMES expr .)
    GE              reduce using rule 51 (binary_expr -> expr TIMES expr .)
    NE              reduce using rule 51 (binary_expr -> expr TIMES expr .)
    LOR             reduce using rule 51 (binary_expr -> expr TIMES expr .)
    LAND            reduce using rule 51 (binary_expr -> expr TIMES expr .)
    COMMA           reduce using rule 51 (binary_expr -> expr TIMES expr .)
    RBRACKET        reduce using rule 51 (binary_expr -> expr TIMES expr .)
    RPAREN          reduce using rule 51 (binary_expr -> expr TIMES expr .)
    COLON           reduce using rule 51 (binary_expr -> expr TIMES expr .)
    TO              reduce using rule 51 (binary_expr -> expr TIMES expr .)
    QUESTIONMARK    shift and go to state 58

  ! QUESTIONMARK    [ reduce using rule 51 (binary_expr -> expr TIMES expr .) ]
  ! LBRACKET        [ shift and go to state 57 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 60 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 62 ]
  ! MODULO          [ shift and go to state 63 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! EQ              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! NE              [ shift and go to state 69 ]
  ! LOR             [ shift and go to state 70 ]
  ! LAND            [ shift and go to state 71 ]


state 95

    (52) binary_expr -> expr DIVIDE expr .
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 52 (binary_expr -> expr DIVIDE expr .)
    LBRACKET        reduce using rule 52 (binary_expr -> expr DIVIDE expr .)
    PLUS            reduce using rule 52 (binary_expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 52 (binary_expr -> expr DIVIDE expr .)
    TIMES           reduce using rule 52 (binary_expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 52 (binary_expr -> expr DIVIDE expr .)
    MODULO          reduce using rule 52 (binary_expr -> expr DIVIDE expr .)
    GT              reduce using rule 52 (binary_expr -> expr DIVIDE expr .)
    LT              reduce using rule 52 (binary_expr -> expr DIVIDE expr .)
    EQ              reduce using rule 52 (binary_expr -> expr DIVIDE expr .)
    LE              reduce using rule 52 (binary_expr -> expr DIVIDE expr .)
    GE              reduce using rule 52 (binary_expr -> expr DIVIDE expr .)
    NE              reduce using rule 52 (binary_expr -> expr DIVIDE expr .)
    LOR             reduce using rule 52 (binary_expr -> expr DIVIDE expr .)
    LAND            reduce using rule 52 (binary_expr -> expr DIVIDE expr .)
    COMMA           reduce using rule 52 (binary_expr -> expr DIVIDE expr .)
    RBRACKET        reduce using rule 52 (binary_expr -> expr DIVIDE expr .)
    RPAREN          reduce using rule 52 (binary_expr -> expr DIVIDE expr .)
    COLON           reduce using rule 52 (binary_expr -> expr DIVIDE expr .)
    TO              reduce using rule 52 (binary_expr -> expr DIVIDE expr .)
    QUESTIONMARK    shift and go to state 58

  ! QUESTIONMARK    [ reduce using rule 52 (binary_expr -> expr DIVIDE expr .) ]
  ! LBRACKET        [ shift and go to state 57 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 60 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 62 ]
  ! MODULO          [ shift and go to state 63 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! EQ              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! NE              [ shift and go to state 69 ]
  ! LOR             [ shift and go to state 70 ]
  ! LAND            [ shift and go to state 71 ]


state 96

    (53) binary_expr -> expr MODULO expr .
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 53 (binary_expr -> expr MODULO expr .)
    LBRACKET        reduce using rule 53 (binary_expr -> expr MODULO expr .)
    PLUS            reduce using rule 53 (binary_expr -> expr MODULO expr .)
    MINUS           reduce using rule 53 (binary_expr -> expr MODULO expr .)
    TIMES           reduce using rule 53 (binary_expr -> expr MODULO expr .)
    DIVIDE          reduce using rule 53 (binary_expr -> expr MODULO expr .)
    MODULO          reduce using rule 53 (binary_expr -> expr MODULO expr .)
    GT              reduce using rule 53 (binary_expr -> expr MODULO expr .)
    LT              reduce using rule 53 (binary_expr -> expr MODULO expr .)
    EQ              reduce using rule 53 (binary_expr -> expr MODULO expr .)
    LE              reduce using rule 53 (binary_expr -> expr MODULO expr .)
    GE              reduce using rule 53 (binary_expr -> expr MODULO expr .)
    NE              reduce using rule 53 (binary_expr -> expr MODULO expr .)
    LOR             reduce using rule 53 (binary_expr -> expr MODULO expr .)
    LAND            reduce using rule 53 (binary_expr -> expr MODULO expr .)
    COMMA           reduce using rule 53 (binary_expr -> expr MODULO expr .)
    RBRACKET        reduce using rule 53 (binary_expr -> expr MODULO expr .)
    RPAREN          reduce using rule 53 (binary_expr -> expr MODULO expr .)
    COLON           reduce using rule 53 (binary_expr -> expr MODULO expr .)
    TO              reduce using rule 53 (binary_expr -> expr MODULO expr .)
    QUESTIONMARK    shift and go to state 58

  ! QUESTIONMARK    [ reduce using rule 53 (binary_expr -> expr MODULO expr .) ]
  ! LBRACKET        [ shift and go to state 57 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 60 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 62 ]
  ! MODULO          [ shift and go to state 63 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! EQ              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! NE              [ shift and go to state 69 ]
  ! LOR             [ shift and go to state 70 ]
  ! LAND            [ shift and go to state 71 ]


state 97

    (54) binary_expr -> expr GT expr .
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 54 (binary_expr -> expr GT expr .)
    LBRACKET        reduce using rule 54 (binary_expr -> expr GT expr .)
    GT              reduce using rule 54 (binary_expr -> expr GT expr .)
    LT              reduce using rule 54 (binary_expr -> expr GT expr .)
    EQ              reduce using rule 54 (binary_expr -> expr GT expr .)
    LE              reduce using rule 54 (binary_expr -> expr GT expr .)
    GE              reduce using rule 54 (binary_expr -> expr GT expr .)
    NE              reduce using rule 54 (binary_expr -> expr GT expr .)
    LOR             reduce using rule 54 (binary_expr -> expr GT expr .)
    LAND            reduce using rule 54 (binary_expr -> expr GT expr .)
    COMMA           reduce using rule 54 (binary_expr -> expr GT expr .)
    RBRACKET        reduce using rule 54 (binary_expr -> expr GT expr .)
    RPAREN          reduce using rule 54 (binary_expr -> expr GT expr .)
    COLON           reduce using rule 54 (binary_expr -> expr GT expr .)
    TO              reduce using rule 54 (binary_expr -> expr GT expr .)
    QUESTIONMARK    shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULO          shift and go to state 63

  ! QUESTIONMARK    [ reduce using rule 54 (binary_expr -> expr GT expr .) ]
  ! PLUS            [ reduce using rule 54 (binary_expr -> expr GT expr .) ]
  ! MINUS           [ reduce using rule 54 (binary_expr -> expr GT expr .) ]
  ! TIMES           [ reduce using rule 54 (binary_expr -> expr GT expr .) ]
  ! DIVIDE          [ reduce using rule 54 (binary_expr -> expr GT expr .) ]
  ! MODULO          [ reduce using rule 54 (binary_expr -> expr GT expr .) ]
  ! LBRACKET        [ shift and go to state 57 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! EQ              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! NE              [ shift and go to state 69 ]
  ! LOR             [ shift and go to state 70 ]
  ! LAND            [ shift and go to state 71 ]


state 98

    (55) binary_expr -> expr LT expr .
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 55 (binary_expr -> expr LT expr .)
    LBRACKET        reduce using rule 55 (binary_expr -> expr LT expr .)
    GT              reduce using rule 55 (binary_expr -> expr LT expr .)
    LT              reduce using rule 55 (binary_expr -> expr LT expr .)
    EQ              reduce using rule 55 (binary_expr -> expr LT expr .)
    LE              reduce using rule 55 (binary_expr -> expr LT expr .)
    GE              reduce using rule 55 (binary_expr -> expr LT expr .)
    NE              reduce using rule 55 (binary_expr -> expr LT expr .)
    LOR             reduce using rule 55 (binary_expr -> expr LT expr .)
    LAND            reduce using rule 55 (binary_expr -> expr LT expr .)
    COMMA           reduce using rule 55 (binary_expr -> expr LT expr .)
    RBRACKET        reduce using rule 55 (binary_expr -> expr LT expr .)
    RPAREN          reduce using rule 55 (binary_expr -> expr LT expr .)
    COLON           reduce using rule 55 (binary_expr -> expr LT expr .)
    TO              reduce using rule 55 (binary_expr -> expr LT expr .)
    QUESTIONMARK    shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULO          shift and go to state 63

  ! QUESTIONMARK    [ reduce using rule 55 (binary_expr -> expr LT expr .) ]
  ! PLUS            [ reduce using rule 55 (binary_expr -> expr LT expr .) ]
  ! MINUS           [ reduce using rule 55 (binary_expr -> expr LT expr .) ]
  ! TIMES           [ reduce using rule 55 (binary_expr -> expr LT expr .) ]
  ! DIVIDE          [ reduce using rule 55 (binary_expr -> expr LT expr .) ]
  ! MODULO          [ reduce using rule 55 (binary_expr -> expr LT expr .) ]
  ! LBRACKET        [ shift and go to state 57 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! EQ              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! NE              [ shift and go to state 69 ]
  ! LOR             [ shift and go to state 70 ]
  ! LAND            [ shift and go to state 71 ]


state 99

    (56) binary_expr -> expr EQ expr .
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 56 (binary_expr -> expr EQ expr .)
    LBRACKET        reduce using rule 56 (binary_expr -> expr EQ expr .)
    GT              reduce using rule 56 (binary_expr -> expr EQ expr .)
    LT              reduce using rule 56 (binary_expr -> expr EQ expr .)
    EQ              reduce using rule 56 (binary_expr -> expr EQ expr .)
    LE              reduce using rule 56 (binary_expr -> expr EQ expr .)
    GE              reduce using rule 56 (binary_expr -> expr EQ expr .)
    NE              reduce using rule 56 (binary_expr -> expr EQ expr .)
    LOR             reduce using rule 56 (binary_expr -> expr EQ expr .)
    LAND            reduce using rule 56 (binary_expr -> expr EQ expr .)
    COMMA           reduce using rule 56 (binary_expr -> expr EQ expr .)
    RBRACKET        reduce using rule 56 (binary_expr -> expr EQ expr .)
    RPAREN          reduce using rule 56 (binary_expr -> expr EQ expr .)
    COLON           reduce using rule 56 (binary_expr -> expr EQ expr .)
    TO              reduce using rule 56 (binary_expr -> expr EQ expr .)
    QUESTIONMARK    shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULO          shift and go to state 63

  ! QUESTIONMARK    [ reduce using rule 56 (binary_expr -> expr EQ expr .) ]
  ! PLUS            [ reduce using rule 56 (binary_expr -> expr EQ expr .) ]
  ! MINUS           [ reduce using rule 56 (binary_expr -> expr EQ expr .) ]
  ! TIMES           [ reduce using rule 56 (binary_expr -> expr EQ expr .) ]
  ! DIVIDE          [ reduce using rule 56 (binary_expr -> expr EQ expr .) ]
  ! MODULO          [ reduce using rule 56 (binary_expr -> expr EQ expr .) ]
  ! LBRACKET        [ shift and go to state 57 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! EQ              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! NE              [ shift and go to state 69 ]
  ! LOR             [ shift and go to state 70 ]
  ! LAND            [ shift and go to state 71 ]


state 100

    (57) binary_expr -> expr LE expr .
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 57 (binary_expr -> expr LE expr .)
    LBRACKET        reduce using rule 57 (binary_expr -> expr LE expr .)
    GT              reduce using rule 57 (binary_expr -> expr LE expr .)
    LT              reduce using rule 57 (binary_expr -> expr LE expr .)
    EQ              reduce using rule 57 (binary_expr -> expr LE expr .)
    LE              reduce using rule 57 (binary_expr -> expr LE expr .)
    GE              reduce using rule 57 (binary_expr -> expr LE expr .)
    NE              reduce using rule 57 (binary_expr -> expr LE expr .)
    LOR             reduce using rule 57 (binary_expr -> expr LE expr .)
    LAND            reduce using rule 57 (binary_expr -> expr LE expr .)
    COMMA           reduce using rule 57 (binary_expr -> expr LE expr .)
    RBRACKET        reduce using rule 57 (binary_expr -> expr LE expr .)
    RPAREN          reduce using rule 57 (binary_expr -> expr LE expr .)
    COLON           reduce using rule 57 (binary_expr -> expr LE expr .)
    TO              reduce using rule 57 (binary_expr -> expr LE expr .)
    QUESTIONMARK    shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULO          shift and go to state 63

  ! QUESTIONMARK    [ reduce using rule 57 (binary_expr -> expr LE expr .) ]
  ! PLUS            [ reduce using rule 57 (binary_expr -> expr LE expr .) ]
  ! MINUS           [ reduce using rule 57 (binary_expr -> expr LE expr .) ]
  ! TIMES           [ reduce using rule 57 (binary_expr -> expr LE expr .) ]
  ! DIVIDE          [ reduce using rule 57 (binary_expr -> expr LE expr .) ]
  ! MODULO          [ reduce using rule 57 (binary_expr -> expr LE expr .) ]
  ! LBRACKET        [ shift and go to state 57 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! EQ              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! NE              [ shift and go to state 69 ]
  ! LOR             [ shift and go to state 70 ]
  ! LAND            [ shift and go to state 71 ]


state 101

    (58) binary_expr -> expr GE expr .
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 58 (binary_expr -> expr GE expr .)
    LBRACKET        reduce using rule 58 (binary_expr -> expr GE expr .)
    GT              reduce using rule 58 (binary_expr -> expr GE expr .)
    LT              reduce using rule 58 (binary_expr -> expr GE expr .)
    EQ              reduce using rule 58 (binary_expr -> expr GE expr .)
    LE              reduce using rule 58 (binary_expr -> expr GE expr .)
    GE              reduce using rule 58 (binary_expr -> expr GE expr .)
    NE              reduce using rule 58 (binary_expr -> expr GE expr .)
    LOR             reduce using rule 58 (binary_expr -> expr GE expr .)
    LAND            reduce using rule 58 (binary_expr -> expr GE expr .)
    COMMA           reduce using rule 58 (binary_expr -> expr GE expr .)
    RBRACKET        reduce using rule 58 (binary_expr -> expr GE expr .)
    RPAREN          reduce using rule 58 (binary_expr -> expr GE expr .)
    COLON           reduce using rule 58 (binary_expr -> expr GE expr .)
    TO              reduce using rule 58 (binary_expr -> expr GE expr .)
    QUESTIONMARK    shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULO          shift and go to state 63

  ! QUESTIONMARK    [ reduce using rule 58 (binary_expr -> expr GE expr .) ]
  ! PLUS            [ reduce using rule 58 (binary_expr -> expr GE expr .) ]
  ! MINUS           [ reduce using rule 58 (binary_expr -> expr GE expr .) ]
  ! TIMES           [ reduce using rule 58 (binary_expr -> expr GE expr .) ]
  ! DIVIDE          [ reduce using rule 58 (binary_expr -> expr GE expr .) ]
  ! MODULO          [ reduce using rule 58 (binary_expr -> expr GE expr .) ]
  ! LBRACKET        [ shift and go to state 57 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! EQ              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! NE              [ shift and go to state 69 ]
  ! LOR             [ shift and go to state 70 ]
  ! LAND            [ shift and go to state 71 ]


state 102

    (59) binary_expr -> expr NE expr .
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 59 (binary_expr -> expr NE expr .)
    LBRACKET        reduce using rule 59 (binary_expr -> expr NE expr .)
    GT              reduce using rule 59 (binary_expr -> expr NE expr .)
    LT              reduce using rule 59 (binary_expr -> expr NE expr .)
    EQ              reduce using rule 59 (binary_expr -> expr NE expr .)
    LE              reduce using rule 59 (binary_expr -> expr NE expr .)
    GE              reduce using rule 59 (binary_expr -> expr NE expr .)
    NE              reduce using rule 59 (binary_expr -> expr NE expr .)
    LOR             reduce using rule 59 (binary_expr -> expr NE expr .)
    LAND            reduce using rule 59 (binary_expr -> expr NE expr .)
    COMMA           reduce using rule 59 (binary_expr -> expr NE expr .)
    RBRACKET        reduce using rule 59 (binary_expr -> expr NE expr .)
    RPAREN          reduce using rule 59 (binary_expr -> expr NE expr .)
    COLON           reduce using rule 59 (binary_expr -> expr NE expr .)
    TO              reduce using rule 59 (binary_expr -> expr NE expr .)
    QUESTIONMARK    shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULO          shift and go to state 63

  ! QUESTIONMARK    [ reduce using rule 59 (binary_expr -> expr NE expr .) ]
  ! PLUS            [ reduce using rule 59 (binary_expr -> expr NE expr .) ]
  ! MINUS           [ reduce using rule 59 (binary_expr -> expr NE expr .) ]
  ! TIMES           [ reduce using rule 59 (binary_expr -> expr NE expr .) ]
  ! DIVIDE          [ reduce using rule 59 (binary_expr -> expr NE expr .) ]
  ! MODULO          [ reduce using rule 59 (binary_expr -> expr NE expr .) ]
  ! LBRACKET        [ shift and go to state 57 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! EQ              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! NE              [ shift and go to state 69 ]
  ! LOR             [ shift and go to state 70 ]
  ! LAND            [ shift and go to state 71 ]


state 103

    (60) binary_expr -> expr LOR expr .
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 60 (binary_expr -> expr LOR expr .)
    LBRACKET        reduce using rule 60 (binary_expr -> expr LOR expr .)
    LOR             reduce using rule 60 (binary_expr -> expr LOR expr .)
    COMMA           reduce using rule 60 (binary_expr -> expr LOR expr .)
    RBRACKET        reduce using rule 60 (binary_expr -> expr LOR expr .)
    RPAREN          reduce using rule 60 (binary_expr -> expr LOR expr .)
    COLON           reduce using rule 60 (binary_expr -> expr LOR expr .)
    TO              reduce using rule 60 (binary_expr -> expr LOR expr .)
    QUESTIONMARK    shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULO          shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    EQ              shift and go to state 66
    LE              shift and go to state 67
    GE              shift and go to state 68
    NE              shift and go to state 69
    LAND            shift and go to state 71

  ! QUESTIONMARK    [ reduce using rule 60 (binary_expr -> expr LOR expr .) ]
  ! PLUS            [ reduce using rule 60 (binary_expr -> expr LOR expr .) ]
  ! MINUS           [ reduce using rule 60 (binary_expr -> expr LOR expr .) ]
  ! TIMES           [ reduce using rule 60 (binary_expr -> expr LOR expr .) ]
  ! DIVIDE          [ reduce using rule 60 (binary_expr -> expr LOR expr .) ]
  ! MODULO          [ reduce using rule 60 (binary_expr -> expr LOR expr .) ]
  ! GT              [ reduce using rule 60 (binary_expr -> expr LOR expr .) ]
  ! LT              [ reduce using rule 60 (binary_expr -> expr LOR expr .) ]
  ! EQ              [ reduce using rule 60 (binary_expr -> expr LOR expr .) ]
  ! LE              [ reduce using rule 60 (binary_expr -> expr LOR expr .) ]
  ! GE              [ reduce using rule 60 (binary_expr -> expr LOR expr .) ]
  ! NE              [ reduce using rule 60 (binary_expr -> expr LOR expr .) ]
  ! LAND            [ reduce using rule 60 (binary_expr -> expr LOR expr .) ]
  ! LBRACKET        [ shift and go to state 57 ]
  ! LOR             [ shift and go to state 70 ]


state 104

    (61) binary_expr -> expr LAND expr .
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 61 (binary_expr -> expr LAND expr .)
    LBRACKET        reduce using rule 61 (binary_expr -> expr LAND expr .)
    LOR             reduce using rule 61 (binary_expr -> expr LAND expr .)
    LAND            reduce using rule 61 (binary_expr -> expr LAND expr .)
    COMMA           reduce using rule 61 (binary_expr -> expr LAND expr .)
    RBRACKET        reduce using rule 61 (binary_expr -> expr LAND expr .)
    RPAREN          reduce using rule 61 (binary_expr -> expr LAND expr .)
    COLON           reduce using rule 61 (binary_expr -> expr LAND expr .)
    TO              reduce using rule 61 (binary_expr -> expr LAND expr .)
    QUESTIONMARK    shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULO          shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    EQ              shift and go to state 66
    LE              shift and go to state 67
    GE              shift and go to state 68
    NE              shift and go to state 69

  ! QUESTIONMARK    [ reduce using rule 61 (binary_expr -> expr LAND expr .) ]
  ! PLUS            [ reduce using rule 61 (binary_expr -> expr LAND expr .) ]
  ! MINUS           [ reduce using rule 61 (binary_expr -> expr LAND expr .) ]
  ! TIMES           [ reduce using rule 61 (binary_expr -> expr LAND expr .) ]
  ! DIVIDE          [ reduce using rule 61 (binary_expr -> expr LAND expr .) ]
  ! MODULO          [ reduce using rule 61 (binary_expr -> expr LAND expr .) ]
  ! GT              [ reduce using rule 61 (binary_expr -> expr LAND expr .) ]
  ! LT              [ reduce using rule 61 (binary_expr -> expr LAND expr .) ]
  ! EQ              [ reduce using rule 61 (binary_expr -> expr LAND expr .) ]
  ! LE              [ reduce using rule 61 (binary_expr -> expr LAND expr .) ]
  ! GE              [ reduce using rule 61 (binary_expr -> expr LAND expr .) ]
  ! NE              [ reduce using rule 61 (binary_expr -> expr LAND expr .) ]
  ! LBRACKET        [ shift and go to state 57 ]
  ! LOR             [ shift and go to state 70 ]
  ! LAND            [ shift and go to state 71 ]


state 105

    (22) defvar -> VAR TYPE ID .
    (23) defvar -> VAR TYPE ID . EQUALS expr

    SEMI            reduce using rule 22 (defvar -> VAR TYPE ID .)
    EQUALS          shift and go to state 115


state 106

    (16) single_if -> IF LPAREN expr . RPAREN stmt
    (17) if_with_else -> IF LPAREN expr . RPAREN stmt ELSE stmt
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    RPAREN          shift and go to state 116
    LBRACKET        shift and go to state 57
    QUESTIONMARK    shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULO          shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    EQ              shift and go to state 66
    LE              shift and go to state 67
    GE              shift and go to state 68
    NE              shift and go to state 69
    LOR             shift and go to state 70
    LAND            shift and go to state 71


state 107

    (18) while_loop -> WHILE LPAREN expr . RPAREN stmt
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    RPAREN          shift and go to state 117
    LBRACKET        shift and go to state 57
    QUESTIONMARK    shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULO          shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    EQ              shift and go to state 66
    LE              shift and go to state 67
    GE              shift and go to state 68
    NE              shift and go to state 69
    LOR             shift and go to state 70
    LAND            shift and go to state 71


state 108

    (19) for_loop -> FOR LPAREN ID . EQUALS expr TO expr RPAREN stmt

    EQUALS          shift and go to state 118


state 109

    (42) expr_list -> LBRACKET clist RBRACKET .

    SEMI            reduce using rule 42 (expr_list -> LBRACKET clist RBRACKET .)
    LBRACKET        reduce using rule 42 (expr_list -> LBRACKET clist RBRACKET .)
    QUESTIONMARK    reduce using rule 42 (expr_list -> LBRACKET clist RBRACKET .)
    PLUS            reduce using rule 42 (expr_list -> LBRACKET clist RBRACKET .)
    MINUS           reduce using rule 42 (expr_list -> LBRACKET clist RBRACKET .)
    TIMES           reduce using rule 42 (expr_list -> LBRACKET clist RBRACKET .)
    DIVIDE          reduce using rule 42 (expr_list -> LBRACKET clist RBRACKET .)
    MODULO          reduce using rule 42 (expr_list -> LBRACKET clist RBRACKET .)
    GT              reduce using rule 42 (expr_list -> LBRACKET clist RBRACKET .)
    LT              reduce using rule 42 (expr_list -> LBRACKET clist RBRACKET .)
    EQ              reduce using rule 42 (expr_list -> LBRACKET clist RBRACKET .)
    LE              reduce using rule 42 (expr_list -> LBRACKET clist RBRACKET .)
    GE              reduce using rule 42 (expr_list -> LBRACKET clist RBRACKET .)
    NE              reduce using rule 42 (expr_list -> LBRACKET clist RBRACKET .)
    LOR             reduce using rule 42 (expr_list -> LBRACKET clist RBRACKET .)
    LAND            reduce using rule 42 (expr_list -> LBRACKET clist RBRACKET .)
    COMMA           reduce using rule 42 (expr_list -> LBRACKET clist RBRACKET .)
    RBRACKET        reduce using rule 42 (expr_list -> LBRACKET clist RBRACKET .)
    RPAREN          reduce using rule 42 (expr_list -> LBRACKET clist RBRACKET .)
    COLON           reduce using rule 42 (expr_list -> LBRACKET clist RBRACKET .)
    TO              reduce using rule 42 (expr_list -> LBRACKET clist RBRACKET .)


state 110

    (29) clist -> expr COMMA . clist
    (27) clist -> . empty
    (28) clist -> . expr
    (29) clist -> . expr COMMA clist
    (62) empty -> .
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    RBRACKET        reduce using rule 62 (empty -> .)
    RPAREN          reduce using rule 62 (empty -> .)
    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 84
    clist                          shift and go to state 119
    empty                          shift and go to state 83
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 111

    (44) operation_on_list -> ID LBRACKET expr RBRACKET .
    (46) assignment -> ID LBRACKET expr RBRACKET . EQUALS expr

    SEMI            reduce using rule 44 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    LBRACKET        reduce using rule 44 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    QUESTIONMARK    reduce using rule 44 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 44 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 44 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    TIMES           reduce using rule 44 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 44 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    MODULO          reduce using rule 44 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    GT              reduce using rule 44 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    LT              reduce using rule 44 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    EQ              reduce using rule 44 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    LE              reduce using rule 44 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    GE              reduce using rule 44 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    NE              reduce using rule 44 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    LOR             reduce using rule 44 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    LAND            reduce using rule 44 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 44 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 44 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 44 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    COLON           reduce using rule 44 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    TO              reduce using rule 44 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    EQUALS          shift and go to state 120


state 112

    (48) function_call -> ID LPAREN clist RPAREN .

    SEMI            reduce using rule 48 (function_call -> ID LPAREN clist RPAREN .)
    LBRACKET        reduce using rule 48 (function_call -> ID LPAREN clist RPAREN .)
    QUESTIONMARK    reduce using rule 48 (function_call -> ID LPAREN clist RPAREN .)
    PLUS            reduce using rule 48 (function_call -> ID LPAREN clist RPAREN .)
    MINUS           reduce using rule 48 (function_call -> ID LPAREN clist RPAREN .)
    TIMES           reduce using rule 48 (function_call -> ID LPAREN clist RPAREN .)
    DIVIDE          reduce using rule 48 (function_call -> ID LPAREN clist RPAREN .)
    MODULO          reduce using rule 48 (function_call -> ID LPAREN clist RPAREN .)
    GT              reduce using rule 48 (function_call -> ID LPAREN clist RPAREN .)
    LT              reduce using rule 48 (function_call -> ID LPAREN clist RPAREN .)
    EQ              reduce using rule 48 (function_call -> ID LPAREN clist RPAREN .)
    LE              reduce using rule 48 (function_call -> ID LPAREN clist RPAREN .)
    GE              reduce using rule 48 (function_call -> ID LPAREN clist RPAREN .)
    NE              reduce using rule 48 (function_call -> ID LPAREN clist RPAREN .)
    LOR             reduce using rule 48 (function_call -> ID LPAREN clist RPAREN .)
    LAND            reduce using rule 48 (function_call -> ID LPAREN clist RPAREN .)
    COMMA           reduce using rule 48 (function_call -> ID LPAREN clist RPAREN .)
    RBRACKET        reduce using rule 48 (function_call -> ID LPAREN clist RPAREN .)
    RPAREN          reduce using rule 48 (function_call -> ID LPAREN clist RPAREN .)
    COLON           reduce using rule 48 (function_call -> ID LPAREN clist RPAREN .)
    TO              reduce using rule 48 (function_call -> ID LPAREN clist RPAREN .)


state 113

    (43) operation_on_list -> expr LBRACKET expr RBRACKET .

    SEMI            reduce using rule 43 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    LBRACKET        reduce using rule 43 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    QUESTIONMARK    reduce using rule 43 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 43 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 43 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    TIMES           reduce using rule 43 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 43 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    MODULO          reduce using rule 43 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    GT              reduce using rule 43 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    LT              reduce using rule 43 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    EQ              reduce using rule 43 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    LE              reduce using rule 43 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    GE              reduce using rule 43 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    NE              reduce using rule 43 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    LOR             reduce using rule 43 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    LAND            reduce using rule 43 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 43 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 43 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 43 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    COLON           reduce using rule 43 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    TO              reduce using rule 43 (operation_on_list -> expr LBRACKET expr RBRACKET .)


state 114

    (47) ternary_expr -> expr QUESTIONMARK expr COLON . expr
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 121
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 115

    (23) defvar -> VAR TYPE ID EQUALS . expr
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 122
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 116

    (16) single_if -> IF LPAREN expr RPAREN . stmt
    (17) if_with_else -> IF LPAREN expr RPAREN . stmt ELSE stmt
    (7) stmt -> . expr SEMI
    (8) stmt -> . defvar SEMI
    (9) stmt -> . return_instr SEMI
    (10) stmt -> . single_if
    (11) stmt -> . if_with_else
    (12) stmt -> . while_loop
    (13) stmt -> . for_loop
    (14) stmt -> . block
    (15) stmt -> . func
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (22) defvar -> . VAR TYPE ID
    (23) defvar -> . VAR TYPE ID EQUALS expr
    (21) return_instr -> . RETURN expr
    (16) single_if -> . IF LPAREN expr RPAREN stmt
    (17) if_with_else -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (18) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (19) for_loop -> . FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
    (20) block -> . LBRACE body RBRACE
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    VAR             shift and go to state 43
    RETURN          shift and go to state 44
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    FOR             shift and go to state 47
    LBRACE          shift and go to state 19
    DEF             shift and go to state 4
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 23
    stmt                           shift and go to state 123
    defvar                         shift and go to state 24
    return_instr                   shift and go to state 25
    single_if                      shift and go to state 26
    if_with_else                   shift and go to state 27
    while_loop                     shift and go to state 28
    for_loop                       shift and go to state 29
    block                          shift and go to state 30
    func                           shift and go to state 31
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 117

    (18) while_loop -> WHILE LPAREN expr RPAREN . stmt
    (7) stmt -> . expr SEMI
    (8) stmt -> . defvar SEMI
    (9) stmt -> . return_instr SEMI
    (10) stmt -> . single_if
    (11) stmt -> . if_with_else
    (12) stmt -> . while_loop
    (13) stmt -> . for_loop
    (14) stmt -> . block
    (15) stmt -> . func
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (22) defvar -> . VAR TYPE ID
    (23) defvar -> . VAR TYPE ID EQUALS expr
    (21) return_instr -> . RETURN expr
    (16) single_if -> . IF LPAREN expr RPAREN stmt
    (17) if_with_else -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (18) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (19) for_loop -> . FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
    (20) block -> . LBRACE body RBRACE
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    VAR             shift and go to state 43
    RETURN          shift and go to state 44
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    FOR             shift and go to state 47
    LBRACE          shift and go to state 19
    DEF             shift and go to state 4
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 23
    stmt                           shift and go to state 124
    defvar                         shift and go to state 24
    return_instr                   shift and go to state 25
    single_if                      shift and go to state 26
    if_with_else                   shift and go to state 27
    while_loop                     shift and go to state 28
    for_loop                       shift and go to state 29
    block                          shift and go to state 30
    func                           shift and go to state 31
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 118

    (19) for_loop -> FOR LPAREN ID EQUALS . expr TO expr RPAREN stmt
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 125
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 119

    (29) clist -> expr COMMA clist .

    RBRACKET        reduce using rule 29 (clist -> expr COMMA clist .)
    RPAREN          reduce using rule 29 (clist -> expr COMMA clist .)


state 120

    (46) assignment -> ID LBRACKET expr RBRACKET EQUALS . expr
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 126
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 121

    (47) ternary_expr -> expr QUESTIONMARK expr COLON expr .
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 47 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    LBRACKET        reduce using rule 47 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    QUESTIONMARK    reduce using rule 47 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    PLUS            reduce using rule 47 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    MINUS           reduce using rule 47 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    TIMES           reduce using rule 47 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    DIVIDE          reduce using rule 47 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    MODULO          reduce using rule 47 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    GT              reduce using rule 47 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    LT              reduce using rule 47 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    EQ              reduce using rule 47 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    LE              reduce using rule 47 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    GE              reduce using rule 47 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    NE              reduce using rule 47 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    LOR             reduce using rule 47 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    LAND            reduce using rule 47 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    COMMA           reduce using rule 47 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    RBRACKET        reduce using rule 47 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    RPAREN          reduce using rule 47 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    COLON           reduce using rule 47 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    TO              reduce using rule 47 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)

  ! LBRACKET        [ shift and go to state 57 ]
  ! QUESTIONMARK    [ shift and go to state 58 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 60 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 62 ]
  ! MODULO          [ shift and go to state 63 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! EQ              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! NE              [ shift and go to state 69 ]
  ! LOR             [ shift and go to state 70 ]
  ! LAND            [ shift and go to state 71 ]


state 122

    (23) defvar -> VAR TYPE ID EQUALS expr .
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 23 (defvar -> VAR TYPE ID EQUALS expr .)
    LBRACKET        shift and go to state 57
    QUESTIONMARK    shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULO          shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    EQ              shift and go to state 66
    LE              shift and go to state 67
    GE              shift and go to state 68
    NE              shift and go to state 69
    LOR             shift and go to state 70
    LAND            shift and go to state 71


state 123

    (16) single_if -> IF LPAREN expr RPAREN stmt .
    (17) if_with_else -> IF LPAREN expr RPAREN stmt . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    LNOT            reduce using rule 16 (single_if -> IF LPAREN expr RPAREN stmt .)
    PLUS            reduce using rule 16 (single_if -> IF LPAREN expr RPAREN stmt .)
    MINUS           reduce using rule 16 (single_if -> IF LPAREN expr RPAREN stmt .)
    ID              reduce using rule 16 (single_if -> IF LPAREN expr RPAREN stmt .)
    NUMBER          reduce using rule 16 (single_if -> IF LPAREN expr RPAREN stmt .)
    STRING          reduce using rule 16 (single_if -> IF LPAREN expr RPAREN stmt .)
    VAR             reduce using rule 16 (single_if -> IF LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 16 (single_if -> IF LPAREN expr RPAREN stmt .)
    IF              reduce using rule 16 (single_if -> IF LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 16 (single_if -> IF LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 16 (single_if -> IF LPAREN expr RPAREN stmt .)
    LBRACE          reduce using rule 16 (single_if -> IF LPAREN expr RPAREN stmt .)
    DEF             reduce using rule 16 (single_if -> IF LPAREN expr RPAREN stmt .)
    LBRACKET        reduce using rule 16 (single_if -> IF LPAREN expr RPAREN stmt .)
    RBRACE          reduce using rule 16 (single_if -> IF LPAREN expr RPAREN stmt .)
    ELSE            shift and go to state 127

  ! ELSE            [ reduce using rule 16 (single_if -> IF LPAREN expr RPAREN stmt .) ]


state 124

    (18) while_loop -> WHILE LPAREN expr RPAREN stmt .

    LNOT            reduce using rule 18 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    PLUS            reduce using rule 18 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    MINUS           reduce using rule 18 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    ID              reduce using rule 18 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    NUMBER          reduce using rule 18 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    STRING          reduce using rule 18 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    VAR             reduce using rule 18 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 18 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    IF              reduce using rule 18 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 18 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 18 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    LBRACE          reduce using rule 18 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    DEF             reduce using rule 18 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    LBRACKET        reduce using rule 18 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    RBRACE          reduce using rule 18 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    ELSE            reduce using rule 18 (while_loop -> WHILE LPAREN expr RPAREN stmt .)


state 125

    (19) for_loop -> FOR LPAREN ID EQUALS expr . TO expr RPAREN stmt
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    TO              shift and go to state 128
    LBRACKET        shift and go to state 57
    QUESTIONMARK    shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULO          shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    EQ              shift and go to state 66
    LE              shift and go to state 67
    GE              shift and go to state 68
    NE              shift and go to state 69
    LOR             shift and go to state 70
    LAND            shift and go to state 71


state 126

    (46) assignment -> ID LBRACKET expr RBRACKET EQUALS expr .
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 46 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    LBRACKET        reduce using rule 46 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    QUESTIONMARK    reduce using rule 46 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    PLUS            reduce using rule 46 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    MINUS           reduce using rule 46 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    TIMES           reduce using rule 46 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    DIVIDE          reduce using rule 46 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    MODULO          reduce using rule 46 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    GT              reduce using rule 46 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    LT              reduce using rule 46 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    EQ              reduce using rule 46 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    LE              reduce using rule 46 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    GE              reduce using rule 46 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    NE              reduce using rule 46 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    LOR             reduce using rule 46 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    LAND            reduce using rule 46 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    COMMA           reduce using rule 46 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    RBRACKET        reduce using rule 46 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    RPAREN          reduce using rule 46 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    COLON           reduce using rule 46 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    TO              reduce using rule 46 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)

  ! LBRACKET        [ shift and go to state 57 ]
  ! QUESTIONMARK    [ shift and go to state 58 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 60 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 62 ]
  ! MODULO          [ shift and go to state 63 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! EQ              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! NE              [ shift and go to state 69 ]
  ! LOR             [ shift and go to state 70 ]
  ! LAND            [ shift and go to state 71 ]


state 127

    (17) if_with_else -> IF LPAREN expr RPAREN stmt ELSE . stmt
    (7) stmt -> . expr SEMI
    (8) stmt -> . defvar SEMI
    (9) stmt -> . return_instr SEMI
    (10) stmt -> . single_if
    (11) stmt -> . if_with_else
    (12) stmt -> . while_loop
    (13) stmt -> . for_loop
    (14) stmt -> . block
    (15) stmt -> . func
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (22) defvar -> . VAR TYPE ID
    (23) defvar -> . VAR TYPE ID EQUALS expr
    (21) return_instr -> . RETURN expr
    (16) single_if -> . IF LPAREN expr RPAREN stmt
    (17) if_with_else -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (18) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (19) for_loop -> . FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
    (20) block -> . LBRACE body RBRACE
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    VAR             shift and go to state 43
    RETURN          shift and go to state 44
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    FOR             shift and go to state 47
    LBRACE          shift and go to state 19
    DEF             shift and go to state 4
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 23
    stmt                           shift and go to state 129
    defvar                         shift and go to state 24
    return_instr                   shift and go to state 25
    single_if                      shift and go to state 26
    if_with_else                   shift and go to state 27
    while_loop                     shift and go to state 28
    for_loop                       shift and go to state 29
    block                          shift and go to state 30
    func                           shift and go to state 31
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 128

    (19) for_loop -> FOR LPAREN ID EQUALS expr TO . expr RPAREN stmt
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 130
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 129

    (17) if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .

    LNOT            reduce using rule 17 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    PLUS            reduce using rule 17 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    MINUS           reduce using rule 17 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    ID              reduce using rule 17 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    NUMBER          reduce using rule 17 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    STRING          reduce using rule 17 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    VAR             reduce using rule 17 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    RETURN          reduce using rule 17 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    IF              reduce using rule 17 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    WHILE           reduce using rule 17 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FOR             reduce using rule 17 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    LBRACE          reduce using rule 17 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    DEF             reduce using rule 17 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    LBRACKET        reduce using rule 17 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    RBRACE          reduce using rule 17 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    ELSE            reduce using rule 17 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)


state 130

    (19) for_loop -> FOR LPAREN ID EQUALS expr TO expr . RPAREN stmt
    (43) operation_on_list -> expr . LBRACKET expr RBRACKET
    (47) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (49) binary_expr -> expr . PLUS expr
    (50) binary_expr -> expr . MINUS expr
    (51) binary_expr -> expr . TIMES expr
    (52) binary_expr -> expr . DIVIDE expr
    (53) binary_expr -> expr . MODULO expr
    (54) binary_expr -> expr . GT expr
    (55) binary_expr -> expr . LT expr
    (56) binary_expr -> expr . EQ expr
    (57) binary_expr -> expr . LE expr
    (58) binary_expr -> expr . GE expr
    (59) binary_expr -> expr . NE expr
    (60) binary_expr -> expr . LOR expr
    (61) binary_expr -> expr . LAND expr

    RPAREN          shift and go to state 131
    LBRACKET        shift and go to state 57
    QUESTIONMARK    shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULO          shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    EQ              shift and go to state 66
    LE              shift and go to state 67
    GE              shift and go to state 68
    NE              shift and go to state 69
    LOR             shift and go to state 70
    LAND            shift and go to state 71


state 131

    (19) for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN . stmt
    (7) stmt -> . expr SEMI
    (8) stmt -> . defvar SEMI
    (9) stmt -> . return_instr SEMI
    (10) stmt -> . single_if
    (11) stmt -> . if_with_else
    (12) stmt -> . while_loop
    (13) stmt -> . for_loop
    (14) stmt -> . block
    (15) stmt -> . func
    (30) expr -> . operation_on_list
    (31) expr -> . expr_list
    (32) expr -> . ternary_expr
    (33) expr -> . LNOT expr
    (34) expr -> . PLUS expr
    (35) expr -> . MINUS expr
    (36) expr -> . binary_expr
    (37) expr -> . ID
    (38) expr -> . assignment
    (39) expr -> . function_call
    (40) expr -> . NUMBER
    (41) expr -> . STRING
    (22) defvar -> . VAR TYPE ID
    (23) defvar -> . VAR TYPE ID EQUALS expr
    (21) return_instr -> . RETURN expr
    (16) single_if -> . IF LPAREN expr RPAREN stmt
    (17) if_with_else -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (18) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (19) for_loop -> . FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
    (20) block -> . LBRACE body RBRACE
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (43) operation_on_list -> . expr LBRACKET expr RBRACKET
    (44) operation_on_list -> . ID LBRACKET expr RBRACKET
    (42) expr_list -> . LBRACKET clist RBRACKET
    (47) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (49) binary_expr -> . expr PLUS expr
    (50) binary_expr -> . expr MINUS expr
    (51) binary_expr -> . expr TIMES expr
    (52) binary_expr -> . expr DIVIDE expr
    (53) binary_expr -> . expr MODULO expr
    (54) binary_expr -> . expr GT expr
    (55) binary_expr -> . expr LT expr
    (56) binary_expr -> . expr EQ expr
    (57) binary_expr -> . expr LE expr
    (58) binary_expr -> . expr GE expr
    (59) binary_expr -> . expr NE expr
    (60) binary_expr -> . expr LOR expr
    (61) binary_expr -> . expr LAND expr
    (45) assignment -> . ID EQUALS expr
    (46) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (48) function_call -> . ID LPAREN clist RPAREN

    LNOT            shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    ID              shift and go to state 18
    NUMBER          shift and go to state 41
    STRING          shift and go to state 42
    VAR             shift and go to state 43
    RETURN          shift and go to state 44
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    FOR             shift and go to state 47
    LBRACE          shift and go to state 19
    DEF             shift and go to state 4
    LBRACKET        shift and go to state 48

    expr                           shift and go to state 23
    stmt                           shift and go to state 132
    defvar                         shift and go to state 24
    return_instr                   shift and go to state 25
    single_if                      shift and go to state 26
    if_with_else                   shift and go to state 27
    while_loop                     shift and go to state 28
    for_loop                       shift and go to state 29
    block                          shift and go to state 30
    func                           shift and go to state 31
    operation_on_list              shift and go to state 32
    expr_list                      shift and go to state 33
    ternary_expr                   shift and go to state 34
    binary_expr                    shift and go to state 38
    assignment                     shift and go to state 39
    function_call                  shift and go to state 40

state 132

    (19) for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .

    LNOT            reduce using rule 19 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    PLUS            reduce using rule 19 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    MINUS           reduce using rule 19 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    ID              reduce using rule 19 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    NUMBER          reduce using rule 19 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    STRING          reduce using rule 19 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    VAR             reduce using rule 19 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    RETURN          reduce using rule 19 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    IF              reduce using rule 19 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    WHILE           reduce using rule 19 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    FOR             reduce using rule 19 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    LBRACE          reduce using rule 19 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    DEF             reduce using rule 19 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    LBRACKET        reduce using rule 19 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    RBRACE          reduce using rule 19 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    ELSE            reduce using rule 19 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LBRACKET in state 18 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 123 resolved as shift
