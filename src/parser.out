Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ALSE
    AND
    AS
    AUTO
    BREAK
    CASE
    CLASS
    CLOSE
    CONST
    CONTINUE
    DECREMENT
    DEFAULT
    DEL
    DIVEQUAL
    EXCEPT
    FROM
    GLOBAL
    IMPORT
    IN
    INCREMENT
    INPUT
    INT
    IS
    LAMBDA
    LEN
    LSHIFT
    MINUSEQUAL
    MODEQUAL
    NONLOCAL
    NOT
    NULL
    ONE
    OPEN
    OR
    PASS
    PERIOD
    PLUSEQUAL
    RAISE
    RANGE
    READ
    RSHIFT
    RUE
    SIZEOF
    STATIC
    STR
    STRUCT
    SWITCH
    TIMESEQUAL
    TRY
    VECTOR
    VOID
    WITH
    WRITE
    XOR

Grammar

Rule 0     S' -> prog
Rule 1     prog -> empty
Rule 2     prog -> func prog
Rule 3     func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
Rule 4     func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
Rule 5     func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE
Rule 6     func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE
Rule 7     body -> empty
Rule 8     body -> stmt body
Rule 9     stmt -> expr SEMI
Rule 10    stmt -> defvar SEMI
Rule 11    stmt -> return_instr SEMI
Rule 12    stmt -> single_if
Rule 13    stmt -> if_with_else
Rule 14    stmt -> while_loop
Rule 15    stmt -> for_loop
Rule 16    stmt -> block
Rule 17    stmt -> func
Rule 18    stmt -> error SEMI
Rule 19    stmt -> error
Rule 20    single_if -> IF LPAREN expr RPAREN stmt
Rule 21    if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt
Rule 22    while_loop -> WHILE LPAREN expr RPAREN stmt
Rule 23    for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
Rule 24    block -> LBRACE body RBRACE
Rule 25    return_instr -> RETURN expr
Rule 26    defvar -> VAR TYPE ID
Rule 27    defvar -> VAR TYPE ID EQUALS expr
Rule 28    flist -> empty
Rule 29    flist -> TYPE ID
Rule 30    flist -> TYPE ID COMMA flist
Rule 31    clist -> empty
Rule 32    clist -> expr
Rule 33    clist -> expr COMMA clist
Rule 34    expr -> operation_on_list
Rule 35    expr -> expr_list
Rule 36    expr -> ternary_expr
Rule 37    expr -> LNOT expr
Rule 38    expr -> PLUS expr
Rule 39    expr -> MINUS expr
Rule 40    expr -> binary_expr
Rule 41    expr -> ID
Rule 42    expr -> assignment
Rule 43    expr -> function_call
Rule 44    expr -> NUMBER
Rule 45    expr -> STRING
Rule 46    expr_list -> LBRACKET clist RBRACKET
Rule 47    operation_on_list -> expr LBRACKET expr RBRACKET
Rule 48    operation_on_list -> ID LBRACKET expr RBRACKET
Rule 49    assignment -> ID EQUALS expr
Rule 50    assignment -> ID LBRACKET expr RBRACKET EQUALS expr
Rule 51    ternary_expr -> expr QUESTIONMARK expr COLON expr
Rule 52    function_call -> ID LPAREN clist RPAREN
Rule 53    function_call -> ID LPAREN error RPAREN
Rule 54    binary_expr -> expr PLUS expr
Rule 55    binary_expr -> expr MINUS expr
Rule 56    binary_expr -> expr TIMES expr
Rule 57    binary_expr -> expr DIVIDE expr
Rule 58    binary_expr -> expr MODULO expr
Rule 59    binary_expr -> expr GT expr
Rule 60    binary_expr -> expr LT expr
Rule 61    binary_expr -> expr EQ expr
Rule 62    binary_expr -> expr LE expr
Rule 63    binary_expr -> expr GE expr
Rule 64    binary_expr -> expr NE expr
Rule 65    binary_expr -> expr LOR expr
Rule 66    binary_expr -> expr LAND expr
Rule 67    empty -> <empty>

Terminals, with rules where they appear

ALSE                 : 
AND                  : 
AS                   : 
AUTO                 : 
BREAK                : 
CASE                 : 
CLASS                : 
CLOSE                : 
COLON                : 51
COMMA                : 30 33
CONST                : 
CONTINUE             : 
DECREMENT            : 
DEF                  : 3 4 5 6
DEFAULT              : 
DEL                  : 
DIVEQUAL             : 
DIVIDE               : 57
ELSE                 : 21
EQ                   : 61
EQUALS               : 23 27 49 50
EXCEPT               : 
FOR                  : 23
FROM                 : 
GE                   : 63
GLOBAL               : 
GT                   : 59
ID                   : 3 4 5 6 23 26 27 29 30 41 48 49 50 52 53
IF                   : 20 21
IMPORT               : 
IN                   : 
INCREMENT            : 
INPUT                : 
INT                  : 
IS                   : 
LAMBDA               : 
LAND                 : 66
LBRACE               : 3 5 6 24
LBRACKET             : 46 47 48 50
LE                   : 62
LEN                  : 
LNOT                 : 37
LOR                  : 65
LPAREN               : 3 4 5 6 20 21 22 23 52 53
LSHIFT               : 
LT                   : 60
MINUS                : 39 55
MINUSEQUAL           : 
MODEQUAL             : 
MODULO               : 58
NE                   : 64
NONLOCAL             : 
NOT                  : 
NULL                 : 
NUMBER               : 44
ONE                  : 
OPEN                 : 
OR                   : 
PASS                 : 
PERIOD               : 
PLUS                 : 38 54
PLUSEQUAL            : 
QUESTIONMARK         : 51
RAISE                : 
RANGE                : 
RBRACE               : 3 5 6 24
RBRACKET             : 46 47 48 50
READ                 : 
RETURN               : 4 25
RPAREN               : 3 4 5 6 20 21 22 23 52 53
RSHIFT               : 
RUE                  : 
SEMI                 : 4 9 10 11 18
SIZEOF               : 
STATIC               : 
STR                  : 
STRING               : 45
STRUCT               : 
SWITCH               : 
TIMES                : 56
TIMESEQUAL           : 
TO                   : 23
TRY                  : 
TYPE                 : 3 4 5 26 27 29 30
VAR                  : 26 27
VECTOR               : 
VOID                 : 
WHILE                : 22
WITH                 : 
WRITE                : 
XOR                  : 
error                : 5 6 18 19 53

Nonterminals, with rules where they appear

assignment           : 42
binary_expr          : 40
block                : 16
body                 : 3 5 6 8 24
clist                : 33 46 52
defvar               : 10
empty                : 1 7 28 31
expr                 : 4 9 20 21 22 23 23 25 27 32 33 37 38 39 47 47 48 49 50 50 51 51 51 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 64 65 65 66 66
expr_list            : 35
flist                : 3 4 6 30
for_loop             : 15
func                 : 2 17
function_call        : 43
if_with_else         : 13
operation_on_list    : 34
prog                 : 2 0
return_instr         : 11
single_if            : 12
stmt                 : 8 20 21 21 22 23
ternary_expr         : 36
while_loop           : 14

Parsing method: LALR

state 0

    (0) S' -> . prog
    (1) prog -> . empty
    (2) prog -> . func prog
    (67) empty -> .
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> . DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE
    (6) func -> . DEF error ID LPAREN flist RPAREN LBRACE body RBRACE

    $end            reduce using rule 67 (empty -> .)
    DEF             shift and go to state 4

    prog                           shift and go to state 1
    empty                          shift and go to state 2
    func                           shift and go to state 3

state 1

    (0) S' -> prog .



state 2

    (1) prog -> empty .

    $end            reduce using rule 1 (prog -> empty .)


state 3

    (2) prog -> func . prog
    (1) prog -> . empty
    (2) prog -> . func prog
    (67) empty -> .
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> . DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE
    (6) func -> . DEF error ID LPAREN flist RPAREN LBRACE body RBRACE

    $end            reduce using rule 67 (empty -> .)
    DEF             shift and go to state 4

    func                           shift and go to state 3
    prog                           shift and go to state 5
    empty                          shift and go to state 2

state 4

    (3) func -> DEF . TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> DEF . TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> DEF . TYPE ID LPAREN error RPAREN LBRACE body RBRACE
    (6) func -> DEF . error ID LPAREN flist RPAREN LBRACE body RBRACE

    TYPE            shift and go to state 6
    error           shift and go to state 7


state 5

    (2) prog -> func prog .

    $end            reduce using rule 2 (prog -> func prog .)


state 6

    (3) func -> DEF TYPE . ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> DEF TYPE . ID LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> DEF TYPE . ID LPAREN error RPAREN LBRACE body RBRACE

    ID              shift and go to state 8


state 7

    (6) func -> DEF error . ID LPAREN flist RPAREN LBRACE body RBRACE

    ID              shift and go to state 9


state 8

    (3) func -> DEF TYPE ID . LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> DEF TYPE ID . LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> DEF TYPE ID . LPAREN error RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 10


state 9

    (6) func -> DEF error ID . LPAREN flist RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 11


state 10

    (3) func -> DEF TYPE ID LPAREN . flist RPAREN LBRACE body RBRACE
    (4) func -> DEF TYPE ID LPAREN . flist RPAREN RETURN expr SEMI
    (5) func -> DEF TYPE ID LPAREN . error RPAREN LBRACE body RBRACE
    (28) flist -> . empty
    (29) flist -> . TYPE ID
    (30) flist -> . TYPE ID COMMA flist
    (67) empty -> .

    error           shift and go to state 14
    TYPE            shift and go to state 12
    RPAREN          reduce using rule 67 (empty -> .)

    flist                          shift and go to state 13
    empty                          shift and go to state 15

state 11

    (6) func -> DEF error ID LPAREN . flist RPAREN LBRACE body RBRACE
    (28) flist -> . empty
    (29) flist -> . TYPE ID
    (30) flist -> . TYPE ID COMMA flist
    (67) empty -> .

    TYPE            shift and go to state 12
    RPAREN          reduce using rule 67 (empty -> .)

    flist                          shift and go to state 16
    empty                          shift and go to state 15

state 12

    (29) flist -> TYPE . ID
    (30) flist -> TYPE . ID COMMA flist

    ID              shift and go to state 17


state 13

    (3) func -> DEF TYPE ID LPAREN flist . RPAREN LBRACE body RBRACE
    (4) func -> DEF TYPE ID LPAREN flist . RPAREN RETURN expr SEMI

    RPAREN          shift and go to state 18


state 14

    (5) func -> DEF TYPE ID LPAREN error . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 19


state 15

    (28) flist -> empty .

    RPAREN          reduce using rule 28 (flist -> empty .)


state 16

    (6) func -> DEF error ID LPAREN flist . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 20


state 17

    (29) flist -> TYPE ID .
    (30) flist -> TYPE ID . COMMA flist

    RPAREN          reduce using rule 29 (flist -> TYPE ID .)
    COMMA           shift and go to state 21


state 18

    (3) func -> DEF TYPE ID LPAREN flist RPAREN . LBRACE body RBRACE
    (4) func -> DEF TYPE ID LPAREN flist RPAREN . RETURN expr SEMI

    LBRACE          shift and go to state 22
    RETURN          shift and go to state 23


state 19

    (5) func -> DEF TYPE ID LPAREN error RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 24


state 20

    (6) func -> DEF error ID LPAREN flist RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 25


state 21

    (30) flist -> TYPE ID COMMA . flist
    (28) flist -> . empty
    (29) flist -> . TYPE ID
    (30) flist -> . TYPE ID COMMA flist
    (67) empty -> .

    TYPE            shift and go to state 12
    RPAREN          reduce using rule 67 (empty -> .)

    flist                          shift and go to state 26
    empty                          shift and go to state 15

state 22

    (3) func -> DEF TYPE ID LPAREN flist RPAREN LBRACE . body RBRACE
    (7) body -> . empty
    (8) body -> . stmt body
    (67) empty -> .
    (9) stmt -> . expr SEMI
    (10) stmt -> . defvar SEMI
    (11) stmt -> . return_instr SEMI
    (12) stmt -> . single_if
    (13) stmt -> . if_with_else
    (14) stmt -> . while_loop
    (15) stmt -> . for_loop
    (16) stmt -> . block
    (17) stmt -> . func
    (18) stmt -> . error SEMI
    (19) stmt -> . error
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (26) defvar -> . VAR TYPE ID
    (27) defvar -> . VAR TYPE ID EQUALS expr
    (25) return_instr -> . RETURN expr
    (20) single_if -> . IF LPAREN expr RPAREN stmt
    (21) if_with_else -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (22) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (23) for_loop -> . FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
    (24) block -> . LBRACE body RBRACE
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> . DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE
    (6) func -> . DEF error ID LPAREN flist RPAREN LBRACE body RBRACE
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    RBRACE          reduce using rule 67 (empty -> .)
    error           shift and go to state 41
    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    VAR             shift and go to state 53
    RETURN          shift and go to state 54
    IF              shift and go to state 55
    WHILE           shift and go to state 56
    FOR             shift and go to state 57
    LBRACE          shift and go to state 28
    DEF             shift and go to state 4
    LBRACKET        shift and go to state 58

    body                           shift and go to state 29
    empty                          shift and go to state 30
    stmt                           shift and go to state 31
    expr                           shift and go to state 32
    defvar                         shift and go to state 33
    return_instr                   shift and go to state 34
    single_if                      shift and go to state 35
    if_with_else                   shift and go to state 36
    while_loop                     shift and go to state 37
    for_loop                       shift and go to state 38
    block                          shift and go to state 39
    func                           shift and go to state 40
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 23

    (4) func -> DEF TYPE ID LPAREN flist RPAREN RETURN . expr SEMI
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 59
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 24

    (5) func -> DEF TYPE ID LPAREN error RPAREN LBRACE . body RBRACE
    (7) body -> . empty
    (8) body -> . stmt body
    (67) empty -> .
    (9) stmt -> . expr SEMI
    (10) stmt -> . defvar SEMI
    (11) stmt -> . return_instr SEMI
    (12) stmt -> . single_if
    (13) stmt -> . if_with_else
    (14) stmt -> . while_loop
    (15) stmt -> . for_loop
    (16) stmt -> . block
    (17) stmt -> . func
    (18) stmt -> . error SEMI
    (19) stmt -> . error
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (26) defvar -> . VAR TYPE ID
    (27) defvar -> . VAR TYPE ID EQUALS expr
    (25) return_instr -> . RETURN expr
    (20) single_if -> . IF LPAREN expr RPAREN stmt
    (21) if_with_else -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (22) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (23) for_loop -> . FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
    (24) block -> . LBRACE body RBRACE
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> . DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE
    (6) func -> . DEF error ID LPAREN flist RPAREN LBRACE body RBRACE
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    RBRACE          reduce using rule 67 (empty -> .)
    error           shift and go to state 41
    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    VAR             shift and go to state 53
    RETURN          shift and go to state 54
    IF              shift and go to state 55
    WHILE           shift and go to state 56
    FOR             shift and go to state 57
    LBRACE          shift and go to state 28
    DEF             shift and go to state 4
    LBRACKET        shift and go to state 58

    body                           shift and go to state 60
    empty                          shift and go to state 30
    stmt                           shift and go to state 31
    expr                           shift and go to state 32
    defvar                         shift and go to state 33
    return_instr                   shift and go to state 34
    single_if                      shift and go to state 35
    if_with_else                   shift and go to state 36
    while_loop                     shift and go to state 37
    for_loop                       shift and go to state 38
    block                          shift and go to state 39
    func                           shift and go to state 40
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 25

    (6) func -> DEF error ID LPAREN flist RPAREN LBRACE . body RBRACE
    (7) body -> . empty
    (8) body -> . stmt body
    (67) empty -> .
    (9) stmt -> . expr SEMI
    (10) stmt -> . defvar SEMI
    (11) stmt -> . return_instr SEMI
    (12) stmt -> . single_if
    (13) stmt -> . if_with_else
    (14) stmt -> . while_loop
    (15) stmt -> . for_loop
    (16) stmt -> . block
    (17) stmt -> . func
    (18) stmt -> . error SEMI
    (19) stmt -> . error
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (26) defvar -> . VAR TYPE ID
    (27) defvar -> . VAR TYPE ID EQUALS expr
    (25) return_instr -> . RETURN expr
    (20) single_if -> . IF LPAREN expr RPAREN stmt
    (21) if_with_else -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (22) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (23) for_loop -> . FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
    (24) block -> . LBRACE body RBRACE
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> . DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE
    (6) func -> . DEF error ID LPAREN flist RPAREN LBRACE body RBRACE
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    RBRACE          reduce using rule 67 (empty -> .)
    error           shift and go to state 41
    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    VAR             shift and go to state 53
    RETURN          shift and go to state 54
    IF              shift and go to state 55
    WHILE           shift and go to state 56
    FOR             shift and go to state 57
    LBRACE          shift and go to state 28
    DEF             shift and go to state 4
    LBRACKET        shift and go to state 58

    body                           shift and go to state 61
    empty                          shift and go to state 30
    stmt                           shift and go to state 31
    expr                           shift and go to state 32
    defvar                         shift and go to state 33
    return_instr                   shift and go to state 34
    single_if                      shift and go to state 35
    if_with_else                   shift and go to state 36
    while_loop                     shift and go to state 37
    for_loop                       shift and go to state 38
    block                          shift and go to state 39
    func                           shift and go to state 40
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 26

    (30) flist -> TYPE ID COMMA flist .

    RPAREN          reduce using rule 30 (flist -> TYPE ID COMMA flist .)


state 27

    (41) expr -> ID .
    (48) operation_on_list -> ID . LBRACKET expr RBRACKET
    (49) assignment -> ID . EQUALS expr
    (50) assignment -> ID . LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> ID . LPAREN clist RPAREN
    (53) function_call -> ID . LPAREN error RPAREN

  ! shift/reduce conflict for LBRACKET resolved as shift
    SEMI            reduce using rule 41 (expr -> ID .)
    QUESTIONMARK    reduce using rule 41 (expr -> ID .)
    PLUS            reduce using rule 41 (expr -> ID .)
    MINUS           reduce using rule 41 (expr -> ID .)
    TIMES           reduce using rule 41 (expr -> ID .)
    DIVIDE          reduce using rule 41 (expr -> ID .)
    MODULO          reduce using rule 41 (expr -> ID .)
    GT              reduce using rule 41 (expr -> ID .)
    LT              reduce using rule 41 (expr -> ID .)
    EQ              reduce using rule 41 (expr -> ID .)
    LE              reduce using rule 41 (expr -> ID .)
    GE              reduce using rule 41 (expr -> ID .)
    NE              reduce using rule 41 (expr -> ID .)
    LOR             reduce using rule 41 (expr -> ID .)
    LAND            reduce using rule 41 (expr -> ID .)
    COMMA           reduce using rule 41 (expr -> ID .)
    RBRACKET        reduce using rule 41 (expr -> ID .)
    RPAREN          reduce using rule 41 (expr -> ID .)
    COLON           reduce using rule 41 (expr -> ID .)
    TO              reduce using rule 41 (expr -> ID .)
    LBRACKET        shift and go to state 62
    EQUALS          shift and go to state 63
    LPAREN          shift and go to state 64

  ! LBRACKET        [ reduce using rule 41 (expr -> ID .) ]


state 28

    (24) block -> LBRACE . body RBRACE
    (7) body -> . empty
    (8) body -> . stmt body
    (67) empty -> .
    (9) stmt -> . expr SEMI
    (10) stmt -> . defvar SEMI
    (11) stmt -> . return_instr SEMI
    (12) stmt -> . single_if
    (13) stmt -> . if_with_else
    (14) stmt -> . while_loop
    (15) stmt -> . for_loop
    (16) stmt -> . block
    (17) stmt -> . func
    (18) stmt -> . error SEMI
    (19) stmt -> . error
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (26) defvar -> . VAR TYPE ID
    (27) defvar -> . VAR TYPE ID EQUALS expr
    (25) return_instr -> . RETURN expr
    (20) single_if -> . IF LPAREN expr RPAREN stmt
    (21) if_with_else -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (22) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (23) for_loop -> . FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
    (24) block -> . LBRACE body RBRACE
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> . DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE
    (6) func -> . DEF error ID LPAREN flist RPAREN LBRACE body RBRACE
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    RBRACE          reduce using rule 67 (empty -> .)
    error           shift and go to state 41
    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    VAR             shift and go to state 53
    RETURN          shift and go to state 54
    IF              shift and go to state 55
    WHILE           shift and go to state 56
    FOR             shift and go to state 57
    LBRACE          shift and go to state 28
    DEF             shift and go to state 4
    LBRACKET        shift and go to state 58

    body                           shift and go to state 65
    empty                          shift and go to state 30
    stmt                           shift and go to state 31
    expr                           shift and go to state 32
    defvar                         shift and go to state 33
    return_instr                   shift and go to state 34
    single_if                      shift and go to state 35
    if_with_else                   shift and go to state 36
    while_loop                     shift and go to state 37
    for_loop                       shift and go to state 38
    block                          shift and go to state 39
    func                           shift and go to state 40
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 29

    (3) func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 66


state 30

    (7) body -> empty .

    RBRACE          reduce using rule 7 (body -> empty .)


state 31

    (8) body -> stmt . body
    (7) body -> . empty
    (8) body -> . stmt body
    (67) empty -> .
    (9) stmt -> . expr SEMI
    (10) stmt -> . defvar SEMI
    (11) stmt -> . return_instr SEMI
    (12) stmt -> . single_if
    (13) stmt -> . if_with_else
    (14) stmt -> . while_loop
    (15) stmt -> . for_loop
    (16) stmt -> . block
    (17) stmt -> . func
    (18) stmt -> . error SEMI
    (19) stmt -> . error
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (26) defvar -> . VAR TYPE ID
    (27) defvar -> . VAR TYPE ID EQUALS expr
    (25) return_instr -> . RETURN expr
    (20) single_if -> . IF LPAREN expr RPAREN stmt
    (21) if_with_else -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (22) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (23) for_loop -> . FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
    (24) block -> . LBRACE body RBRACE
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> . DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE
    (6) func -> . DEF error ID LPAREN flist RPAREN LBRACE body RBRACE
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    RBRACE          reduce using rule 67 (empty -> .)
    error           shift and go to state 41
    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    VAR             shift and go to state 53
    RETURN          shift and go to state 54
    IF              shift and go to state 55
    WHILE           shift and go to state 56
    FOR             shift and go to state 57
    LBRACE          shift and go to state 28
    DEF             shift and go to state 4
    LBRACKET        shift and go to state 58

    stmt                           shift and go to state 31
    body                           shift and go to state 67
    empty                          shift and go to state 30
    expr                           shift and go to state 32
    defvar                         shift and go to state 33
    return_instr                   shift and go to state 34
    single_if                      shift and go to state 35
    if_with_else                   shift and go to state 36
    while_loop                     shift and go to state 37
    for_loop                       shift and go to state 38
    block                          shift and go to state 39
    func                           shift and go to state 40
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 32

    (9) stmt -> expr . SEMI
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    SEMI            shift and go to state 68
    LBRACKET        shift and go to state 69
    QUESTIONMARK    shift and go to state 70
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 74
    MODULO          shift and go to state 75
    GT              shift and go to state 76
    LT              shift and go to state 77
    EQ              shift and go to state 78
    LE              shift and go to state 79
    GE              shift and go to state 80
    NE              shift and go to state 81
    LOR             shift and go to state 82
    LAND            shift and go to state 83


state 33

    (10) stmt -> defvar . SEMI

    SEMI            shift and go to state 84


state 34

    (11) stmt -> return_instr . SEMI

    SEMI            shift and go to state 85


state 35

    (12) stmt -> single_if .

    error           reduce using rule 12 (stmt -> single_if .)
    LNOT            reduce using rule 12 (stmt -> single_if .)
    PLUS            reduce using rule 12 (stmt -> single_if .)
    MINUS           reduce using rule 12 (stmt -> single_if .)
    ID              reduce using rule 12 (stmt -> single_if .)
    NUMBER          reduce using rule 12 (stmt -> single_if .)
    STRING          reduce using rule 12 (stmt -> single_if .)
    VAR             reduce using rule 12 (stmt -> single_if .)
    RETURN          reduce using rule 12 (stmt -> single_if .)
    IF              reduce using rule 12 (stmt -> single_if .)
    WHILE           reduce using rule 12 (stmt -> single_if .)
    FOR             reduce using rule 12 (stmt -> single_if .)
    LBRACE          reduce using rule 12 (stmt -> single_if .)
    DEF             reduce using rule 12 (stmt -> single_if .)
    LBRACKET        reduce using rule 12 (stmt -> single_if .)
    RBRACE          reduce using rule 12 (stmt -> single_if .)
    ELSE            reduce using rule 12 (stmt -> single_if .)


state 36

    (13) stmt -> if_with_else .

    error           reduce using rule 13 (stmt -> if_with_else .)
    LNOT            reduce using rule 13 (stmt -> if_with_else .)
    PLUS            reduce using rule 13 (stmt -> if_with_else .)
    MINUS           reduce using rule 13 (stmt -> if_with_else .)
    ID              reduce using rule 13 (stmt -> if_with_else .)
    NUMBER          reduce using rule 13 (stmt -> if_with_else .)
    STRING          reduce using rule 13 (stmt -> if_with_else .)
    VAR             reduce using rule 13 (stmt -> if_with_else .)
    RETURN          reduce using rule 13 (stmt -> if_with_else .)
    IF              reduce using rule 13 (stmt -> if_with_else .)
    WHILE           reduce using rule 13 (stmt -> if_with_else .)
    FOR             reduce using rule 13 (stmt -> if_with_else .)
    LBRACE          reduce using rule 13 (stmt -> if_with_else .)
    DEF             reduce using rule 13 (stmt -> if_with_else .)
    LBRACKET        reduce using rule 13 (stmt -> if_with_else .)
    RBRACE          reduce using rule 13 (stmt -> if_with_else .)
    ELSE            reduce using rule 13 (stmt -> if_with_else .)


state 37

    (14) stmt -> while_loop .

    error           reduce using rule 14 (stmt -> while_loop .)
    LNOT            reduce using rule 14 (stmt -> while_loop .)
    PLUS            reduce using rule 14 (stmt -> while_loop .)
    MINUS           reduce using rule 14 (stmt -> while_loop .)
    ID              reduce using rule 14 (stmt -> while_loop .)
    NUMBER          reduce using rule 14 (stmt -> while_loop .)
    STRING          reduce using rule 14 (stmt -> while_loop .)
    VAR             reduce using rule 14 (stmt -> while_loop .)
    RETURN          reduce using rule 14 (stmt -> while_loop .)
    IF              reduce using rule 14 (stmt -> while_loop .)
    WHILE           reduce using rule 14 (stmt -> while_loop .)
    FOR             reduce using rule 14 (stmt -> while_loop .)
    LBRACE          reduce using rule 14 (stmt -> while_loop .)
    DEF             reduce using rule 14 (stmt -> while_loop .)
    LBRACKET        reduce using rule 14 (stmt -> while_loop .)
    RBRACE          reduce using rule 14 (stmt -> while_loop .)
    ELSE            reduce using rule 14 (stmt -> while_loop .)


state 38

    (15) stmt -> for_loop .

    error           reduce using rule 15 (stmt -> for_loop .)
    LNOT            reduce using rule 15 (stmt -> for_loop .)
    PLUS            reduce using rule 15 (stmt -> for_loop .)
    MINUS           reduce using rule 15 (stmt -> for_loop .)
    ID              reduce using rule 15 (stmt -> for_loop .)
    NUMBER          reduce using rule 15 (stmt -> for_loop .)
    STRING          reduce using rule 15 (stmt -> for_loop .)
    VAR             reduce using rule 15 (stmt -> for_loop .)
    RETURN          reduce using rule 15 (stmt -> for_loop .)
    IF              reduce using rule 15 (stmt -> for_loop .)
    WHILE           reduce using rule 15 (stmt -> for_loop .)
    FOR             reduce using rule 15 (stmt -> for_loop .)
    LBRACE          reduce using rule 15 (stmt -> for_loop .)
    DEF             reduce using rule 15 (stmt -> for_loop .)
    LBRACKET        reduce using rule 15 (stmt -> for_loop .)
    RBRACE          reduce using rule 15 (stmt -> for_loop .)
    ELSE            reduce using rule 15 (stmt -> for_loop .)


state 39

    (16) stmt -> block .

    error           reduce using rule 16 (stmt -> block .)
    LNOT            reduce using rule 16 (stmt -> block .)
    PLUS            reduce using rule 16 (stmt -> block .)
    MINUS           reduce using rule 16 (stmt -> block .)
    ID              reduce using rule 16 (stmt -> block .)
    NUMBER          reduce using rule 16 (stmt -> block .)
    STRING          reduce using rule 16 (stmt -> block .)
    VAR             reduce using rule 16 (stmt -> block .)
    RETURN          reduce using rule 16 (stmt -> block .)
    IF              reduce using rule 16 (stmt -> block .)
    WHILE           reduce using rule 16 (stmt -> block .)
    FOR             reduce using rule 16 (stmt -> block .)
    LBRACE          reduce using rule 16 (stmt -> block .)
    DEF             reduce using rule 16 (stmt -> block .)
    LBRACKET        reduce using rule 16 (stmt -> block .)
    RBRACE          reduce using rule 16 (stmt -> block .)
    ELSE            reduce using rule 16 (stmt -> block .)


state 40

    (17) stmt -> func .

    error           reduce using rule 17 (stmt -> func .)
    LNOT            reduce using rule 17 (stmt -> func .)
    PLUS            reduce using rule 17 (stmt -> func .)
    MINUS           reduce using rule 17 (stmt -> func .)
    ID              reduce using rule 17 (stmt -> func .)
    NUMBER          reduce using rule 17 (stmt -> func .)
    STRING          reduce using rule 17 (stmt -> func .)
    VAR             reduce using rule 17 (stmt -> func .)
    RETURN          reduce using rule 17 (stmt -> func .)
    IF              reduce using rule 17 (stmt -> func .)
    WHILE           reduce using rule 17 (stmt -> func .)
    FOR             reduce using rule 17 (stmt -> func .)
    LBRACE          reduce using rule 17 (stmt -> func .)
    DEF             reduce using rule 17 (stmt -> func .)
    LBRACKET        reduce using rule 17 (stmt -> func .)
    RBRACE          reduce using rule 17 (stmt -> func .)
    ELSE            reduce using rule 17 (stmt -> func .)


state 41

    (18) stmt -> error . SEMI
    (19) stmt -> error .

    SEMI            shift and go to state 86
    error           reduce using rule 19 (stmt -> error .)
    LNOT            reduce using rule 19 (stmt -> error .)
    PLUS            reduce using rule 19 (stmt -> error .)
    MINUS           reduce using rule 19 (stmt -> error .)
    ID              reduce using rule 19 (stmt -> error .)
    NUMBER          reduce using rule 19 (stmt -> error .)
    STRING          reduce using rule 19 (stmt -> error .)
    VAR             reduce using rule 19 (stmt -> error .)
    RETURN          reduce using rule 19 (stmt -> error .)
    IF              reduce using rule 19 (stmt -> error .)
    WHILE           reduce using rule 19 (stmt -> error .)
    FOR             reduce using rule 19 (stmt -> error .)
    LBRACE          reduce using rule 19 (stmt -> error .)
    DEF             reduce using rule 19 (stmt -> error .)
    LBRACKET        reduce using rule 19 (stmt -> error .)
    RBRACE          reduce using rule 19 (stmt -> error .)
    ELSE            reduce using rule 19 (stmt -> error .)


state 42

    (34) expr -> operation_on_list .

    SEMI            reduce using rule 34 (expr -> operation_on_list .)
    LBRACKET        reduce using rule 34 (expr -> operation_on_list .)
    QUESTIONMARK    reduce using rule 34 (expr -> operation_on_list .)
    PLUS            reduce using rule 34 (expr -> operation_on_list .)
    MINUS           reduce using rule 34 (expr -> operation_on_list .)
    TIMES           reduce using rule 34 (expr -> operation_on_list .)
    DIVIDE          reduce using rule 34 (expr -> operation_on_list .)
    MODULO          reduce using rule 34 (expr -> operation_on_list .)
    GT              reduce using rule 34 (expr -> operation_on_list .)
    LT              reduce using rule 34 (expr -> operation_on_list .)
    EQ              reduce using rule 34 (expr -> operation_on_list .)
    LE              reduce using rule 34 (expr -> operation_on_list .)
    GE              reduce using rule 34 (expr -> operation_on_list .)
    NE              reduce using rule 34 (expr -> operation_on_list .)
    LOR             reduce using rule 34 (expr -> operation_on_list .)
    LAND            reduce using rule 34 (expr -> operation_on_list .)
    COMMA           reduce using rule 34 (expr -> operation_on_list .)
    RBRACKET        reduce using rule 34 (expr -> operation_on_list .)
    RPAREN          reduce using rule 34 (expr -> operation_on_list .)
    COLON           reduce using rule 34 (expr -> operation_on_list .)
    TO              reduce using rule 34 (expr -> operation_on_list .)


state 43

    (35) expr -> expr_list .

    SEMI            reduce using rule 35 (expr -> expr_list .)
    LBRACKET        reduce using rule 35 (expr -> expr_list .)
    QUESTIONMARK    reduce using rule 35 (expr -> expr_list .)
    PLUS            reduce using rule 35 (expr -> expr_list .)
    MINUS           reduce using rule 35 (expr -> expr_list .)
    TIMES           reduce using rule 35 (expr -> expr_list .)
    DIVIDE          reduce using rule 35 (expr -> expr_list .)
    MODULO          reduce using rule 35 (expr -> expr_list .)
    GT              reduce using rule 35 (expr -> expr_list .)
    LT              reduce using rule 35 (expr -> expr_list .)
    EQ              reduce using rule 35 (expr -> expr_list .)
    LE              reduce using rule 35 (expr -> expr_list .)
    GE              reduce using rule 35 (expr -> expr_list .)
    NE              reduce using rule 35 (expr -> expr_list .)
    LOR             reduce using rule 35 (expr -> expr_list .)
    LAND            reduce using rule 35 (expr -> expr_list .)
    COMMA           reduce using rule 35 (expr -> expr_list .)
    RBRACKET        reduce using rule 35 (expr -> expr_list .)
    RPAREN          reduce using rule 35 (expr -> expr_list .)
    COLON           reduce using rule 35 (expr -> expr_list .)
    TO              reduce using rule 35 (expr -> expr_list .)


state 44

    (36) expr -> ternary_expr .

    SEMI            reduce using rule 36 (expr -> ternary_expr .)
    LBRACKET        reduce using rule 36 (expr -> ternary_expr .)
    QUESTIONMARK    reduce using rule 36 (expr -> ternary_expr .)
    PLUS            reduce using rule 36 (expr -> ternary_expr .)
    MINUS           reduce using rule 36 (expr -> ternary_expr .)
    TIMES           reduce using rule 36 (expr -> ternary_expr .)
    DIVIDE          reduce using rule 36 (expr -> ternary_expr .)
    MODULO          reduce using rule 36 (expr -> ternary_expr .)
    GT              reduce using rule 36 (expr -> ternary_expr .)
    LT              reduce using rule 36 (expr -> ternary_expr .)
    EQ              reduce using rule 36 (expr -> ternary_expr .)
    LE              reduce using rule 36 (expr -> ternary_expr .)
    GE              reduce using rule 36 (expr -> ternary_expr .)
    NE              reduce using rule 36 (expr -> ternary_expr .)
    LOR             reduce using rule 36 (expr -> ternary_expr .)
    LAND            reduce using rule 36 (expr -> ternary_expr .)
    COMMA           reduce using rule 36 (expr -> ternary_expr .)
    RBRACKET        reduce using rule 36 (expr -> ternary_expr .)
    RPAREN          reduce using rule 36 (expr -> ternary_expr .)
    COLON           reduce using rule 36 (expr -> ternary_expr .)
    TO              reduce using rule 36 (expr -> ternary_expr .)


state 45

    (37) expr -> LNOT . expr
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 87
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 46

    (38) expr -> PLUS . expr
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 88
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 47

    (39) expr -> MINUS . expr
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 89
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 48

    (40) expr -> binary_expr .

    SEMI            reduce using rule 40 (expr -> binary_expr .)
    LBRACKET        reduce using rule 40 (expr -> binary_expr .)
    QUESTIONMARK    reduce using rule 40 (expr -> binary_expr .)
    PLUS            reduce using rule 40 (expr -> binary_expr .)
    MINUS           reduce using rule 40 (expr -> binary_expr .)
    TIMES           reduce using rule 40 (expr -> binary_expr .)
    DIVIDE          reduce using rule 40 (expr -> binary_expr .)
    MODULO          reduce using rule 40 (expr -> binary_expr .)
    GT              reduce using rule 40 (expr -> binary_expr .)
    LT              reduce using rule 40 (expr -> binary_expr .)
    EQ              reduce using rule 40 (expr -> binary_expr .)
    LE              reduce using rule 40 (expr -> binary_expr .)
    GE              reduce using rule 40 (expr -> binary_expr .)
    NE              reduce using rule 40 (expr -> binary_expr .)
    LOR             reduce using rule 40 (expr -> binary_expr .)
    LAND            reduce using rule 40 (expr -> binary_expr .)
    COMMA           reduce using rule 40 (expr -> binary_expr .)
    RBRACKET        reduce using rule 40 (expr -> binary_expr .)
    RPAREN          reduce using rule 40 (expr -> binary_expr .)
    COLON           reduce using rule 40 (expr -> binary_expr .)
    TO              reduce using rule 40 (expr -> binary_expr .)


state 49

    (42) expr -> assignment .

    SEMI            reduce using rule 42 (expr -> assignment .)
    LBRACKET        reduce using rule 42 (expr -> assignment .)
    QUESTIONMARK    reduce using rule 42 (expr -> assignment .)
    PLUS            reduce using rule 42 (expr -> assignment .)
    MINUS           reduce using rule 42 (expr -> assignment .)
    TIMES           reduce using rule 42 (expr -> assignment .)
    DIVIDE          reduce using rule 42 (expr -> assignment .)
    MODULO          reduce using rule 42 (expr -> assignment .)
    GT              reduce using rule 42 (expr -> assignment .)
    LT              reduce using rule 42 (expr -> assignment .)
    EQ              reduce using rule 42 (expr -> assignment .)
    LE              reduce using rule 42 (expr -> assignment .)
    GE              reduce using rule 42 (expr -> assignment .)
    NE              reduce using rule 42 (expr -> assignment .)
    LOR             reduce using rule 42 (expr -> assignment .)
    LAND            reduce using rule 42 (expr -> assignment .)
    COMMA           reduce using rule 42 (expr -> assignment .)
    RBRACKET        reduce using rule 42 (expr -> assignment .)
    RPAREN          reduce using rule 42 (expr -> assignment .)
    COLON           reduce using rule 42 (expr -> assignment .)
    TO              reduce using rule 42 (expr -> assignment .)


state 50

    (43) expr -> function_call .

    SEMI            reduce using rule 43 (expr -> function_call .)
    LBRACKET        reduce using rule 43 (expr -> function_call .)
    QUESTIONMARK    reduce using rule 43 (expr -> function_call .)
    PLUS            reduce using rule 43 (expr -> function_call .)
    MINUS           reduce using rule 43 (expr -> function_call .)
    TIMES           reduce using rule 43 (expr -> function_call .)
    DIVIDE          reduce using rule 43 (expr -> function_call .)
    MODULO          reduce using rule 43 (expr -> function_call .)
    GT              reduce using rule 43 (expr -> function_call .)
    LT              reduce using rule 43 (expr -> function_call .)
    EQ              reduce using rule 43 (expr -> function_call .)
    LE              reduce using rule 43 (expr -> function_call .)
    GE              reduce using rule 43 (expr -> function_call .)
    NE              reduce using rule 43 (expr -> function_call .)
    LOR             reduce using rule 43 (expr -> function_call .)
    LAND            reduce using rule 43 (expr -> function_call .)
    COMMA           reduce using rule 43 (expr -> function_call .)
    RBRACKET        reduce using rule 43 (expr -> function_call .)
    RPAREN          reduce using rule 43 (expr -> function_call .)
    COLON           reduce using rule 43 (expr -> function_call .)
    TO              reduce using rule 43 (expr -> function_call .)


state 51

    (44) expr -> NUMBER .

    SEMI            reduce using rule 44 (expr -> NUMBER .)
    LBRACKET        reduce using rule 44 (expr -> NUMBER .)
    QUESTIONMARK    reduce using rule 44 (expr -> NUMBER .)
    PLUS            reduce using rule 44 (expr -> NUMBER .)
    MINUS           reduce using rule 44 (expr -> NUMBER .)
    TIMES           reduce using rule 44 (expr -> NUMBER .)
    DIVIDE          reduce using rule 44 (expr -> NUMBER .)
    MODULO          reduce using rule 44 (expr -> NUMBER .)
    GT              reduce using rule 44 (expr -> NUMBER .)
    LT              reduce using rule 44 (expr -> NUMBER .)
    EQ              reduce using rule 44 (expr -> NUMBER .)
    LE              reduce using rule 44 (expr -> NUMBER .)
    GE              reduce using rule 44 (expr -> NUMBER .)
    NE              reduce using rule 44 (expr -> NUMBER .)
    LOR             reduce using rule 44 (expr -> NUMBER .)
    LAND            reduce using rule 44 (expr -> NUMBER .)
    COMMA           reduce using rule 44 (expr -> NUMBER .)
    RBRACKET        reduce using rule 44 (expr -> NUMBER .)
    RPAREN          reduce using rule 44 (expr -> NUMBER .)
    COLON           reduce using rule 44 (expr -> NUMBER .)
    TO              reduce using rule 44 (expr -> NUMBER .)


state 52

    (45) expr -> STRING .

    SEMI            reduce using rule 45 (expr -> STRING .)
    LBRACKET        reduce using rule 45 (expr -> STRING .)
    QUESTIONMARK    reduce using rule 45 (expr -> STRING .)
    PLUS            reduce using rule 45 (expr -> STRING .)
    MINUS           reduce using rule 45 (expr -> STRING .)
    TIMES           reduce using rule 45 (expr -> STRING .)
    DIVIDE          reduce using rule 45 (expr -> STRING .)
    MODULO          reduce using rule 45 (expr -> STRING .)
    GT              reduce using rule 45 (expr -> STRING .)
    LT              reduce using rule 45 (expr -> STRING .)
    EQ              reduce using rule 45 (expr -> STRING .)
    LE              reduce using rule 45 (expr -> STRING .)
    GE              reduce using rule 45 (expr -> STRING .)
    NE              reduce using rule 45 (expr -> STRING .)
    LOR             reduce using rule 45 (expr -> STRING .)
    LAND            reduce using rule 45 (expr -> STRING .)
    COMMA           reduce using rule 45 (expr -> STRING .)
    RBRACKET        reduce using rule 45 (expr -> STRING .)
    RPAREN          reduce using rule 45 (expr -> STRING .)
    COLON           reduce using rule 45 (expr -> STRING .)
    TO              reduce using rule 45 (expr -> STRING .)


state 53

    (26) defvar -> VAR . TYPE ID
    (27) defvar -> VAR . TYPE ID EQUALS expr

    TYPE            shift and go to state 90


state 54

    (25) return_instr -> RETURN . expr
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 91
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 55

    (20) single_if -> IF . LPAREN expr RPAREN stmt
    (21) if_with_else -> IF . LPAREN expr RPAREN stmt ELSE stmt

    LPAREN          shift and go to state 92


state 56

    (22) while_loop -> WHILE . LPAREN expr RPAREN stmt

    LPAREN          shift and go to state 93


state 57

    (23) for_loop -> FOR . LPAREN ID EQUALS expr TO expr RPAREN stmt

    LPAREN          shift and go to state 94


state 58

    (46) expr_list -> LBRACKET . clist RBRACKET
    (31) clist -> . empty
    (32) clist -> . expr
    (33) clist -> . expr COMMA clist
    (67) empty -> .
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    RBRACKET        reduce using rule 67 (empty -> .)
    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    clist                          shift and go to state 95
    empty                          shift and go to state 96
    expr                           shift and go to state 97
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 59

    (4) func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr . SEMI
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    SEMI            shift and go to state 98
    LBRACKET        shift and go to state 69
    QUESTIONMARK    shift and go to state 70
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 74
    MODULO          shift and go to state 75
    GT              shift and go to state 76
    LT              shift and go to state 77
    EQ              shift and go to state 78
    LE              shift and go to state 79
    GE              shift and go to state 80
    NE              shift and go to state 81
    LOR             shift and go to state 82
    LAND            shift and go to state 83


state 60

    (5) func -> DEF TYPE ID LPAREN error RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 99


state 61

    (6) func -> DEF error ID LPAREN flist RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 100


state 62

    (48) operation_on_list -> ID LBRACKET . expr RBRACKET
    (50) assignment -> ID LBRACKET . expr RBRACKET EQUALS expr
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 101
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 63

    (49) assignment -> ID EQUALS . expr
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 102
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 64

    (52) function_call -> ID LPAREN . clist RPAREN
    (53) function_call -> ID LPAREN . error RPAREN
    (31) clist -> . empty
    (32) clist -> . expr
    (33) clist -> . expr COMMA clist
    (67) empty -> .
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    error           shift and go to state 104
    RPAREN          reduce using rule 67 (empty -> .)
    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    clist                          shift and go to state 103
    empty                          shift and go to state 96
    expr                           shift and go to state 97
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 65

    (24) block -> LBRACE body . RBRACE

    RBRACE          shift and go to state 105


state 66

    (3) func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .

    DEF             reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    $end            reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    error           reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    LNOT            reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    PLUS            reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    MINUS           reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    ID              reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    NUMBER          reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    STRING          reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    VAR             reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    RETURN          reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    LBRACE          reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    LBRACKET        reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    ELSE            reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)


state 67

    (8) body -> stmt body .

    RBRACE          reduce using rule 8 (body -> stmt body .)


state 68

    (9) stmt -> expr SEMI .

    error           reduce using rule 9 (stmt -> expr SEMI .)
    LNOT            reduce using rule 9 (stmt -> expr SEMI .)
    PLUS            reduce using rule 9 (stmt -> expr SEMI .)
    MINUS           reduce using rule 9 (stmt -> expr SEMI .)
    ID              reduce using rule 9 (stmt -> expr SEMI .)
    NUMBER          reduce using rule 9 (stmt -> expr SEMI .)
    STRING          reduce using rule 9 (stmt -> expr SEMI .)
    VAR             reduce using rule 9 (stmt -> expr SEMI .)
    RETURN          reduce using rule 9 (stmt -> expr SEMI .)
    IF              reduce using rule 9 (stmt -> expr SEMI .)
    WHILE           reduce using rule 9 (stmt -> expr SEMI .)
    FOR             reduce using rule 9 (stmt -> expr SEMI .)
    LBRACE          reduce using rule 9 (stmt -> expr SEMI .)
    DEF             reduce using rule 9 (stmt -> expr SEMI .)
    LBRACKET        reduce using rule 9 (stmt -> expr SEMI .)
    RBRACE          reduce using rule 9 (stmt -> expr SEMI .)
    ELSE            reduce using rule 9 (stmt -> expr SEMI .)


state 69

    (47) operation_on_list -> expr LBRACKET . expr RBRACKET
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 106
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 70

    (51) ternary_expr -> expr QUESTIONMARK . expr COLON expr
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 107
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 71

    (54) binary_expr -> expr PLUS . expr
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 108
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 72

    (55) binary_expr -> expr MINUS . expr
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 109
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 73

    (56) binary_expr -> expr TIMES . expr
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 110
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 74

    (57) binary_expr -> expr DIVIDE . expr
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 111
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 75

    (58) binary_expr -> expr MODULO . expr
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 112
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 76

    (59) binary_expr -> expr GT . expr
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 113
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 77

    (60) binary_expr -> expr LT . expr
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 114
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 78

    (61) binary_expr -> expr EQ . expr
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 115
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 79

    (62) binary_expr -> expr LE . expr
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 116
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 80

    (63) binary_expr -> expr GE . expr
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 117
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 81

    (64) binary_expr -> expr NE . expr
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 118
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 82

    (65) binary_expr -> expr LOR . expr
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 119
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 83

    (66) binary_expr -> expr LAND . expr
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 120
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 84

    (10) stmt -> defvar SEMI .

    error           reduce using rule 10 (stmt -> defvar SEMI .)
    LNOT            reduce using rule 10 (stmt -> defvar SEMI .)
    PLUS            reduce using rule 10 (stmt -> defvar SEMI .)
    MINUS           reduce using rule 10 (stmt -> defvar SEMI .)
    ID              reduce using rule 10 (stmt -> defvar SEMI .)
    NUMBER          reduce using rule 10 (stmt -> defvar SEMI .)
    STRING          reduce using rule 10 (stmt -> defvar SEMI .)
    VAR             reduce using rule 10 (stmt -> defvar SEMI .)
    RETURN          reduce using rule 10 (stmt -> defvar SEMI .)
    IF              reduce using rule 10 (stmt -> defvar SEMI .)
    WHILE           reduce using rule 10 (stmt -> defvar SEMI .)
    FOR             reduce using rule 10 (stmt -> defvar SEMI .)
    LBRACE          reduce using rule 10 (stmt -> defvar SEMI .)
    DEF             reduce using rule 10 (stmt -> defvar SEMI .)
    LBRACKET        reduce using rule 10 (stmt -> defvar SEMI .)
    RBRACE          reduce using rule 10 (stmt -> defvar SEMI .)
    ELSE            reduce using rule 10 (stmt -> defvar SEMI .)


state 85

    (11) stmt -> return_instr SEMI .

    error           reduce using rule 11 (stmt -> return_instr SEMI .)
    LNOT            reduce using rule 11 (stmt -> return_instr SEMI .)
    PLUS            reduce using rule 11 (stmt -> return_instr SEMI .)
    MINUS           reduce using rule 11 (stmt -> return_instr SEMI .)
    ID              reduce using rule 11 (stmt -> return_instr SEMI .)
    NUMBER          reduce using rule 11 (stmt -> return_instr SEMI .)
    STRING          reduce using rule 11 (stmt -> return_instr SEMI .)
    VAR             reduce using rule 11 (stmt -> return_instr SEMI .)
    RETURN          reduce using rule 11 (stmt -> return_instr SEMI .)
    IF              reduce using rule 11 (stmt -> return_instr SEMI .)
    WHILE           reduce using rule 11 (stmt -> return_instr SEMI .)
    FOR             reduce using rule 11 (stmt -> return_instr SEMI .)
    LBRACE          reduce using rule 11 (stmt -> return_instr SEMI .)
    DEF             reduce using rule 11 (stmt -> return_instr SEMI .)
    LBRACKET        reduce using rule 11 (stmt -> return_instr SEMI .)
    RBRACE          reduce using rule 11 (stmt -> return_instr SEMI .)
    ELSE            reduce using rule 11 (stmt -> return_instr SEMI .)


state 86

    (18) stmt -> error SEMI .

    error           reduce using rule 18 (stmt -> error SEMI .)
    LNOT            reduce using rule 18 (stmt -> error SEMI .)
    PLUS            reduce using rule 18 (stmt -> error SEMI .)
    MINUS           reduce using rule 18 (stmt -> error SEMI .)
    ID              reduce using rule 18 (stmt -> error SEMI .)
    NUMBER          reduce using rule 18 (stmt -> error SEMI .)
    STRING          reduce using rule 18 (stmt -> error SEMI .)
    VAR             reduce using rule 18 (stmt -> error SEMI .)
    RETURN          reduce using rule 18 (stmt -> error SEMI .)
    IF              reduce using rule 18 (stmt -> error SEMI .)
    WHILE           reduce using rule 18 (stmt -> error SEMI .)
    FOR             reduce using rule 18 (stmt -> error SEMI .)
    LBRACE          reduce using rule 18 (stmt -> error SEMI .)
    DEF             reduce using rule 18 (stmt -> error SEMI .)
    LBRACKET        reduce using rule 18 (stmt -> error SEMI .)
    RBRACE          reduce using rule 18 (stmt -> error SEMI .)
    ELSE            reduce using rule 18 (stmt -> error SEMI .)


state 87

    (37) expr -> LNOT expr .
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 37 (expr -> LNOT expr .)
    LBRACKET        reduce using rule 37 (expr -> LNOT expr .)
    QUESTIONMARK    reduce using rule 37 (expr -> LNOT expr .)
    PLUS            reduce using rule 37 (expr -> LNOT expr .)
    MINUS           reduce using rule 37 (expr -> LNOT expr .)
    TIMES           reduce using rule 37 (expr -> LNOT expr .)
    DIVIDE          reduce using rule 37 (expr -> LNOT expr .)
    MODULO          reduce using rule 37 (expr -> LNOT expr .)
    GT              reduce using rule 37 (expr -> LNOT expr .)
    LT              reduce using rule 37 (expr -> LNOT expr .)
    EQ              reduce using rule 37 (expr -> LNOT expr .)
    LE              reduce using rule 37 (expr -> LNOT expr .)
    GE              reduce using rule 37 (expr -> LNOT expr .)
    NE              reduce using rule 37 (expr -> LNOT expr .)
    LOR             reduce using rule 37 (expr -> LNOT expr .)
    LAND            reduce using rule 37 (expr -> LNOT expr .)
    COMMA           reduce using rule 37 (expr -> LNOT expr .)
    RBRACKET        reduce using rule 37 (expr -> LNOT expr .)
    RPAREN          reduce using rule 37 (expr -> LNOT expr .)
    COLON           reduce using rule 37 (expr -> LNOT expr .)
    TO              reduce using rule 37 (expr -> LNOT expr .)

  ! LBRACKET        [ shift and go to state 69 ]
  ! QUESTIONMARK    [ shift and go to state 70 ]
  ! PLUS            [ shift and go to state 71 ]
  ! MINUS           [ shift and go to state 72 ]
  ! TIMES           [ shift and go to state 73 ]
  ! DIVIDE          [ shift and go to state 74 ]
  ! MODULO          [ shift and go to state 75 ]
  ! GT              [ shift and go to state 76 ]
  ! LT              [ shift and go to state 77 ]
  ! EQ              [ shift and go to state 78 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 80 ]
  ! NE              [ shift and go to state 81 ]
  ! LOR             [ shift and go to state 82 ]
  ! LAND            [ shift and go to state 83 ]


state 88

    (38) expr -> PLUS expr .
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 38 (expr -> PLUS expr .)
    LBRACKET        reduce using rule 38 (expr -> PLUS expr .)
    PLUS            reduce using rule 38 (expr -> PLUS expr .)
    MINUS           reduce using rule 38 (expr -> PLUS expr .)
    GT              reduce using rule 38 (expr -> PLUS expr .)
    LT              reduce using rule 38 (expr -> PLUS expr .)
    EQ              reduce using rule 38 (expr -> PLUS expr .)
    LE              reduce using rule 38 (expr -> PLUS expr .)
    GE              reduce using rule 38 (expr -> PLUS expr .)
    NE              reduce using rule 38 (expr -> PLUS expr .)
    LOR             reduce using rule 38 (expr -> PLUS expr .)
    LAND            reduce using rule 38 (expr -> PLUS expr .)
    COMMA           reduce using rule 38 (expr -> PLUS expr .)
    RBRACKET        reduce using rule 38 (expr -> PLUS expr .)
    RPAREN          reduce using rule 38 (expr -> PLUS expr .)
    COLON           reduce using rule 38 (expr -> PLUS expr .)
    TO              reduce using rule 38 (expr -> PLUS expr .)
    QUESTIONMARK    shift and go to state 70
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 74
    MODULO          shift and go to state 75

  ! QUESTIONMARK    [ reduce using rule 38 (expr -> PLUS expr .) ]
  ! TIMES           [ reduce using rule 38 (expr -> PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 38 (expr -> PLUS expr .) ]
  ! MODULO          [ reduce using rule 38 (expr -> PLUS expr .) ]
  ! LBRACKET        [ shift and go to state 69 ]
  ! PLUS            [ shift and go to state 71 ]
  ! MINUS           [ shift and go to state 72 ]
  ! GT              [ shift and go to state 76 ]
  ! LT              [ shift and go to state 77 ]
  ! EQ              [ shift and go to state 78 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 80 ]
  ! NE              [ shift and go to state 81 ]
  ! LOR             [ shift and go to state 82 ]
  ! LAND            [ shift and go to state 83 ]


state 89

    (39) expr -> MINUS expr .
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 39 (expr -> MINUS expr .)
    LBRACKET        reduce using rule 39 (expr -> MINUS expr .)
    PLUS            reduce using rule 39 (expr -> MINUS expr .)
    MINUS           reduce using rule 39 (expr -> MINUS expr .)
    TIMES           reduce using rule 39 (expr -> MINUS expr .)
    DIVIDE          reduce using rule 39 (expr -> MINUS expr .)
    MODULO          reduce using rule 39 (expr -> MINUS expr .)
    GT              reduce using rule 39 (expr -> MINUS expr .)
    LT              reduce using rule 39 (expr -> MINUS expr .)
    EQ              reduce using rule 39 (expr -> MINUS expr .)
    LE              reduce using rule 39 (expr -> MINUS expr .)
    GE              reduce using rule 39 (expr -> MINUS expr .)
    NE              reduce using rule 39 (expr -> MINUS expr .)
    LOR             reduce using rule 39 (expr -> MINUS expr .)
    LAND            reduce using rule 39 (expr -> MINUS expr .)
    COMMA           reduce using rule 39 (expr -> MINUS expr .)
    RBRACKET        reduce using rule 39 (expr -> MINUS expr .)
    RPAREN          reduce using rule 39 (expr -> MINUS expr .)
    COLON           reduce using rule 39 (expr -> MINUS expr .)
    TO              reduce using rule 39 (expr -> MINUS expr .)
    QUESTIONMARK    shift and go to state 70

  ! QUESTIONMARK    [ reduce using rule 39 (expr -> MINUS expr .) ]
  ! LBRACKET        [ shift and go to state 69 ]
  ! PLUS            [ shift and go to state 71 ]
  ! MINUS           [ shift and go to state 72 ]
  ! TIMES           [ shift and go to state 73 ]
  ! DIVIDE          [ shift and go to state 74 ]
  ! MODULO          [ shift and go to state 75 ]
  ! GT              [ shift and go to state 76 ]
  ! LT              [ shift and go to state 77 ]
  ! EQ              [ shift and go to state 78 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 80 ]
  ! NE              [ shift and go to state 81 ]
  ! LOR             [ shift and go to state 82 ]
  ! LAND            [ shift and go to state 83 ]


state 90

    (26) defvar -> VAR TYPE . ID
    (27) defvar -> VAR TYPE . ID EQUALS expr

    ID              shift and go to state 121


state 91

    (25) return_instr -> RETURN expr .
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 25 (return_instr -> RETURN expr .)
    LBRACKET        shift and go to state 69
    QUESTIONMARK    shift and go to state 70
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 74
    MODULO          shift and go to state 75
    GT              shift and go to state 76
    LT              shift and go to state 77
    EQ              shift and go to state 78
    LE              shift and go to state 79
    GE              shift and go to state 80
    NE              shift and go to state 81
    LOR             shift and go to state 82
    LAND            shift and go to state 83


state 92

    (20) single_if -> IF LPAREN . expr RPAREN stmt
    (21) if_with_else -> IF LPAREN . expr RPAREN stmt ELSE stmt
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 122
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 93

    (22) while_loop -> WHILE LPAREN . expr RPAREN stmt
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 123
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 94

    (23) for_loop -> FOR LPAREN . ID EQUALS expr TO expr RPAREN stmt

    ID              shift and go to state 124


state 95

    (46) expr_list -> LBRACKET clist . RBRACKET

    RBRACKET        shift and go to state 125


state 96

    (31) clist -> empty .

    RBRACKET        reduce using rule 31 (clist -> empty .)
    RPAREN          reduce using rule 31 (clist -> empty .)


state 97

    (32) clist -> expr .
    (33) clist -> expr . COMMA clist
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    RBRACKET        reduce using rule 32 (clist -> expr .)
    RPAREN          reduce using rule 32 (clist -> expr .)
    COMMA           shift and go to state 126
    LBRACKET        shift and go to state 69
    QUESTIONMARK    shift and go to state 70
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 74
    MODULO          shift and go to state 75
    GT              shift and go to state 76
    LT              shift and go to state 77
    EQ              shift and go to state 78
    LE              shift and go to state 79
    GE              shift and go to state 80
    NE              shift and go to state 81
    LOR             shift and go to state 82
    LAND            shift and go to state 83


state 98

    (4) func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .

    DEF             reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    $end            reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    error           reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    LNOT            reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    PLUS            reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    MINUS           reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    ID              reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    NUMBER          reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    STRING          reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    VAR             reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    RETURN          reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    IF              reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    WHILE           reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    FOR             reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    LBRACE          reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    LBRACKET        reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    RBRACE          reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    ELSE            reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)


state 99

    (5) func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .

    DEF             reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    $end            reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    error           reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    LNOT            reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    PLUS            reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    MINUS           reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    ID              reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    NUMBER          reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    STRING          reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    VAR             reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    RETURN          reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    LBRACE          reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    LBRACKET        reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    ELSE            reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)


state 100

    (6) func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .

    DEF             reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    $end            reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    error           reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    LNOT            reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    PLUS            reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    MINUS           reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    ID              reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    NUMBER          reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    STRING          reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    VAR             reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    RETURN          reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    LBRACE          reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    LBRACKET        reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    ELSE            reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)


state 101

    (48) operation_on_list -> ID LBRACKET expr . RBRACKET
    (50) assignment -> ID LBRACKET expr . RBRACKET EQUALS expr
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    RBRACKET        shift and go to state 127
    LBRACKET        shift and go to state 69
    QUESTIONMARK    shift and go to state 70
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 74
    MODULO          shift and go to state 75
    GT              shift and go to state 76
    LT              shift and go to state 77
    EQ              shift and go to state 78
    LE              shift and go to state 79
    GE              shift and go to state 80
    NE              shift and go to state 81
    LOR             shift and go to state 82
    LAND            shift and go to state 83


state 102

    (49) assignment -> ID EQUALS expr .
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 49 (assignment -> ID EQUALS expr .)
    LBRACKET        reduce using rule 49 (assignment -> ID EQUALS expr .)
    COMMA           reduce using rule 49 (assignment -> ID EQUALS expr .)
    RBRACKET        reduce using rule 49 (assignment -> ID EQUALS expr .)
    RPAREN          reduce using rule 49 (assignment -> ID EQUALS expr .)
    COLON           reduce using rule 49 (assignment -> ID EQUALS expr .)
    TO              reduce using rule 49 (assignment -> ID EQUALS expr .)
    QUESTIONMARK    shift and go to state 70
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 74
    MODULO          shift and go to state 75
    GT              shift and go to state 76
    LT              shift and go to state 77
    EQ              shift and go to state 78
    LE              shift and go to state 79
    GE              shift and go to state 80
    NE              shift and go to state 81
    LOR             shift and go to state 82
    LAND            shift and go to state 83

  ! QUESTIONMARK    [ reduce using rule 49 (assignment -> ID EQUALS expr .) ]
  ! PLUS            [ reduce using rule 49 (assignment -> ID EQUALS expr .) ]
  ! MINUS           [ reduce using rule 49 (assignment -> ID EQUALS expr .) ]
  ! TIMES           [ reduce using rule 49 (assignment -> ID EQUALS expr .) ]
  ! DIVIDE          [ reduce using rule 49 (assignment -> ID EQUALS expr .) ]
  ! MODULO          [ reduce using rule 49 (assignment -> ID EQUALS expr .) ]
  ! GT              [ reduce using rule 49 (assignment -> ID EQUALS expr .) ]
  ! LT              [ reduce using rule 49 (assignment -> ID EQUALS expr .) ]
  ! EQ              [ reduce using rule 49 (assignment -> ID EQUALS expr .) ]
  ! LE              [ reduce using rule 49 (assignment -> ID EQUALS expr .) ]
  ! GE              [ reduce using rule 49 (assignment -> ID EQUALS expr .) ]
  ! NE              [ reduce using rule 49 (assignment -> ID EQUALS expr .) ]
  ! LOR             [ reduce using rule 49 (assignment -> ID EQUALS expr .) ]
  ! LAND            [ reduce using rule 49 (assignment -> ID EQUALS expr .) ]
  ! LBRACKET        [ shift and go to state 69 ]


state 103

    (52) function_call -> ID LPAREN clist . RPAREN

    RPAREN          shift and go to state 128


state 104

    (53) function_call -> ID LPAREN error . RPAREN

    RPAREN          shift and go to state 129


state 105

    (24) block -> LBRACE body RBRACE .

    error           reduce using rule 24 (block -> LBRACE body RBRACE .)
    LNOT            reduce using rule 24 (block -> LBRACE body RBRACE .)
    PLUS            reduce using rule 24 (block -> LBRACE body RBRACE .)
    MINUS           reduce using rule 24 (block -> LBRACE body RBRACE .)
    ID              reduce using rule 24 (block -> LBRACE body RBRACE .)
    NUMBER          reduce using rule 24 (block -> LBRACE body RBRACE .)
    STRING          reduce using rule 24 (block -> LBRACE body RBRACE .)
    VAR             reduce using rule 24 (block -> LBRACE body RBRACE .)
    RETURN          reduce using rule 24 (block -> LBRACE body RBRACE .)
    IF              reduce using rule 24 (block -> LBRACE body RBRACE .)
    WHILE           reduce using rule 24 (block -> LBRACE body RBRACE .)
    FOR             reduce using rule 24 (block -> LBRACE body RBRACE .)
    LBRACE          reduce using rule 24 (block -> LBRACE body RBRACE .)
    DEF             reduce using rule 24 (block -> LBRACE body RBRACE .)
    LBRACKET        reduce using rule 24 (block -> LBRACE body RBRACE .)
    RBRACE          reduce using rule 24 (block -> LBRACE body RBRACE .)
    ELSE            reduce using rule 24 (block -> LBRACE body RBRACE .)


state 106

    (47) operation_on_list -> expr LBRACKET expr . RBRACKET
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    RBRACKET        shift and go to state 130
    LBRACKET        shift and go to state 69
    QUESTIONMARK    shift and go to state 70
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 74
    MODULO          shift and go to state 75
    GT              shift and go to state 76
    LT              shift and go to state 77
    EQ              shift and go to state 78
    LE              shift and go to state 79
    GE              shift and go to state 80
    NE              shift and go to state 81
    LOR             shift and go to state 82
    LAND            shift and go to state 83


state 107

    (51) ternary_expr -> expr QUESTIONMARK expr . COLON expr
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    COLON           shift and go to state 131
    LBRACKET        shift and go to state 69
    QUESTIONMARK    shift and go to state 70
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 74
    MODULO          shift and go to state 75
    GT              shift and go to state 76
    LT              shift and go to state 77
    EQ              shift and go to state 78
    LE              shift and go to state 79
    GE              shift and go to state 80
    NE              shift and go to state 81
    LOR             shift and go to state 82
    LAND            shift and go to state 83


state 108

    (54) binary_expr -> expr PLUS expr .
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 54 (binary_expr -> expr PLUS expr .)
    LBRACKET        reduce using rule 54 (binary_expr -> expr PLUS expr .)
    PLUS            reduce using rule 54 (binary_expr -> expr PLUS expr .)
    MINUS           reduce using rule 54 (binary_expr -> expr PLUS expr .)
    GT              reduce using rule 54 (binary_expr -> expr PLUS expr .)
    LT              reduce using rule 54 (binary_expr -> expr PLUS expr .)
    EQ              reduce using rule 54 (binary_expr -> expr PLUS expr .)
    LE              reduce using rule 54 (binary_expr -> expr PLUS expr .)
    GE              reduce using rule 54 (binary_expr -> expr PLUS expr .)
    NE              reduce using rule 54 (binary_expr -> expr PLUS expr .)
    LOR             reduce using rule 54 (binary_expr -> expr PLUS expr .)
    LAND            reduce using rule 54 (binary_expr -> expr PLUS expr .)
    COMMA           reduce using rule 54 (binary_expr -> expr PLUS expr .)
    RBRACKET        reduce using rule 54 (binary_expr -> expr PLUS expr .)
    RPAREN          reduce using rule 54 (binary_expr -> expr PLUS expr .)
    COLON           reduce using rule 54 (binary_expr -> expr PLUS expr .)
    TO              reduce using rule 54 (binary_expr -> expr PLUS expr .)
    QUESTIONMARK    shift and go to state 70
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 74
    MODULO          shift and go to state 75

  ! QUESTIONMARK    [ reduce using rule 54 (binary_expr -> expr PLUS expr .) ]
  ! TIMES           [ reduce using rule 54 (binary_expr -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 54 (binary_expr -> expr PLUS expr .) ]
  ! MODULO          [ reduce using rule 54 (binary_expr -> expr PLUS expr .) ]
  ! LBRACKET        [ shift and go to state 69 ]
  ! PLUS            [ shift and go to state 71 ]
  ! MINUS           [ shift and go to state 72 ]
  ! GT              [ shift and go to state 76 ]
  ! LT              [ shift and go to state 77 ]
  ! EQ              [ shift and go to state 78 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 80 ]
  ! NE              [ shift and go to state 81 ]
  ! LOR             [ shift and go to state 82 ]
  ! LAND            [ shift and go to state 83 ]


state 109

    (55) binary_expr -> expr MINUS expr .
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 55 (binary_expr -> expr MINUS expr .)
    LBRACKET        reduce using rule 55 (binary_expr -> expr MINUS expr .)
    PLUS            reduce using rule 55 (binary_expr -> expr MINUS expr .)
    MINUS           reduce using rule 55 (binary_expr -> expr MINUS expr .)
    GT              reduce using rule 55 (binary_expr -> expr MINUS expr .)
    LT              reduce using rule 55 (binary_expr -> expr MINUS expr .)
    EQ              reduce using rule 55 (binary_expr -> expr MINUS expr .)
    LE              reduce using rule 55 (binary_expr -> expr MINUS expr .)
    GE              reduce using rule 55 (binary_expr -> expr MINUS expr .)
    NE              reduce using rule 55 (binary_expr -> expr MINUS expr .)
    LOR             reduce using rule 55 (binary_expr -> expr MINUS expr .)
    LAND            reduce using rule 55 (binary_expr -> expr MINUS expr .)
    COMMA           reduce using rule 55 (binary_expr -> expr MINUS expr .)
    RBRACKET        reduce using rule 55 (binary_expr -> expr MINUS expr .)
    RPAREN          reduce using rule 55 (binary_expr -> expr MINUS expr .)
    COLON           reduce using rule 55 (binary_expr -> expr MINUS expr .)
    TO              reduce using rule 55 (binary_expr -> expr MINUS expr .)
    QUESTIONMARK    shift and go to state 70
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 74
    MODULO          shift and go to state 75

  ! QUESTIONMARK    [ reduce using rule 55 (binary_expr -> expr MINUS expr .) ]
  ! TIMES           [ reduce using rule 55 (binary_expr -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 55 (binary_expr -> expr MINUS expr .) ]
  ! MODULO          [ reduce using rule 55 (binary_expr -> expr MINUS expr .) ]
  ! LBRACKET        [ shift and go to state 69 ]
  ! PLUS            [ shift and go to state 71 ]
  ! MINUS           [ shift and go to state 72 ]
  ! GT              [ shift and go to state 76 ]
  ! LT              [ shift and go to state 77 ]
  ! EQ              [ shift and go to state 78 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 80 ]
  ! NE              [ shift and go to state 81 ]
  ! LOR             [ shift and go to state 82 ]
  ! LAND            [ shift and go to state 83 ]


state 110

    (56) binary_expr -> expr TIMES expr .
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 56 (binary_expr -> expr TIMES expr .)
    LBRACKET        reduce using rule 56 (binary_expr -> expr TIMES expr .)
    PLUS            reduce using rule 56 (binary_expr -> expr TIMES expr .)
    MINUS           reduce using rule 56 (binary_expr -> expr TIMES expr .)
    TIMES           reduce using rule 56 (binary_expr -> expr TIMES expr .)
    DIVIDE          reduce using rule 56 (binary_expr -> expr TIMES expr .)
    MODULO          reduce using rule 56 (binary_expr -> expr TIMES expr .)
    GT              reduce using rule 56 (binary_expr -> expr TIMES expr .)
    LT              reduce using rule 56 (binary_expr -> expr TIMES expr .)
    EQ              reduce using rule 56 (binary_expr -> expr TIMES expr .)
    LE              reduce using rule 56 (binary_expr -> expr TIMES expr .)
    GE              reduce using rule 56 (binary_expr -> expr TIMES expr .)
    NE              reduce using rule 56 (binary_expr -> expr TIMES expr .)
    LOR             reduce using rule 56 (binary_expr -> expr TIMES expr .)
    LAND            reduce using rule 56 (binary_expr -> expr TIMES expr .)
    COMMA           reduce using rule 56 (binary_expr -> expr TIMES expr .)
    RBRACKET        reduce using rule 56 (binary_expr -> expr TIMES expr .)
    RPAREN          reduce using rule 56 (binary_expr -> expr TIMES expr .)
    COLON           reduce using rule 56 (binary_expr -> expr TIMES expr .)
    TO              reduce using rule 56 (binary_expr -> expr TIMES expr .)
    QUESTIONMARK    shift and go to state 70

  ! QUESTIONMARK    [ reduce using rule 56 (binary_expr -> expr TIMES expr .) ]
  ! LBRACKET        [ shift and go to state 69 ]
  ! PLUS            [ shift and go to state 71 ]
  ! MINUS           [ shift and go to state 72 ]
  ! TIMES           [ shift and go to state 73 ]
  ! DIVIDE          [ shift and go to state 74 ]
  ! MODULO          [ shift and go to state 75 ]
  ! GT              [ shift and go to state 76 ]
  ! LT              [ shift and go to state 77 ]
  ! EQ              [ shift and go to state 78 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 80 ]
  ! NE              [ shift and go to state 81 ]
  ! LOR             [ shift and go to state 82 ]
  ! LAND            [ shift and go to state 83 ]


state 111

    (57) binary_expr -> expr DIVIDE expr .
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    LBRACKET        reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    PLUS            reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    TIMES           reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    MODULO          reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    GT              reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    LT              reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    EQ              reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    LE              reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    GE              reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    NE              reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    LOR             reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    LAND            reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    COMMA           reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    RBRACKET        reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    RPAREN          reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    COLON           reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    TO              reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    QUESTIONMARK    shift and go to state 70

  ! QUESTIONMARK    [ reduce using rule 57 (binary_expr -> expr DIVIDE expr .) ]
  ! LBRACKET        [ shift and go to state 69 ]
  ! PLUS            [ shift and go to state 71 ]
  ! MINUS           [ shift and go to state 72 ]
  ! TIMES           [ shift and go to state 73 ]
  ! DIVIDE          [ shift and go to state 74 ]
  ! MODULO          [ shift and go to state 75 ]
  ! GT              [ shift and go to state 76 ]
  ! LT              [ shift and go to state 77 ]
  ! EQ              [ shift and go to state 78 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 80 ]
  ! NE              [ shift and go to state 81 ]
  ! LOR             [ shift and go to state 82 ]
  ! LAND            [ shift and go to state 83 ]


state 112

    (58) binary_expr -> expr MODULO expr .
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 58 (binary_expr -> expr MODULO expr .)
    LBRACKET        reduce using rule 58 (binary_expr -> expr MODULO expr .)
    PLUS            reduce using rule 58 (binary_expr -> expr MODULO expr .)
    MINUS           reduce using rule 58 (binary_expr -> expr MODULO expr .)
    TIMES           reduce using rule 58 (binary_expr -> expr MODULO expr .)
    DIVIDE          reduce using rule 58 (binary_expr -> expr MODULO expr .)
    MODULO          reduce using rule 58 (binary_expr -> expr MODULO expr .)
    GT              reduce using rule 58 (binary_expr -> expr MODULO expr .)
    LT              reduce using rule 58 (binary_expr -> expr MODULO expr .)
    EQ              reduce using rule 58 (binary_expr -> expr MODULO expr .)
    LE              reduce using rule 58 (binary_expr -> expr MODULO expr .)
    GE              reduce using rule 58 (binary_expr -> expr MODULO expr .)
    NE              reduce using rule 58 (binary_expr -> expr MODULO expr .)
    LOR             reduce using rule 58 (binary_expr -> expr MODULO expr .)
    LAND            reduce using rule 58 (binary_expr -> expr MODULO expr .)
    COMMA           reduce using rule 58 (binary_expr -> expr MODULO expr .)
    RBRACKET        reduce using rule 58 (binary_expr -> expr MODULO expr .)
    RPAREN          reduce using rule 58 (binary_expr -> expr MODULO expr .)
    COLON           reduce using rule 58 (binary_expr -> expr MODULO expr .)
    TO              reduce using rule 58 (binary_expr -> expr MODULO expr .)
    QUESTIONMARK    shift and go to state 70

  ! QUESTIONMARK    [ reduce using rule 58 (binary_expr -> expr MODULO expr .) ]
  ! LBRACKET        [ shift and go to state 69 ]
  ! PLUS            [ shift and go to state 71 ]
  ! MINUS           [ shift and go to state 72 ]
  ! TIMES           [ shift and go to state 73 ]
  ! DIVIDE          [ shift and go to state 74 ]
  ! MODULO          [ shift and go to state 75 ]
  ! GT              [ shift and go to state 76 ]
  ! LT              [ shift and go to state 77 ]
  ! EQ              [ shift and go to state 78 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 80 ]
  ! NE              [ shift and go to state 81 ]
  ! LOR             [ shift and go to state 82 ]
  ! LAND            [ shift and go to state 83 ]


state 113

    (59) binary_expr -> expr GT expr .
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 59 (binary_expr -> expr GT expr .)
    LBRACKET        reduce using rule 59 (binary_expr -> expr GT expr .)
    GT              reduce using rule 59 (binary_expr -> expr GT expr .)
    LT              reduce using rule 59 (binary_expr -> expr GT expr .)
    EQ              reduce using rule 59 (binary_expr -> expr GT expr .)
    LE              reduce using rule 59 (binary_expr -> expr GT expr .)
    GE              reduce using rule 59 (binary_expr -> expr GT expr .)
    NE              reduce using rule 59 (binary_expr -> expr GT expr .)
    LOR             reduce using rule 59 (binary_expr -> expr GT expr .)
    LAND            reduce using rule 59 (binary_expr -> expr GT expr .)
    COMMA           reduce using rule 59 (binary_expr -> expr GT expr .)
    RBRACKET        reduce using rule 59 (binary_expr -> expr GT expr .)
    RPAREN          reduce using rule 59 (binary_expr -> expr GT expr .)
    COLON           reduce using rule 59 (binary_expr -> expr GT expr .)
    TO              reduce using rule 59 (binary_expr -> expr GT expr .)
    QUESTIONMARK    shift and go to state 70
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 74
    MODULO          shift and go to state 75

  ! QUESTIONMARK    [ reduce using rule 59 (binary_expr -> expr GT expr .) ]
  ! PLUS            [ reduce using rule 59 (binary_expr -> expr GT expr .) ]
  ! MINUS           [ reduce using rule 59 (binary_expr -> expr GT expr .) ]
  ! TIMES           [ reduce using rule 59 (binary_expr -> expr GT expr .) ]
  ! DIVIDE          [ reduce using rule 59 (binary_expr -> expr GT expr .) ]
  ! MODULO          [ reduce using rule 59 (binary_expr -> expr GT expr .) ]
  ! LBRACKET        [ shift and go to state 69 ]
  ! GT              [ shift and go to state 76 ]
  ! LT              [ shift and go to state 77 ]
  ! EQ              [ shift and go to state 78 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 80 ]
  ! NE              [ shift and go to state 81 ]
  ! LOR             [ shift and go to state 82 ]
  ! LAND            [ shift and go to state 83 ]


state 114

    (60) binary_expr -> expr LT expr .
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 60 (binary_expr -> expr LT expr .)
    LBRACKET        reduce using rule 60 (binary_expr -> expr LT expr .)
    GT              reduce using rule 60 (binary_expr -> expr LT expr .)
    LT              reduce using rule 60 (binary_expr -> expr LT expr .)
    EQ              reduce using rule 60 (binary_expr -> expr LT expr .)
    LE              reduce using rule 60 (binary_expr -> expr LT expr .)
    GE              reduce using rule 60 (binary_expr -> expr LT expr .)
    NE              reduce using rule 60 (binary_expr -> expr LT expr .)
    LOR             reduce using rule 60 (binary_expr -> expr LT expr .)
    LAND            reduce using rule 60 (binary_expr -> expr LT expr .)
    COMMA           reduce using rule 60 (binary_expr -> expr LT expr .)
    RBRACKET        reduce using rule 60 (binary_expr -> expr LT expr .)
    RPAREN          reduce using rule 60 (binary_expr -> expr LT expr .)
    COLON           reduce using rule 60 (binary_expr -> expr LT expr .)
    TO              reduce using rule 60 (binary_expr -> expr LT expr .)
    QUESTIONMARK    shift and go to state 70
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 74
    MODULO          shift and go to state 75

  ! QUESTIONMARK    [ reduce using rule 60 (binary_expr -> expr LT expr .) ]
  ! PLUS            [ reduce using rule 60 (binary_expr -> expr LT expr .) ]
  ! MINUS           [ reduce using rule 60 (binary_expr -> expr LT expr .) ]
  ! TIMES           [ reduce using rule 60 (binary_expr -> expr LT expr .) ]
  ! DIVIDE          [ reduce using rule 60 (binary_expr -> expr LT expr .) ]
  ! MODULO          [ reduce using rule 60 (binary_expr -> expr LT expr .) ]
  ! LBRACKET        [ shift and go to state 69 ]
  ! GT              [ shift and go to state 76 ]
  ! LT              [ shift and go to state 77 ]
  ! EQ              [ shift and go to state 78 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 80 ]
  ! NE              [ shift and go to state 81 ]
  ! LOR             [ shift and go to state 82 ]
  ! LAND            [ shift and go to state 83 ]


state 115

    (61) binary_expr -> expr EQ expr .
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 61 (binary_expr -> expr EQ expr .)
    LBRACKET        reduce using rule 61 (binary_expr -> expr EQ expr .)
    GT              reduce using rule 61 (binary_expr -> expr EQ expr .)
    LT              reduce using rule 61 (binary_expr -> expr EQ expr .)
    EQ              reduce using rule 61 (binary_expr -> expr EQ expr .)
    LE              reduce using rule 61 (binary_expr -> expr EQ expr .)
    GE              reduce using rule 61 (binary_expr -> expr EQ expr .)
    NE              reduce using rule 61 (binary_expr -> expr EQ expr .)
    LOR             reduce using rule 61 (binary_expr -> expr EQ expr .)
    LAND            reduce using rule 61 (binary_expr -> expr EQ expr .)
    COMMA           reduce using rule 61 (binary_expr -> expr EQ expr .)
    RBRACKET        reduce using rule 61 (binary_expr -> expr EQ expr .)
    RPAREN          reduce using rule 61 (binary_expr -> expr EQ expr .)
    COLON           reduce using rule 61 (binary_expr -> expr EQ expr .)
    TO              reduce using rule 61 (binary_expr -> expr EQ expr .)
    QUESTIONMARK    shift and go to state 70
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 74
    MODULO          shift and go to state 75

  ! QUESTIONMARK    [ reduce using rule 61 (binary_expr -> expr EQ expr .) ]
  ! PLUS            [ reduce using rule 61 (binary_expr -> expr EQ expr .) ]
  ! MINUS           [ reduce using rule 61 (binary_expr -> expr EQ expr .) ]
  ! TIMES           [ reduce using rule 61 (binary_expr -> expr EQ expr .) ]
  ! DIVIDE          [ reduce using rule 61 (binary_expr -> expr EQ expr .) ]
  ! MODULO          [ reduce using rule 61 (binary_expr -> expr EQ expr .) ]
  ! LBRACKET        [ shift and go to state 69 ]
  ! GT              [ shift and go to state 76 ]
  ! LT              [ shift and go to state 77 ]
  ! EQ              [ shift and go to state 78 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 80 ]
  ! NE              [ shift and go to state 81 ]
  ! LOR             [ shift and go to state 82 ]
  ! LAND            [ shift and go to state 83 ]


state 116

    (62) binary_expr -> expr LE expr .
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 62 (binary_expr -> expr LE expr .)
    LBRACKET        reduce using rule 62 (binary_expr -> expr LE expr .)
    GT              reduce using rule 62 (binary_expr -> expr LE expr .)
    LT              reduce using rule 62 (binary_expr -> expr LE expr .)
    EQ              reduce using rule 62 (binary_expr -> expr LE expr .)
    LE              reduce using rule 62 (binary_expr -> expr LE expr .)
    GE              reduce using rule 62 (binary_expr -> expr LE expr .)
    NE              reduce using rule 62 (binary_expr -> expr LE expr .)
    LOR             reduce using rule 62 (binary_expr -> expr LE expr .)
    LAND            reduce using rule 62 (binary_expr -> expr LE expr .)
    COMMA           reduce using rule 62 (binary_expr -> expr LE expr .)
    RBRACKET        reduce using rule 62 (binary_expr -> expr LE expr .)
    RPAREN          reduce using rule 62 (binary_expr -> expr LE expr .)
    COLON           reduce using rule 62 (binary_expr -> expr LE expr .)
    TO              reduce using rule 62 (binary_expr -> expr LE expr .)
    QUESTIONMARK    shift and go to state 70
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 74
    MODULO          shift and go to state 75

  ! QUESTIONMARK    [ reduce using rule 62 (binary_expr -> expr LE expr .) ]
  ! PLUS            [ reduce using rule 62 (binary_expr -> expr LE expr .) ]
  ! MINUS           [ reduce using rule 62 (binary_expr -> expr LE expr .) ]
  ! TIMES           [ reduce using rule 62 (binary_expr -> expr LE expr .) ]
  ! DIVIDE          [ reduce using rule 62 (binary_expr -> expr LE expr .) ]
  ! MODULO          [ reduce using rule 62 (binary_expr -> expr LE expr .) ]
  ! LBRACKET        [ shift and go to state 69 ]
  ! GT              [ shift and go to state 76 ]
  ! LT              [ shift and go to state 77 ]
  ! EQ              [ shift and go to state 78 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 80 ]
  ! NE              [ shift and go to state 81 ]
  ! LOR             [ shift and go to state 82 ]
  ! LAND            [ shift and go to state 83 ]


state 117

    (63) binary_expr -> expr GE expr .
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 63 (binary_expr -> expr GE expr .)
    LBRACKET        reduce using rule 63 (binary_expr -> expr GE expr .)
    GT              reduce using rule 63 (binary_expr -> expr GE expr .)
    LT              reduce using rule 63 (binary_expr -> expr GE expr .)
    EQ              reduce using rule 63 (binary_expr -> expr GE expr .)
    LE              reduce using rule 63 (binary_expr -> expr GE expr .)
    GE              reduce using rule 63 (binary_expr -> expr GE expr .)
    NE              reduce using rule 63 (binary_expr -> expr GE expr .)
    LOR             reduce using rule 63 (binary_expr -> expr GE expr .)
    LAND            reduce using rule 63 (binary_expr -> expr GE expr .)
    COMMA           reduce using rule 63 (binary_expr -> expr GE expr .)
    RBRACKET        reduce using rule 63 (binary_expr -> expr GE expr .)
    RPAREN          reduce using rule 63 (binary_expr -> expr GE expr .)
    COLON           reduce using rule 63 (binary_expr -> expr GE expr .)
    TO              reduce using rule 63 (binary_expr -> expr GE expr .)
    QUESTIONMARK    shift and go to state 70
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 74
    MODULO          shift and go to state 75

  ! QUESTIONMARK    [ reduce using rule 63 (binary_expr -> expr GE expr .) ]
  ! PLUS            [ reduce using rule 63 (binary_expr -> expr GE expr .) ]
  ! MINUS           [ reduce using rule 63 (binary_expr -> expr GE expr .) ]
  ! TIMES           [ reduce using rule 63 (binary_expr -> expr GE expr .) ]
  ! DIVIDE          [ reduce using rule 63 (binary_expr -> expr GE expr .) ]
  ! MODULO          [ reduce using rule 63 (binary_expr -> expr GE expr .) ]
  ! LBRACKET        [ shift and go to state 69 ]
  ! GT              [ shift and go to state 76 ]
  ! LT              [ shift and go to state 77 ]
  ! EQ              [ shift and go to state 78 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 80 ]
  ! NE              [ shift and go to state 81 ]
  ! LOR             [ shift and go to state 82 ]
  ! LAND            [ shift and go to state 83 ]


state 118

    (64) binary_expr -> expr NE expr .
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 64 (binary_expr -> expr NE expr .)
    LBRACKET        reduce using rule 64 (binary_expr -> expr NE expr .)
    GT              reduce using rule 64 (binary_expr -> expr NE expr .)
    LT              reduce using rule 64 (binary_expr -> expr NE expr .)
    EQ              reduce using rule 64 (binary_expr -> expr NE expr .)
    LE              reduce using rule 64 (binary_expr -> expr NE expr .)
    GE              reduce using rule 64 (binary_expr -> expr NE expr .)
    NE              reduce using rule 64 (binary_expr -> expr NE expr .)
    LOR             reduce using rule 64 (binary_expr -> expr NE expr .)
    LAND            reduce using rule 64 (binary_expr -> expr NE expr .)
    COMMA           reduce using rule 64 (binary_expr -> expr NE expr .)
    RBRACKET        reduce using rule 64 (binary_expr -> expr NE expr .)
    RPAREN          reduce using rule 64 (binary_expr -> expr NE expr .)
    COLON           reduce using rule 64 (binary_expr -> expr NE expr .)
    TO              reduce using rule 64 (binary_expr -> expr NE expr .)
    QUESTIONMARK    shift and go to state 70
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 74
    MODULO          shift and go to state 75

  ! QUESTIONMARK    [ reduce using rule 64 (binary_expr -> expr NE expr .) ]
  ! PLUS            [ reduce using rule 64 (binary_expr -> expr NE expr .) ]
  ! MINUS           [ reduce using rule 64 (binary_expr -> expr NE expr .) ]
  ! TIMES           [ reduce using rule 64 (binary_expr -> expr NE expr .) ]
  ! DIVIDE          [ reduce using rule 64 (binary_expr -> expr NE expr .) ]
  ! MODULO          [ reduce using rule 64 (binary_expr -> expr NE expr .) ]
  ! LBRACKET        [ shift and go to state 69 ]
  ! GT              [ shift and go to state 76 ]
  ! LT              [ shift and go to state 77 ]
  ! EQ              [ shift and go to state 78 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 80 ]
  ! NE              [ shift and go to state 81 ]
  ! LOR             [ shift and go to state 82 ]
  ! LAND            [ shift and go to state 83 ]


state 119

    (65) binary_expr -> expr LOR expr .
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 65 (binary_expr -> expr LOR expr .)
    LBRACKET        reduce using rule 65 (binary_expr -> expr LOR expr .)
    LOR             reduce using rule 65 (binary_expr -> expr LOR expr .)
    COMMA           reduce using rule 65 (binary_expr -> expr LOR expr .)
    RBRACKET        reduce using rule 65 (binary_expr -> expr LOR expr .)
    RPAREN          reduce using rule 65 (binary_expr -> expr LOR expr .)
    COLON           reduce using rule 65 (binary_expr -> expr LOR expr .)
    TO              reduce using rule 65 (binary_expr -> expr LOR expr .)
    QUESTIONMARK    shift and go to state 70
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 74
    MODULO          shift and go to state 75
    GT              shift and go to state 76
    LT              shift and go to state 77
    EQ              shift and go to state 78
    LE              shift and go to state 79
    GE              shift and go to state 80
    NE              shift and go to state 81
    LAND            shift and go to state 83

  ! QUESTIONMARK    [ reduce using rule 65 (binary_expr -> expr LOR expr .) ]
  ! PLUS            [ reduce using rule 65 (binary_expr -> expr LOR expr .) ]
  ! MINUS           [ reduce using rule 65 (binary_expr -> expr LOR expr .) ]
  ! TIMES           [ reduce using rule 65 (binary_expr -> expr LOR expr .) ]
  ! DIVIDE          [ reduce using rule 65 (binary_expr -> expr LOR expr .) ]
  ! MODULO          [ reduce using rule 65 (binary_expr -> expr LOR expr .) ]
  ! GT              [ reduce using rule 65 (binary_expr -> expr LOR expr .) ]
  ! LT              [ reduce using rule 65 (binary_expr -> expr LOR expr .) ]
  ! EQ              [ reduce using rule 65 (binary_expr -> expr LOR expr .) ]
  ! LE              [ reduce using rule 65 (binary_expr -> expr LOR expr .) ]
  ! GE              [ reduce using rule 65 (binary_expr -> expr LOR expr .) ]
  ! NE              [ reduce using rule 65 (binary_expr -> expr LOR expr .) ]
  ! LAND            [ reduce using rule 65 (binary_expr -> expr LOR expr .) ]
  ! LBRACKET        [ shift and go to state 69 ]
  ! LOR             [ shift and go to state 82 ]


state 120

    (66) binary_expr -> expr LAND expr .
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 66 (binary_expr -> expr LAND expr .)
    LBRACKET        reduce using rule 66 (binary_expr -> expr LAND expr .)
    LOR             reduce using rule 66 (binary_expr -> expr LAND expr .)
    LAND            reduce using rule 66 (binary_expr -> expr LAND expr .)
    COMMA           reduce using rule 66 (binary_expr -> expr LAND expr .)
    RBRACKET        reduce using rule 66 (binary_expr -> expr LAND expr .)
    RPAREN          reduce using rule 66 (binary_expr -> expr LAND expr .)
    COLON           reduce using rule 66 (binary_expr -> expr LAND expr .)
    TO              reduce using rule 66 (binary_expr -> expr LAND expr .)
    QUESTIONMARK    shift and go to state 70
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 74
    MODULO          shift and go to state 75
    GT              shift and go to state 76
    LT              shift and go to state 77
    EQ              shift and go to state 78
    LE              shift and go to state 79
    GE              shift and go to state 80
    NE              shift and go to state 81

  ! QUESTIONMARK    [ reduce using rule 66 (binary_expr -> expr LAND expr .) ]
  ! PLUS            [ reduce using rule 66 (binary_expr -> expr LAND expr .) ]
  ! MINUS           [ reduce using rule 66 (binary_expr -> expr LAND expr .) ]
  ! TIMES           [ reduce using rule 66 (binary_expr -> expr LAND expr .) ]
  ! DIVIDE          [ reduce using rule 66 (binary_expr -> expr LAND expr .) ]
  ! MODULO          [ reduce using rule 66 (binary_expr -> expr LAND expr .) ]
  ! GT              [ reduce using rule 66 (binary_expr -> expr LAND expr .) ]
  ! LT              [ reduce using rule 66 (binary_expr -> expr LAND expr .) ]
  ! EQ              [ reduce using rule 66 (binary_expr -> expr LAND expr .) ]
  ! LE              [ reduce using rule 66 (binary_expr -> expr LAND expr .) ]
  ! GE              [ reduce using rule 66 (binary_expr -> expr LAND expr .) ]
  ! NE              [ reduce using rule 66 (binary_expr -> expr LAND expr .) ]
  ! LBRACKET        [ shift and go to state 69 ]
  ! LOR             [ shift and go to state 82 ]
  ! LAND            [ shift and go to state 83 ]


state 121

    (26) defvar -> VAR TYPE ID .
    (27) defvar -> VAR TYPE ID . EQUALS expr

    SEMI            reduce using rule 26 (defvar -> VAR TYPE ID .)
    EQUALS          shift and go to state 132


state 122

    (20) single_if -> IF LPAREN expr . RPAREN stmt
    (21) if_with_else -> IF LPAREN expr . RPAREN stmt ELSE stmt
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    RPAREN          shift and go to state 133
    LBRACKET        shift and go to state 69
    QUESTIONMARK    shift and go to state 70
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 74
    MODULO          shift and go to state 75
    GT              shift and go to state 76
    LT              shift and go to state 77
    EQ              shift and go to state 78
    LE              shift and go to state 79
    GE              shift and go to state 80
    NE              shift and go to state 81
    LOR             shift and go to state 82
    LAND            shift and go to state 83


state 123

    (22) while_loop -> WHILE LPAREN expr . RPAREN stmt
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    RPAREN          shift and go to state 134
    LBRACKET        shift and go to state 69
    QUESTIONMARK    shift and go to state 70
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 74
    MODULO          shift and go to state 75
    GT              shift and go to state 76
    LT              shift and go to state 77
    EQ              shift and go to state 78
    LE              shift and go to state 79
    GE              shift and go to state 80
    NE              shift and go to state 81
    LOR             shift and go to state 82
    LAND            shift and go to state 83


state 124

    (23) for_loop -> FOR LPAREN ID . EQUALS expr TO expr RPAREN stmt

    EQUALS          shift and go to state 135


state 125

    (46) expr_list -> LBRACKET clist RBRACKET .

    SEMI            reduce using rule 46 (expr_list -> LBRACKET clist RBRACKET .)
    LBRACKET        reduce using rule 46 (expr_list -> LBRACKET clist RBRACKET .)
    QUESTIONMARK    reduce using rule 46 (expr_list -> LBRACKET clist RBRACKET .)
    PLUS            reduce using rule 46 (expr_list -> LBRACKET clist RBRACKET .)
    MINUS           reduce using rule 46 (expr_list -> LBRACKET clist RBRACKET .)
    TIMES           reduce using rule 46 (expr_list -> LBRACKET clist RBRACKET .)
    DIVIDE          reduce using rule 46 (expr_list -> LBRACKET clist RBRACKET .)
    MODULO          reduce using rule 46 (expr_list -> LBRACKET clist RBRACKET .)
    GT              reduce using rule 46 (expr_list -> LBRACKET clist RBRACKET .)
    LT              reduce using rule 46 (expr_list -> LBRACKET clist RBRACKET .)
    EQ              reduce using rule 46 (expr_list -> LBRACKET clist RBRACKET .)
    LE              reduce using rule 46 (expr_list -> LBRACKET clist RBRACKET .)
    GE              reduce using rule 46 (expr_list -> LBRACKET clist RBRACKET .)
    NE              reduce using rule 46 (expr_list -> LBRACKET clist RBRACKET .)
    LOR             reduce using rule 46 (expr_list -> LBRACKET clist RBRACKET .)
    LAND            reduce using rule 46 (expr_list -> LBRACKET clist RBRACKET .)
    COMMA           reduce using rule 46 (expr_list -> LBRACKET clist RBRACKET .)
    RBRACKET        reduce using rule 46 (expr_list -> LBRACKET clist RBRACKET .)
    RPAREN          reduce using rule 46 (expr_list -> LBRACKET clist RBRACKET .)
    COLON           reduce using rule 46 (expr_list -> LBRACKET clist RBRACKET .)
    TO              reduce using rule 46 (expr_list -> LBRACKET clist RBRACKET .)


state 126

    (33) clist -> expr COMMA . clist
    (31) clist -> . empty
    (32) clist -> . expr
    (33) clist -> . expr COMMA clist
    (67) empty -> .
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    RBRACKET        reduce using rule 67 (empty -> .)
    RPAREN          reduce using rule 67 (empty -> .)
    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 97
    clist                          shift and go to state 136
    empty                          shift and go to state 96
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 127

    (48) operation_on_list -> ID LBRACKET expr RBRACKET .
    (50) assignment -> ID LBRACKET expr RBRACKET . EQUALS expr

    SEMI            reduce using rule 48 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    LBRACKET        reduce using rule 48 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    QUESTIONMARK    reduce using rule 48 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 48 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 48 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    TIMES           reduce using rule 48 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 48 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    MODULO          reduce using rule 48 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    GT              reduce using rule 48 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    LT              reduce using rule 48 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    EQ              reduce using rule 48 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    LE              reduce using rule 48 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    GE              reduce using rule 48 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    NE              reduce using rule 48 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    LOR             reduce using rule 48 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    LAND            reduce using rule 48 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 48 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 48 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 48 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    COLON           reduce using rule 48 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    TO              reduce using rule 48 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    EQUALS          shift and go to state 137


state 128

    (52) function_call -> ID LPAREN clist RPAREN .

    SEMI            reduce using rule 52 (function_call -> ID LPAREN clist RPAREN .)
    LBRACKET        reduce using rule 52 (function_call -> ID LPAREN clist RPAREN .)
    QUESTIONMARK    reduce using rule 52 (function_call -> ID LPAREN clist RPAREN .)
    PLUS            reduce using rule 52 (function_call -> ID LPAREN clist RPAREN .)
    MINUS           reduce using rule 52 (function_call -> ID LPAREN clist RPAREN .)
    TIMES           reduce using rule 52 (function_call -> ID LPAREN clist RPAREN .)
    DIVIDE          reduce using rule 52 (function_call -> ID LPAREN clist RPAREN .)
    MODULO          reduce using rule 52 (function_call -> ID LPAREN clist RPAREN .)
    GT              reduce using rule 52 (function_call -> ID LPAREN clist RPAREN .)
    LT              reduce using rule 52 (function_call -> ID LPAREN clist RPAREN .)
    EQ              reduce using rule 52 (function_call -> ID LPAREN clist RPAREN .)
    LE              reduce using rule 52 (function_call -> ID LPAREN clist RPAREN .)
    GE              reduce using rule 52 (function_call -> ID LPAREN clist RPAREN .)
    NE              reduce using rule 52 (function_call -> ID LPAREN clist RPAREN .)
    LOR             reduce using rule 52 (function_call -> ID LPAREN clist RPAREN .)
    LAND            reduce using rule 52 (function_call -> ID LPAREN clist RPAREN .)
    COMMA           reduce using rule 52 (function_call -> ID LPAREN clist RPAREN .)
    RBRACKET        reduce using rule 52 (function_call -> ID LPAREN clist RPAREN .)
    RPAREN          reduce using rule 52 (function_call -> ID LPAREN clist RPAREN .)
    COLON           reduce using rule 52 (function_call -> ID LPAREN clist RPAREN .)
    TO              reduce using rule 52 (function_call -> ID LPAREN clist RPAREN .)


state 129

    (53) function_call -> ID LPAREN error RPAREN .

    SEMI            reduce using rule 53 (function_call -> ID LPAREN error RPAREN .)
    LBRACKET        reduce using rule 53 (function_call -> ID LPAREN error RPAREN .)
    QUESTIONMARK    reduce using rule 53 (function_call -> ID LPAREN error RPAREN .)
    PLUS            reduce using rule 53 (function_call -> ID LPAREN error RPAREN .)
    MINUS           reduce using rule 53 (function_call -> ID LPAREN error RPAREN .)
    TIMES           reduce using rule 53 (function_call -> ID LPAREN error RPAREN .)
    DIVIDE          reduce using rule 53 (function_call -> ID LPAREN error RPAREN .)
    MODULO          reduce using rule 53 (function_call -> ID LPAREN error RPAREN .)
    GT              reduce using rule 53 (function_call -> ID LPAREN error RPAREN .)
    LT              reduce using rule 53 (function_call -> ID LPAREN error RPAREN .)
    EQ              reduce using rule 53 (function_call -> ID LPAREN error RPAREN .)
    LE              reduce using rule 53 (function_call -> ID LPAREN error RPAREN .)
    GE              reduce using rule 53 (function_call -> ID LPAREN error RPAREN .)
    NE              reduce using rule 53 (function_call -> ID LPAREN error RPAREN .)
    LOR             reduce using rule 53 (function_call -> ID LPAREN error RPAREN .)
    LAND            reduce using rule 53 (function_call -> ID LPAREN error RPAREN .)
    COMMA           reduce using rule 53 (function_call -> ID LPAREN error RPAREN .)
    RBRACKET        reduce using rule 53 (function_call -> ID LPAREN error RPAREN .)
    RPAREN          reduce using rule 53 (function_call -> ID LPAREN error RPAREN .)
    COLON           reduce using rule 53 (function_call -> ID LPAREN error RPAREN .)
    TO              reduce using rule 53 (function_call -> ID LPAREN error RPAREN .)


state 130

    (47) operation_on_list -> expr LBRACKET expr RBRACKET .

    SEMI            reduce using rule 47 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    LBRACKET        reduce using rule 47 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    QUESTIONMARK    reduce using rule 47 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 47 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 47 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    TIMES           reduce using rule 47 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 47 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    MODULO          reduce using rule 47 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    GT              reduce using rule 47 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    LT              reduce using rule 47 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    EQ              reduce using rule 47 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    LE              reduce using rule 47 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    GE              reduce using rule 47 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    NE              reduce using rule 47 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    LOR             reduce using rule 47 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    LAND            reduce using rule 47 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 47 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 47 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 47 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    COLON           reduce using rule 47 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    TO              reduce using rule 47 (operation_on_list -> expr LBRACKET expr RBRACKET .)


state 131

    (51) ternary_expr -> expr QUESTIONMARK expr COLON . expr
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 138
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 132

    (27) defvar -> VAR TYPE ID EQUALS . expr
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 139
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 133

    (20) single_if -> IF LPAREN expr RPAREN . stmt
    (21) if_with_else -> IF LPAREN expr RPAREN . stmt ELSE stmt
    (9) stmt -> . expr SEMI
    (10) stmt -> . defvar SEMI
    (11) stmt -> . return_instr SEMI
    (12) stmt -> . single_if
    (13) stmt -> . if_with_else
    (14) stmt -> . while_loop
    (15) stmt -> . for_loop
    (16) stmt -> . block
    (17) stmt -> . func
    (18) stmt -> . error SEMI
    (19) stmt -> . error
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (26) defvar -> . VAR TYPE ID
    (27) defvar -> . VAR TYPE ID EQUALS expr
    (25) return_instr -> . RETURN expr
    (20) single_if -> . IF LPAREN expr RPAREN stmt
    (21) if_with_else -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (22) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (23) for_loop -> . FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
    (24) block -> . LBRACE body RBRACE
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> . DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE
    (6) func -> . DEF error ID LPAREN flist RPAREN LBRACE body RBRACE
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    error           shift and go to state 41
    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    VAR             shift and go to state 53
    RETURN          shift and go to state 54
    IF              shift and go to state 55
    WHILE           shift and go to state 56
    FOR             shift and go to state 57
    LBRACE          shift and go to state 28
    DEF             shift and go to state 4
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 32
    stmt                           shift and go to state 140
    defvar                         shift and go to state 33
    return_instr                   shift and go to state 34
    single_if                      shift and go to state 35
    if_with_else                   shift and go to state 36
    while_loop                     shift and go to state 37
    for_loop                       shift and go to state 38
    block                          shift and go to state 39
    func                           shift and go to state 40
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 134

    (22) while_loop -> WHILE LPAREN expr RPAREN . stmt
    (9) stmt -> . expr SEMI
    (10) stmt -> . defvar SEMI
    (11) stmt -> . return_instr SEMI
    (12) stmt -> . single_if
    (13) stmt -> . if_with_else
    (14) stmt -> . while_loop
    (15) stmt -> . for_loop
    (16) stmt -> . block
    (17) stmt -> . func
    (18) stmt -> . error SEMI
    (19) stmt -> . error
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (26) defvar -> . VAR TYPE ID
    (27) defvar -> . VAR TYPE ID EQUALS expr
    (25) return_instr -> . RETURN expr
    (20) single_if -> . IF LPAREN expr RPAREN stmt
    (21) if_with_else -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (22) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (23) for_loop -> . FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
    (24) block -> . LBRACE body RBRACE
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> . DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE
    (6) func -> . DEF error ID LPAREN flist RPAREN LBRACE body RBRACE
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    error           shift and go to state 41
    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    VAR             shift and go to state 53
    RETURN          shift and go to state 54
    IF              shift and go to state 55
    WHILE           shift and go to state 56
    FOR             shift and go to state 57
    LBRACE          shift and go to state 28
    DEF             shift and go to state 4
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 32
    stmt                           shift and go to state 141
    defvar                         shift and go to state 33
    return_instr                   shift and go to state 34
    single_if                      shift and go to state 35
    if_with_else                   shift and go to state 36
    while_loop                     shift and go to state 37
    for_loop                       shift and go to state 38
    block                          shift and go to state 39
    func                           shift and go to state 40
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 135

    (23) for_loop -> FOR LPAREN ID EQUALS . expr TO expr RPAREN stmt
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 142
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 136

    (33) clist -> expr COMMA clist .

    RBRACKET        reduce using rule 33 (clist -> expr COMMA clist .)
    RPAREN          reduce using rule 33 (clist -> expr COMMA clist .)


state 137

    (50) assignment -> ID LBRACKET expr RBRACKET EQUALS . expr
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 143
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 138

    (51) ternary_expr -> expr QUESTIONMARK expr COLON expr .
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 51 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    LBRACKET        reduce using rule 51 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    QUESTIONMARK    reduce using rule 51 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    PLUS            reduce using rule 51 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    MINUS           reduce using rule 51 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    TIMES           reduce using rule 51 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    DIVIDE          reduce using rule 51 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    MODULO          reduce using rule 51 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    GT              reduce using rule 51 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    LT              reduce using rule 51 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    EQ              reduce using rule 51 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    LE              reduce using rule 51 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    GE              reduce using rule 51 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    NE              reduce using rule 51 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    LOR             reduce using rule 51 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    LAND            reduce using rule 51 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    COMMA           reduce using rule 51 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    RBRACKET        reduce using rule 51 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    RPAREN          reduce using rule 51 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    COLON           reduce using rule 51 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    TO              reduce using rule 51 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)

  ! LBRACKET        [ shift and go to state 69 ]
  ! QUESTIONMARK    [ shift and go to state 70 ]
  ! PLUS            [ shift and go to state 71 ]
  ! MINUS           [ shift and go to state 72 ]
  ! TIMES           [ shift and go to state 73 ]
  ! DIVIDE          [ shift and go to state 74 ]
  ! MODULO          [ shift and go to state 75 ]
  ! GT              [ shift and go to state 76 ]
  ! LT              [ shift and go to state 77 ]
  ! EQ              [ shift and go to state 78 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 80 ]
  ! NE              [ shift and go to state 81 ]
  ! LOR             [ shift and go to state 82 ]
  ! LAND            [ shift and go to state 83 ]


state 139

    (27) defvar -> VAR TYPE ID EQUALS expr .
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 27 (defvar -> VAR TYPE ID EQUALS expr .)
    LBRACKET        shift and go to state 69
    QUESTIONMARK    shift and go to state 70
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 74
    MODULO          shift and go to state 75
    GT              shift and go to state 76
    LT              shift and go to state 77
    EQ              shift and go to state 78
    LE              shift and go to state 79
    GE              shift and go to state 80
    NE              shift and go to state 81
    LOR             shift and go to state 82
    LAND            shift and go to state 83


state 140

    (20) single_if -> IF LPAREN expr RPAREN stmt .
    (21) if_with_else -> IF LPAREN expr RPAREN stmt . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    error           reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    LNOT            reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    PLUS            reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    MINUS           reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    ID              reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    NUMBER          reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    STRING          reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    VAR             reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    IF              reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    LBRACE          reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    DEF             reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    LBRACKET        reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    RBRACE          reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    ELSE            shift and go to state 144

  ! ELSE            [ reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .) ]


state 141

    (22) while_loop -> WHILE LPAREN expr RPAREN stmt .

    error           reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    LNOT            reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    PLUS            reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    MINUS           reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    ID              reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    NUMBER          reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    STRING          reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    VAR             reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    IF              reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    LBRACE          reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    DEF             reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    LBRACKET        reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    RBRACE          reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    ELSE            reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)


state 142

    (23) for_loop -> FOR LPAREN ID EQUALS expr . TO expr RPAREN stmt
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    TO              shift and go to state 145
    LBRACKET        shift and go to state 69
    QUESTIONMARK    shift and go to state 70
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 74
    MODULO          shift and go to state 75
    GT              shift and go to state 76
    LT              shift and go to state 77
    EQ              shift and go to state 78
    LE              shift and go to state 79
    GE              shift and go to state 80
    NE              shift and go to state 81
    LOR             shift and go to state 82
    LAND            shift and go to state 83


state 143

    (50) assignment -> ID LBRACKET expr RBRACKET EQUALS expr .
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 50 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    LBRACKET        reduce using rule 50 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    QUESTIONMARK    reduce using rule 50 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    PLUS            reduce using rule 50 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    MINUS           reduce using rule 50 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    TIMES           reduce using rule 50 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    DIVIDE          reduce using rule 50 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    MODULO          reduce using rule 50 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    GT              reduce using rule 50 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    LT              reduce using rule 50 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    EQ              reduce using rule 50 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    LE              reduce using rule 50 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    GE              reduce using rule 50 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    NE              reduce using rule 50 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    LOR             reduce using rule 50 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    LAND            reduce using rule 50 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    COMMA           reduce using rule 50 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    RBRACKET        reduce using rule 50 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    RPAREN          reduce using rule 50 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    COLON           reduce using rule 50 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    TO              reduce using rule 50 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)

  ! LBRACKET        [ shift and go to state 69 ]
  ! QUESTIONMARK    [ shift and go to state 70 ]
  ! PLUS            [ shift and go to state 71 ]
  ! MINUS           [ shift and go to state 72 ]
  ! TIMES           [ shift and go to state 73 ]
  ! DIVIDE          [ shift and go to state 74 ]
  ! MODULO          [ shift and go to state 75 ]
  ! GT              [ shift and go to state 76 ]
  ! LT              [ shift and go to state 77 ]
  ! EQ              [ shift and go to state 78 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 80 ]
  ! NE              [ shift and go to state 81 ]
  ! LOR             [ shift and go to state 82 ]
  ! LAND            [ shift and go to state 83 ]


state 144

    (21) if_with_else -> IF LPAREN expr RPAREN stmt ELSE . stmt
    (9) stmt -> . expr SEMI
    (10) stmt -> . defvar SEMI
    (11) stmt -> . return_instr SEMI
    (12) stmt -> . single_if
    (13) stmt -> . if_with_else
    (14) stmt -> . while_loop
    (15) stmt -> . for_loop
    (16) stmt -> . block
    (17) stmt -> . func
    (18) stmt -> . error SEMI
    (19) stmt -> . error
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (26) defvar -> . VAR TYPE ID
    (27) defvar -> . VAR TYPE ID EQUALS expr
    (25) return_instr -> . RETURN expr
    (20) single_if -> . IF LPAREN expr RPAREN stmt
    (21) if_with_else -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (22) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (23) for_loop -> . FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
    (24) block -> . LBRACE body RBRACE
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> . DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE
    (6) func -> . DEF error ID LPAREN flist RPAREN LBRACE body RBRACE
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    error           shift and go to state 41
    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    VAR             shift and go to state 53
    RETURN          shift and go to state 54
    IF              shift and go to state 55
    WHILE           shift and go to state 56
    FOR             shift and go to state 57
    LBRACE          shift and go to state 28
    DEF             shift and go to state 4
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 32
    stmt                           shift and go to state 146
    defvar                         shift and go to state 33
    return_instr                   shift and go to state 34
    single_if                      shift and go to state 35
    if_with_else                   shift and go to state 36
    while_loop                     shift and go to state 37
    for_loop                       shift and go to state 38
    block                          shift and go to state 39
    func                           shift and go to state 40
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 145

    (23) for_loop -> FOR LPAREN ID EQUALS expr TO . expr RPAREN stmt
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 147
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 146

    (21) if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .

    error           reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    LNOT            reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    PLUS            reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    MINUS           reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    ID              reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    NUMBER          reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    STRING          reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    VAR             reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    RETURN          reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    IF              reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    WHILE           reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FOR             reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    LBRACE          reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    DEF             reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    LBRACKET        reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    RBRACE          reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    ELSE            reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)


state 147

    (23) for_loop -> FOR LPAREN ID EQUALS expr TO expr . RPAREN stmt
    (47) operation_on_list -> expr . LBRACKET expr RBRACKET
    (51) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . MODULO expr
    (59) binary_expr -> expr . GT expr
    (60) binary_expr -> expr . LT expr
    (61) binary_expr -> expr . EQ expr
    (62) binary_expr -> expr . LE expr
    (63) binary_expr -> expr . GE expr
    (64) binary_expr -> expr . NE expr
    (65) binary_expr -> expr . LOR expr
    (66) binary_expr -> expr . LAND expr

    RPAREN          shift and go to state 148
    LBRACKET        shift and go to state 69
    QUESTIONMARK    shift and go to state 70
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 74
    MODULO          shift and go to state 75
    GT              shift and go to state 76
    LT              shift and go to state 77
    EQ              shift and go to state 78
    LE              shift and go to state 79
    GE              shift and go to state 80
    NE              shift and go to state 81
    LOR             shift and go to state 82
    LAND            shift and go to state 83


state 148

    (23) for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN . stmt
    (9) stmt -> . expr SEMI
    (10) stmt -> . defvar SEMI
    (11) stmt -> . return_instr SEMI
    (12) stmt -> . single_if
    (13) stmt -> . if_with_else
    (14) stmt -> . while_loop
    (15) stmt -> . for_loop
    (16) stmt -> . block
    (17) stmt -> . func
    (18) stmt -> . error SEMI
    (19) stmt -> . error
    (34) expr -> . operation_on_list
    (35) expr -> . expr_list
    (36) expr -> . ternary_expr
    (37) expr -> . LNOT expr
    (38) expr -> . PLUS expr
    (39) expr -> . MINUS expr
    (40) expr -> . binary_expr
    (41) expr -> . ID
    (42) expr -> . assignment
    (43) expr -> . function_call
    (44) expr -> . NUMBER
    (45) expr -> . STRING
    (26) defvar -> . VAR TYPE ID
    (27) defvar -> . VAR TYPE ID EQUALS expr
    (25) return_instr -> . RETURN expr
    (20) single_if -> . IF LPAREN expr RPAREN stmt
    (21) if_with_else -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (22) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (23) for_loop -> . FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
    (24) block -> . LBRACE body RBRACE
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> . DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE
    (6) func -> . DEF error ID LPAREN flist RPAREN LBRACE body RBRACE
    (47) operation_on_list -> . expr LBRACKET expr RBRACKET
    (48) operation_on_list -> . ID LBRACKET expr RBRACKET
    (46) expr_list -> . LBRACKET clist RBRACKET
    (51) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr MODULO expr
    (59) binary_expr -> . expr GT expr
    (60) binary_expr -> . expr LT expr
    (61) binary_expr -> . expr EQ expr
    (62) binary_expr -> . expr LE expr
    (63) binary_expr -> . expr GE expr
    (64) binary_expr -> . expr NE expr
    (65) binary_expr -> . expr LOR expr
    (66) binary_expr -> . expr LAND expr
    (49) assignment -> . ID EQUALS expr
    (50) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (52) function_call -> . ID LPAREN clist RPAREN
    (53) function_call -> . ID LPAREN error RPAREN

    error           shift and go to state 41
    LNOT            shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    ID              shift and go to state 27
    NUMBER          shift and go to state 51
    STRING          shift and go to state 52
    VAR             shift and go to state 53
    RETURN          shift and go to state 54
    IF              shift and go to state 55
    WHILE           shift and go to state 56
    FOR             shift and go to state 57
    LBRACE          shift and go to state 28
    DEF             shift and go to state 4
    LBRACKET        shift and go to state 58

    expr                           shift and go to state 32
    stmt                           shift and go to state 149
    defvar                         shift and go to state 33
    return_instr                   shift and go to state 34
    single_if                      shift and go to state 35
    if_with_else                   shift and go to state 36
    while_loop                     shift and go to state 37
    for_loop                       shift and go to state 38
    block                          shift and go to state 39
    func                           shift and go to state 40
    operation_on_list              shift and go to state 42
    expr_list                      shift and go to state 43
    ternary_expr                   shift and go to state 44
    binary_expr                    shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50

state 149

    (23) for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .

    error           reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    LNOT            reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    PLUS            reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    MINUS           reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    ID              reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    NUMBER          reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    STRING          reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    VAR             reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    RETURN          reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    IF              reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    WHILE           reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    FOR             reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    LBRACE          reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    DEF             reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    LBRACKET        reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    RBRACE          reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    ELSE            reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LBRACKET in state 27 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 140 resolved as shift
