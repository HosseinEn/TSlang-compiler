Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ALSE
    AND
    AS
    AUTO
    BREAK
    CASE
    CLASS
    CLOSE
    CONST
    CONTINUE
    DECREMENT
    DEFAULT
    DEL
    DIVEQUAL
    EXCEPT
    FROM
    GLOBAL
    IMPORT
    IN
    INCREMENT
    INPUT
    INT
    IS
    LAMBDA
    LEN
    LSHIFT
    MINUSEQUAL
    MODEQUAL
    NONLOCAL
    NOT
    NULL
    ONE
    OPEN
    OR
    PASS
    PERIOD
    PLUSEQUAL
    RAISE
    RANGE
    READ
    RSHIFT
    RUE
    SIZEOF
    STATIC
    STR
    STRUCT
    SWITCH
    TIMESEQUAL
    TRY
    VECTOR
    VOID
    WITH
    WRITE
    XOR

Grammar

Rule 0     S' -> prog
Rule 1     prog -> empty
Rule 2     prog -> func prog
Rule 3     func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
Rule 4     func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
Rule 5     func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE
Rule 6     func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE
Rule 7     body -> empty
Rule 8     body -> stmt body
Rule 9     stmt -> expr SEMI
Rule 10    stmt -> defvar SEMI
Rule 11    stmt -> return_instr SEMI
Rule 12    stmt -> single_if
Rule 13    stmt -> if_with_else
Rule 14    stmt -> while_loop
Rule 15    stmt -> for_loop
Rule 16    stmt -> block
Rule 17    stmt -> func
Rule 18    stmt -> error SEMI
Rule 19    stmt -> error
Rule 20    single_if -> IF LPAREN expr RPAREN stmt
Rule 21    if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt
Rule 22    while_loop -> WHILE LPAREN expr RPAREN stmt
Rule 23    for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
Rule 24    block -> LBRACE body RBRACE
Rule 25    return_instr -> RETURN expr
Rule 26    defvar -> VAR TYPE ID
Rule 27    defvar -> VAR TYPE ID EQUALS expr
Rule 28    flist -> empty
Rule 29    flist -> TYPE ID
Rule 30    flist -> TYPE ID COMMA flist
Rule 31    flist -> error ID COMMA flist
Rule 32    flist -> TYPE error COMMA flist
Rule 33    flist -> TYPE ID COMMA error
Rule 34    clist -> empty
Rule 35    clist -> expr
Rule 36    clist -> expr COMMA clist
Rule 37    expr -> operation_on_list
Rule 38    expr -> expr_list
Rule 39    expr -> ternary_expr
Rule 40    expr -> LNOT expr
Rule 41    expr -> PLUS expr
Rule 42    expr -> MINUS expr
Rule 43    expr -> binary_expr
Rule 44    expr -> ID
Rule 45    expr -> assignment
Rule 46    expr -> function_call
Rule 47    expr -> NUMBER
Rule 48    expr -> STRING
Rule 49    expr_list -> LBRACKET clist RBRACKET
Rule 50    operation_on_list -> expr LBRACKET expr RBRACKET
Rule 51    operation_on_list -> ID LBRACKET expr RBRACKET
Rule 52    assignment -> ID EQUALS expr
Rule 53    assignment -> ID LBRACKET expr RBRACKET EQUALS expr
Rule 54    ternary_expr -> expr QUESTIONMARK expr COLON expr
Rule 55    function_call -> ID LPAREN clist RPAREN
Rule 56    function_call -> ID LPAREN error RPAREN
Rule 57    binary_expr -> expr PLUS expr
Rule 58    binary_expr -> expr MINUS expr
Rule 59    binary_expr -> expr TIMES expr
Rule 60    binary_expr -> expr DIVIDE expr
Rule 61    binary_expr -> expr MODULO expr
Rule 62    binary_expr -> expr GT expr
Rule 63    binary_expr -> expr LT expr
Rule 64    binary_expr -> expr EQ expr
Rule 65    binary_expr -> expr LE expr
Rule 66    binary_expr -> expr GE expr
Rule 67    binary_expr -> expr NE expr
Rule 68    binary_expr -> expr LOR expr
Rule 69    binary_expr -> expr LAND expr
Rule 70    empty -> <empty>

Terminals, with rules where they appear

ALSE                 : 
AND                  : 
AS                   : 
AUTO                 : 
BREAK                : 
CASE                 : 
CLASS                : 
CLOSE                : 
COLON                : 54
COMMA                : 30 31 32 33 36
CONST                : 
CONTINUE             : 
DECREMENT            : 
DEF                  : 3 4 5 6
DEFAULT              : 
DEL                  : 
DIVEQUAL             : 
DIVIDE               : 60
ELSE                 : 21
EQ                   : 64
EQUALS               : 23 27 52 53
EXCEPT               : 
FOR                  : 23
FROM                 : 
GE                   : 66
GLOBAL               : 
GT                   : 62
ID                   : 3 4 5 6 23 26 27 29 30 31 33 44 51 52 53 55 56
IF                   : 20 21
IMPORT               : 
IN                   : 
INCREMENT            : 
INPUT                : 
INT                  : 
IS                   : 
LAMBDA               : 
LAND                 : 69
LBRACE               : 3 5 6 24
LBRACKET             : 49 50 51 53
LE                   : 65
LEN                  : 
LNOT                 : 40
LOR                  : 68
LPAREN               : 3 4 5 6 20 21 22 23 55 56
LSHIFT               : 
LT                   : 63
MINUS                : 42 58
MINUSEQUAL           : 
MODEQUAL             : 
MODULO               : 61
NE                   : 67
NONLOCAL             : 
NOT                  : 
NULL                 : 
NUMBER               : 47
ONE                  : 
OPEN                 : 
OR                   : 
PASS                 : 
PERIOD               : 
PLUS                 : 41 57
PLUSEQUAL            : 
QUESTIONMARK         : 54
RAISE                : 
RANGE                : 
RBRACE               : 3 5 6 24
RBRACKET             : 49 50 51 53
READ                 : 
RETURN               : 4 25
RPAREN               : 3 4 5 6 20 21 22 23 55 56
RSHIFT               : 
RUE                  : 
SEMI                 : 4 9 10 11 18
SIZEOF               : 
STATIC               : 
STR                  : 
STRING               : 48
STRUCT               : 
SWITCH               : 
TIMES                : 59
TIMESEQUAL           : 
TO                   : 23
TRY                  : 
TYPE                 : 3 4 5 26 27 29 30 32 33
VAR                  : 26 27
VECTOR               : 
VOID                 : 
WHILE                : 22
WITH                 : 
WRITE                : 
XOR                  : 
error                : 5 6 18 19 31 32 33 56

Nonterminals, with rules where they appear

assignment           : 45
binary_expr          : 43
block                : 16
body                 : 3 5 6 8 24
clist                : 36 49 55
defvar               : 10
empty                : 1 7 28 34
expr                 : 4 9 20 21 22 23 23 25 27 35 36 40 41 42 50 50 51 52 53 53 54 54 54 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 64 65 65 66 66 67 67 68 68 69 69
expr_list            : 38
flist                : 3 4 6 30 31 32
for_loop             : 15
func                 : 2 17
function_call        : 46
if_with_else         : 13
operation_on_list    : 37
prog                 : 2 0
return_instr         : 11
single_if            : 12
stmt                 : 8 20 21 21 22 23
ternary_expr         : 39
while_loop           : 14

Parsing method: LALR

state 0

    (0) S' -> . prog
    (1) prog -> . empty
    (2) prog -> . func prog
    (70) empty -> .
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> . DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE
    (6) func -> . DEF error ID LPAREN flist RPAREN LBRACE body RBRACE

    $end            reduce using rule 70 (empty -> .)
    DEF             shift and go to state 4

    prog                           shift and go to state 1
    empty                          shift and go to state 2
    func                           shift and go to state 3

state 1

    (0) S' -> prog .



state 2

    (1) prog -> empty .

    $end            reduce using rule 1 (prog -> empty .)


state 3

    (2) prog -> func . prog
    (1) prog -> . empty
    (2) prog -> . func prog
    (70) empty -> .
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> . DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE
    (6) func -> . DEF error ID LPAREN flist RPAREN LBRACE body RBRACE

    $end            reduce using rule 70 (empty -> .)
    DEF             shift and go to state 4

    func                           shift and go to state 3
    prog                           shift and go to state 5
    empty                          shift and go to state 2

state 4

    (3) func -> DEF . TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> DEF . TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> DEF . TYPE ID LPAREN error RPAREN LBRACE body RBRACE
    (6) func -> DEF . error ID LPAREN flist RPAREN LBRACE body RBRACE

    TYPE            shift and go to state 6
    error           shift and go to state 7


state 5

    (2) prog -> func prog .

    $end            reduce using rule 2 (prog -> func prog .)


state 6

    (3) func -> DEF TYPE . ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> DEF TYPE . ID LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> DEF TYPE . ID LPAREN error RPAREN LBRACE body RBRACE

    ID              shift and go to state 8


state 7

    (6) func -> DEF error . ID LPAREN flist RPAREN LBRACE body RBRACE

    ID              shift and go to state 9


state 8

    (3) func -> DEF TYPE ID . LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> DEF TYPE ID . LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> DEF TYPE ID . LPAREN error RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 10


state 9

    (6) func -> DEF error ID . LPAREN flist RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 11


state 10

    (3) func -> DEF TYPE ID LPAREN . flist RPAREN LBRACE body RBRACE
    (4) func -> DEF TYPE ID LPAREN . flist RPAREN RETURN expr SEMI
    (5) func -> DEF TYPE ID LPAREN . error RPAREN LBRACE body RBRACE
    (28) flist -> . empty
    (29) flist -> . TYPE ID
    (30) flist -> . TYPE ID COMMA flist
    (31) flist -> . error ID COMMA flist
    (32) flist -> . TYPE error COMMA flist
    (33) flist -> . TYPE ID COMMA error
    (70) empty -> .

    error           shift and go to state 14
    TYPE            shift and go to state 12
    RPAREN          reduce using rule 70 (empty -> .)

    flist                          shift and go to state 13
    empty                          shift and go to state 15

state 11

    (6) func -> DEF error ID LPAREN . flist RPAREN LBRACE body RBRACE
    (28) flist -> . empty
    (29) flist -> . TYPE ID
    (30) flist -> . TYPE ID COMMA flist
    (31) flist -> . error ID COMMA flist
    (32) flist -> . TYPE error COMMA flist
    (33) flist -> . TYPE ID COMMA error
    (70) empty -> .

    TYPE            shift and go to state 12
    error           shift and go to state 16
    RPAREN          reduce using rule 70 (empty -> .)

    flist                          shift and go to state 17
    empty                          shift and go to state 15

state 12

    (29) flist -> TYPE . ID
    (30) flist -> TYPE . ID COMMA flist
    (32) flist -> TYPE . error COMMA flist
    (33) flist -> TYPE . ID COMMA error

    ID              shift and go to state 18
    error           shift and go to state 19


state 13

    (3) func -> DEF TYPE ID LPAREN flist . RPAREN LBRACE body RBRACE
    (4) func -> DEF TYPE ID LPAREN flist . RPAREN RETURN expr SEMI

    RPAREN          shift and go to state 20


state 14

    (5) func -> DEF TYPE ID LPAREN error . RPAREN LBRACE body RBRACE
    (31) flist -> error . ID COMMA flist

    RPAREN          shift and go to state 22
    ID              shift and go to state 21


state 15

    (28) flist -> empty .

    RPAREN          reduce using rule 28 (flist -> empty .)


state 16

    (31) flist -> error . ID COMMA flist

    ID              shift and go to state 21


state 17

    (6) func -> DEF error ID LPAREN flist . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 23


state 18

    (29) flist -> TYPE ID .
    (30) flist -> TYPE ID . COMMA flist
    (33) flist -> TYPE ID . COMMA error

    RPAREN          reduce using rule 29 (flist -> TYPE ID .)
    COMMA           shift and go to state 24


state 19

    (32) flist -> TYPE error . COMMA flist

    COMMA           shift and go to state 25


state 20

    (3) func -> DEF TYPE ID LPAREN flist RPAREN . LBRACE body RBRACE
    (4) func -> DEF TYPE ID LPAREN flist RPAREN . RETURN expr SEMI

    LBRACE          shift and go to state 26
    RETURN          shift and go to state 27


state 21

    (31) flist -> error ID . COMMA flist

    COMMA           shift and go to state 28


state 22

    (5) func -> DEF TYPE ID LPAREN error RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 29


state 23

    (6) func -> DEF error ID LPAREN flist RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 30


state 24

    (30) flist -> TYPE ID COMMA . flist
    (33) flist -> TYPE ID COMMA . error
    (28) flist -> . empty
    (29) flist -> . TYPE ID
    (30) flist -> . TYPE ID COMMA flist
    (31) flist -> . error ID COMMA flist
    (32) flist -> . TYPE error COMMA flist
    (33) flist -> . TYPE ID COMMA error
    (70) empty -> .

    error           shift and go to state 32
    TYPE            shift and go to state 12
    RPAREN          reduce using rule 70 (empty -> .)

    flist                          shift and go to state 31
    empty                          shift and go to state 15

state 25

    (32) flist -> TYPE error COMMA . flist
    (28) flist -> . empty
    (29) flist -> . TYPE ID
    (30) flist -> . TYPE ID COMMA flist
    (31) flist -> . error ID COMMA flist
    (32) flist -> . TYPE error COMMA flist
    (33) flist -> . TYPE ID COMMA error
    (70) empty -> .

    TYPE            shift and go to state 12
    error           shift and go to state 16
    RPAREN          reduce using rule 70 (empty -> .)

    flist                          shift and go to state 33
    empty                          shift and go to state 15

state 26

    (3) func -> DEF TYPE ID LPAREN flist RPAREN LBRACE . body RBRACE
    (7) body -> . empty
    (8) body -> . stmt body
    (70) empty -> .
    (9) stmt -> . expr SEMI
    (10) stmt -> . defvar SEMI
    (11) stmt -> . return_instr SEMI
    (12) stmt -> . single_if
    (13) stmt -> . if_with_else
    (14) stmt -> . while_loop
    (15) stmt -> . for_loop
    (16) stmt -> . block
    (17) stmt -> . func
    (18) stmt -> . error SEMI
    (19) stmt -> . error
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (26) defvar -> . VAR TYPE ID
    (27) defvar -> . VAR TYPE ID EQUALS expr
    (25) return_instr -> . RETURN expr
    (20) single_if -> . IF LPAREN expr RPAREN stmt
    (21) if_with_else -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (22) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (23) for_loop -> . FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
    (24) block -> . LBRACE body RBRACE
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> . DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE
    (6) func -> . DEF error ID LPAREN flist RPAREN LBRACE body RBRACE
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    RBRACE          reduce using rule 70 (empty -> .)
    error           shift and go to state 48
    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    VAR             shift and go to state 60
    RETURN          shift and go to state 61
    IF              shift and go to state 62
    WHILE           shift and go to state 63
    FOR             shift and go to state 64
    LBRACE          shift and go to state 35
    DEF             shift and go to state 4
    LBRACKET        shift and go to state 65

    body                           shift and go to state 36
    empty                          shift and go to state 37
    stmt                           shift and go to state 38
    expr                           shift and go to state 39
    defvar                         shift and go to state 40
    return_instr                   shift and go to state 41
    single_if                      shift and go to state 42
    if_with_else                   shift and go to state 43
    while_loop                     shift and go to state 44
    for_loop                       shift and go to state 45
    block                          shift and go to state 46
    func                           shift and go to state 47
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 27

    (4) func -> DEF TYPE ID LPAREN flist RPAREN RETURN . expr SEMI
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 66
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 28

    (31) flist -> error ID COMMA . flist
    (28) flist -> . empty
    (29) flist -> . TYPE ID
    (30) flist -> . TYPE ID COMMA flist
    (31) flist -> . error ID COMMA flist
    (32) flist -> . TYPE error COMMA flist
    (33) flist -> . TYPE ID COMMA error
    (70) empty -> .

    TYPE            shift and go to state 12
    error           shift and go to state 16
    RPAREN          reduce using rule 70 (empty -> .)

    flist                          shift and go to state 67
    empty                          shift and go to state 15

state 29

    (5) func -> DEF TYPE ID LPAREN error RPAREN LBRACE . body RBRACE
    (7) body -> . empty
    (8) body -> . stmt body
    (70) empty -> .
    (9) stmt -> . expr SEMI
    (10) stmt -> . defvar SEMI
    (11) stmt -> . return_instr SEMI
    (12) stmt -> . single_if
    (13) stmt -> . if_with_else
    (14) stmt -> . while_loop
    (15) stmt -> . for_loop
    (16) stmt -> . block
    (17) stmt -> . func
    (18) stmt -> . error SEMI
    (19) stmt -> . error
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (26) defvar -> . VAR TYPE ID
    (27) defvar -> . VAR TYPE ID EQUALS expr
    (25) return_instr -> . RETURN expr
    (20) single_if -> . IF LPAREN expr RPAREN stmt
    (21) if_with_else -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (22) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (23) for_loop -> . FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
    (24) block -> . LBRACE body RBRACE
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> . DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE
    (6) func -> . DEF error ID LPAREN flist RPAREN LBRACE body RBRACE
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    RBRACE          reduce using rule 70 (empty -> .)
    error           shift and go to state 48
    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    VAR             shift and go to state 60
    RETURN          shift and go to state 61
    IF              shift and go to state 62
    WHILE           shift and go to state 63
    FOR             shift and go to state 64
    LBRACE          shift and go to state 35
    DEF             shift and go to state 4
    LBRACKET        shift and go to state 65

    body                           shift and go to state 68
    empty                          shift and go to state 37
    stmt                           shift and go to state 38
    expr                           shift and go to state 39
    defvar                         shift and go to state 40
    return_instr                   shift and go to state 41
    single_if                      shift and go to state 42
    if_with_else                   shift and go to state 43
    while_loop                     shift and go to state 44
    for_loop                       shift and go to state 45
    block                          shift and go to state 46
    func                           shift and go to state 47
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 30

    (6) func -> DEF error ID LPAREN flist RPAREN LBRACE . body RBRACE
    (7) body -> . empty
    (8) body -> . stmt body
    (70) empty -> .
    (9) stmt -> . expr SEMI
    (10) stmt -> . defvar SEMI
    (11) stmt -> . return_instr SEMI
    (12) stmt -> . single_if
    (13) stmt -> . if_with_else
    (14) stmt -> . while_loop
    (15) stmt -> . for_loop
    (16) stmt -> . block
    (17) stmt -> . func
    (18) stmt -> . error SEMI
    (19) stmt -> . error
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (26) defvar -> . VAR TYPE ID
    (27) defvar -> . VAR TYPE ID EQUALS expr
    (25) return_instr -> . RETURN expr
    (20) single_if -> . IF LPAREN expr RPAREN stmt
    (21) if_with_else -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (22) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (23) for_loop -> . FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
    (24) block -> . LBRACE body RBRACE
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> . DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE
    (6) func -> . DEF error ID LPAREN flist RPAREN LBRACE body RBRACE
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    RBRACE          reduce using rule 70 (empty -> .)
    error           shift and go to state 48
    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    VAR             shift and go to state 60
    RETURN          shift and go to state 61
    IF              shift and go to state 62
    WHILE           shift and go to state 63
    FOR             shift and go to state 64
    LBRACE          shift and go to state 35
    DEF             shift and go to state 4
    LBRACKET        shift and go to state 65

    body                           shift and go to state 69
    empty                          shift and go to state 37
    stmt                           shift and go to state 38
    expr                           shift and go to state 39
    defvar                         shift and go to state 40
    return_instr                   shift and go to state 41
    single_if                      shift and go to state 42
    if_with_else                   shift and go to state 43
    while_loop                     shift and go to state 44
    for_loop                       shift and go to state 45
    block                          shift and go to state 46
    func                           shift and go to state 47
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 31

    (30) flist -> TYPE ID COMMA flist .

    RPAREN          reduce using rule 30 (flist -> TYPE ID COMMA flist .)


state 32

    (33) flist -> TYPE ID COMMA error .
    (31) flist -> error . ID COMMA flist

    RPAREN          reduce using rule 33 (flist -> TYPE ID COMMA error .)
    ID              shift and go to state 21


state 33

    (32) flist -> TYPE error COMMA flist .

    RPAREN          reduce using rule 32 (flist -> TYPE error COMMA flist .)


state 34

    (44) expr -> ID .
    (51) operation_on_list -> ID . LBRACKET expr RBRACKET
    (52) assignment -> ID . EQUALS expr
    (53) assignment -> ID . LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> ID . LPAREN clist RPAREN
    (56) function_call -> ID . LPAREN error RPAREN

  ! shift/reduce conflict for LBRACKET resolved as shift
    SEMI            reduce using rule 44 (expr -> ID .)
    QUESTIONMARK    reduce using rule 44 (expr -> ID .)
    PLUS            reduce using rule 44 (expr -> ID .)
    MINUS           reduce using rule 44 (expr -> ID .)
    TIMES           reduce using rule 44 (expr -> ID .)
    DIVIDE          reduce using rule 44 (expr -> ID .)
    MODULO          reduce using rule 44 (expr -> ID .)
    GT              reduce using rule 44 (expr -> ID .)
    LT              reduce using rule 44 (expr -> ID .)
    EQ              reduce using rule 44 (expr -> ID .)
    LE              reduce using rule 44 (expr -> ID .)
    GE              reduce using rule 44 (expr -> ID .)
    NE              reduce using rule 44 (expr -> ID .)
    LOR             reduce using rule 44 (expr -> ID .)
    LAND            reduce using rule 44 (expr -> ID .)
    COMMA           reduce using rule 44 (expr -> ID .)
    RBRACKET        reduce using rule 44 (expr -> ID .)
    RPAREN          reduce using rule 44 (expr -> ID .)
    COLON           reduce using rule 44 (expr -> ID .)
    TO              reduce using rule 44 (expr -> ID .)
    LBRACKET        shift and go to state 70
    EQUALS          shift and go to state 71
    LPAREN          shift and go to state 72

  ! LBRACKET        [ reduce using rule 44 (expr -> ID .) ]


state 35

    (24) block -> LBRACE . body RBRACE
    (7) body -> . empty
    (8) body -> . stmt body
    (70) empty -> .
    (9) stmt -> . expr SEMI
    (10) stmt -> . defvar SEMI
    (11) stmt -> . return_instr SEMI
    (12) stmt -> . single_if
    (13) stmt -> . if_with_else
    (14) stmt -> . while_loop
    (15) stmt -> . for_loop
    (16) stmt -> . block
    (17) stmt -> . func
    (18) stmt -> . error SEMI
    (19) stmt -> . error
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (26) defvar -> . VAR TYPE ID
    (27) defvar -> . VAR TYPE ID EQUALS expr
    (25) return_instr -> . RETURN expr
    (20) single_if -> . IF LPAREN expr RPAREN stmt
    (21) if_with_else -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (22) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (23) for_loop -> . FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
    (24) block -> . LBRACE body RBRACE
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> . DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE
    (6) func -> . DEF error ID LPAREN flist RPAREN LBRACE body RBRACE
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    RBRACE          reduce using rule 70 (empty -> .)
    error           shift and go to state 48
    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    VAR             shift and go to state 60
    RETURN          shift and go to state 61
    IF              shift and go to state 62
    WHILE           shift and go to state 63
    FOR             shift and go to state 64
    LBRACE          shift and go to state 35
    DEF             shift and go to state 4
    LBRACKET        shift and go to state 65

    body                           shift and go to state 73
    empty                          shift and go to state 37
    stmt                           shift and go to state 38
    expr                           shift and go to state 39
    defvar                         shift and go to state 40
    return_instr                   shift and go to state 41
    single_if                      shift and go to state 42
    if_with_else                   shift and go to state 43
    while_loop                     shift and go to state 44
    for_loop                       shift and go to state 45
    block                          shift and go to state 46
    func                           shift and go to state 47
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 36

    (3) func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 74


state 37

    (7) body -> empty .

    RBRACE          reduce using rule 7 (body -> empty .)


state 38

    (8) body -> stmt . body
    (7) body -> . empty
    (8) body -> . stmt body
    (70) empty -> .
    (9) stmt -> . expr SEMI
    (10) stmt -> . defvar SEMI
    (11) stmt -> . return_instr SEMI
    (12) stmt -> . single_if
    (13) stmt -> . if_with_else
    (14) stmt -> . while_loop
    (15) stmt -> . for_loop
    (16) stmt -> . block
    (17) stmt -> . func
    (18) stmt -> . error SEMI
    (19) stmt -> . error
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (26) defvar -> . VAR TYPE ID
    (27) defvar -> . VAR TYPE ID EQUALS expr
    (25) return_instr -> . RETURN expr
    (20) single_if -> . IF LPAREN expr RPAREN stmt
    (21) if_with_else -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (22) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (23) for_loop -> . FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
    (24) block -> . LBRACE body RBRACE
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> . DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE
    (6) func -> . DEF error ID LPAREN flist RPAREN LBRACE body RBRACE
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    RBRACE          reduce using rule 70 (empty -> .)
    error           shift and go to state 48
    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    VAR             shift and go to state 60
    RETURN          shift and go to state 61
    IF              shift and go to state 62
    WHILE           shift and go to state 63
    FOR             shift and go to state 64
    LBRACE          shift and go to state 35
    DEF             shift and go to state 4
    LBRACKET        shift and go to state 65

    stmt                           shift and go to state 38
    body                           shift and go to state 75
    empty                          shift and go to state 37
    expr                           shift and go to state 39
    defvar                         shift and go to state 40
    return_instr                   shift and go to state 41
    single_if                      shift and go to state 42
    if_with_else                   shift and go to state 43
    while_loop                     shift and go to state 44
    for_loop                       shift and go to state 45
    block                          shift and go to state 46
    func                           shift and go to state 47
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 39

    (9) stmt -> expr . SEMI
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    SEMI            shift and go to state 76
    LBRACKET        shift and go to state 77
    QUESTIONMARK    shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MODULO          shift and go to state 83
    GT              shift and go to state 84
    LT              shift and go to state 85
    EQ              shift and go to state 86
    LE              shift and go to state 87
    GE              shift and go to state 88
    NE              shift and go to state 89
    LOR             shift and go to state 90
    LAND            shift and go to state 91


state 40

    (10) stmt -> defvar . SEMI

    SEMI            shift and go to state 92


state 41

    (11) stmt -> return_instr . SEMI

    SEMI            shift and go to state 93


state 42

    (12) stmt -> single_if .

    error           reduce using rule 12 (stmt -> single_if .)
    LNOT            reduce using rule 12 (stmt -> single_if .)
    PLUS            reduce using rule 12 (stmt -> single_if .)
    MINUS           reduce using rule 12 (stmt -> single_if .)
    ID              reduce using rule 12 (stmt -> single_if .)
    NUMBER          reduce using rule 12 (stmt -> single_if .)
    STRING          reduce using rule 12 (stmt -> single_if .)
    VAR             reduce using rule 12 (stmt -> single_if .)
    RETURN          reduce using rule 12 (stmt -> single_if .)
    IF              reduce using rule 12 (stmt -> single_if .)
    WHILE           reduce using rule 12 (stmt -> single_if .)
    FOR             reduce using rule 12 (stmt -> single_if .)
    LBRACE          reduce using rule 12 (stmt -> single_if .)
    DEF             reduce using rule 12 (stmt -> single_if .)
    LBRACKET        reduce using rule 12 (stmt -> single_if .)
    RBRACE          reduce using rule 12 (stmt -> single_if .)
    ELSE            reduce using rule 12 (stmt -> single_if .)


state 43

    (13) stmt -> if_with_else .

    error           reduce using rule 13 (stmt -> if_with_else .)
    LNOT            reduce using rule 13 (stmt -> if_with_else .)
    PLUS            reduce using rule 13 (stmt -> if_with_else .)
    MINUS           reduce using rule 13 (stmt -> if_with_else .)
    ID              reduce using rule 13 (stmt -> if_with_else .)
    NUMBER          reduce using rule 13 (stmt -> if_with_else .)
    STRING          reduce using rule 13 (stmt -> if_with_else .)
    VAR             reduce using rule 13 (stmt -> if_with_else .)
    RETURN          reduce using rule 13 (stmt -> if_with_else .)
    IF              reduce using rule 13 (stmt -> if_with_else .)
    WHILE           reduce using rule 13 (stmt -> if_with_else .)
    FOR             reduce using rule 13 (stmt -> if_with_else .)
    LBRACE          reduce using rule 13 (stmt -> if_with_else .)
    DEF             reduce using rule 13 (stmt -> if_with_else .)
    LBRACKET        reduce using rule 13 (stmt -> if_with_else .)
    RBRACE          reduce using rule 13 (stmt -> if_with_else .)
    ELSE            reduce using rule 13 (stmt -> if_with_else .)


state 44

    (14) stmt -> while_loop .

    error           reduce using rule 14 (stmt -> while_loop .)
    LNOT            reduce using rule 14 (stmt -> while_loop .)
    PLUS            reduce using rule 14 (stmt -> while_loop .)
    MINUS           reduce using rule 14 (stmt -> while_loop .)
    ID              reduce using rule 14 (stmt -> while_loop .)
    NUMBER          reduce using rule 14 (stmt -> while_loop .)
    STRING          reduce using rule 14 (stmt -> while_loop .)
    VAR             reduce using rule 14 (stmt -> while_loop .)
    RETURN          reduce using rule 14 (stmt -> while_loop .)
    IF              reduce using rule 14 (stmt -> while_loop .)
    WHILE           reduce using rule 14 (stmt -> while_loop .)
    FOR             reduce using rule 14 (stmt -> while_loop .)
    LBRACE          reduce using rule 14 (stmt -> while_loop .)
    DEF             reduce using rule 14 (stmt -> while_loop .)
    LBRACKET        reduce using rule 14 (stmt -> while_loop .)
    RBRACE          reduce using rule 14 (stmt -> while_loop .)
    ELSE            reduce using rule 14 (stmt -> while_loop .)


state 45

    (15) stmt -> for_loop .

    error           reduce using rule 15 (stmt -> for_loop .)
    LNOT            reduce using rule 15 (stmt -> for_loop .)
    PLUS            reduce using rule 15 (stmt -> for_loop .)
    MINUS           reduce using rule 15 (stmt -> for_loop .)
    ID              reduce using rule 15 (stmt -> for_loop .)
    NUMBER          reduce using rule 15 (stmt -> for_loop .)
    STRING          reduce using rule 15 (stmt -> for_loop .)
    VAR             reduce using rule 15 (stmt -> for_loop .)
    RETURN          reduce using rule 15 (stmt -> for_loop .)
    IF              reduce using rule 15 (stmt -> for_loop .)
    WHILE           reduce using rule 15 (stmt -> for_loop .)
    FOR             reduce using rule 15 (stmt -> for_loop .)
    LBRACE          reduce using rule 15 (stmt -> for_loop .)
    DEF             reduce using rule 15 (stmt -> for_loop .)
    LBRACKET        reduce using rule 15 (stmt -> for_loop .)
    RBRACE          reduce using rule 15 (stmt -> for_loop .)
    ELSE            reduce using rule 15 (stmt -> for_loop .)


state 46

    (16) stmt -> block .

    error           reduce using rule 16 (stmt -> block .)
    LNOT            reduce using rule 16 (stmt -> block .)
    PLUS            reduce using rule 16 (stmt -> block .)
    MINUS           reduce using rule 16 (stmt -> block .)
    ID              reduce using rule 16 (stmt -> block .)
    NUMBER          reduce using rule 16 (stmt -> block .)
    STRING          reduce using rule 16 (stmt -> block .)
    VAR             reduce using rule 16 (stmt -> block .)
    RETURN          reduce using rule 16 (stmt -> block .)
    IF              reduce using rule 16 (stmt -> block .)
    WHILE           reduce using rule 16 (stmt -> block .)
    FOR             reduce using rule 16 (stmt -> block .)
    LBRACE          reduce using rule 16 (stmt -> block .)
    DEF             reduce using rule 16 (stmt -> block .)
    LBRACKET        reduce using rule 16 (stmt -> block .)
    RBRACE          reduce using rule 16 (stmt -> block .)
    ELSE            reduce using rule 16 (stmt -> block .)


state 47

    (17) stmt -> func .

    error           reduce using rule 17 (stmt -> func .)
    LNOT            reduce using rule 17 (stmt -> func .)
    PLUS            reduce using rule 17 (stmt -> func .)
    MINUS           reduce using rule 17 (stmt -> func .)
    ID              reduce using rule 17 (stmt -> func .)
    NUMBER          reduce using rule 17 (stmt -> func .)
    STRING          reduce using rule 17 (stmt -> func .)
    VAR             reduce using rule 17 (stmt -> func .)
    RETURN          reduce using rule 17 (stmt -> func .)
    IF              reduce using rule 17 (stmt -> func .)
    WHILE           reduce using rule 17 (stmt -> func .)
    FOR             reduce using rule 17 (stmt -> func .)
    LBRACE          reduce using rule 17 (stmt -> func .)
    DEF             reduce using rule 17 (stmt -> func .)
    LBRACKET        reduce using rule 17 (stmt -> func .)
    RBRACE          reduce using rule 17 (stmt -> func .)
    ELSE            reduce using rule 17 (stmt -> func .)


state 48

    (18) stmt -> error . SEMI
    (19) stmt -> error .

    SEMI            shift and go to state 94
    error           reduce using rule 19 (stmt -> error .)
    LNOT            reduce using rule 19 (stmt -> error .)
    PLUS            reduce using rule 19 (stmt -> error .)
    MINUS           reduce using rule 19 (stmt -> error .)
    ID              reduce using rule 19 (stmt -> error .)
    NUMBER          reduce using rule 19 (stmt -> error .)
    STRING          reduce using rule 19 (stmt -> error .)
    VAR             reduce using rule 19 (stmt -> error .)
    RETURN          reduce using rule 19 (stmt -> error .)
    IF              reduce using rule 19 (stmt -> error .)
    WHILE           reduce using rule 19 (stmt -> error .)
    FOR             reduce using rule 19 (stmt -> error .)
    LBRACE          reduce using rule 19 (stmt -> error .)
    DEF             reduce using rule 19 (stmt -> error .)
    LBRACKET        reduce using rule 19 (stmt -> error .)
    RBRACE          reduce using rule 19 (stmt -> error .)
    ELSE            reduce using rule 19 (stmt -> error .)


state 49

    (37) expr -> operation_on_list .

    SEMI            reduce using rule 37 (expr -> operation_on_list .)
    LBRACKET        reduce using rule 37 (expr -> operation_on_list .)
    QUESTIONMARK    reduce using rule 37 (expr -> operation_on_list .)
    PLUS            reduce using rule 37 (expr -> operation_on_list .)
    MINUS           reduce using rule 37 (expr -> operation_on_list .)
    TIMES           reduce using rule 37 (expr -> operation_on_list .)
    DIVIDE          reduce using rule 37 (expr -> operation_on_list .)
    MODULO          reduce using rule 37 (expr -> operation_on_list .)
    GT              reduce using rule 37 (expr -> operation_on_list .)
    LT              reduce using rule 37 (expr -> operation_on_list .)
    EQ              reduce using rule 37 (expr -> operation_on_list .)
    LE              reduce using rule 37 (expr -> operation_on_list .)
    GE              reduce using rule 37 (expr -> operation_on_list .)
    NE              reduce using rule 37 (expr -> operation_on_list .)
    LOR             reduce using rule 37 (expr -> operation_on_list .)
    LAND            reduce using rule 37 (expr -> operation_on_list .)
    COMMA           reduce using rule 37 (expr -> operation_on_list .)
    RBRACKET        reduce using rule 37 (expr -> operation_on_list .)
    RPAREN          reduce using rule 37 (expr -> operation_on_list .)
    COLON           reduce using rule 37 (expr -> operation_on_list .)
    TO              reduce using rule 37 (expr -> operation_on_list .)


state 50

    (38) expr -> expr_list .

    SEMI            reduce using rule 38 (expr -> expr_list .)
    LBRACKET        reduce using rule 38 (expr -> expr_list .)
    QUESTIONMARK    reduce using rule 38 (expr -> expr_list .)
    PLUS            reduce using rule 38 (expr -> expr_list .)
    MINUS           reduce using rule 38 (expr -> expr_list .)
    TIMES           reduce using rule 38 (expr -> expr_list .)
    DIVIDE          reduce using rule 38 (expr -> expr_list .)
    MODULO          reduce using rule 38 (expr -> expr_list .)
    GT              reduce using rule 38 (expr -> expr_list .)
    LT              reduce using rule 38 (expr -> expr_list .)
    EQ              reduce using rule 38 (expr -> expr_list .)
    LE              reduce using rule 38 (expr -> expr_list .)
    GE              reduce using rule 38 (expr -> expr_list .)
    NE              reduce using rule 38 (expr -> expr_list .)
    LOR             reduce using rule 38 (expr -> expr_list .)
    LAND            reduce using rule 38 (expr -> expr_list .)
    COMMA           reduce using rule 38 (expr -> expr_list .)
    RBRACKET        reduce using rule 38 (expr -> expr_list .)
    RPAREN          reduce using rule 38 (expr -> expr_list .)
    COLON           reduce using rule 38 (expr -> expr_list .)
    TO              reduce using rule 38 (expr -> expr_list .)


state 51

    (39) expr -> ternary_expr .

    SEMI            reduce using rule 39 (expr -> ternary_expr .)
    LBRACKET        reduce using rule 39 (expr -> ternary_expr .)
    QUESTIONMARK    reduce using rule 39 (expr -> ternary_expr .)
    PLUS            reduce using rule 39 (expr -> ternary_expr .)
    MINUS           reduce using rule 39 (expr -> ternary_expr .)
    TIMES           reduce using rule 39 (expr -> ternary_expr .)
    DIVIDE          reduce using rule 39 (expr -> ternary_expr .)
    MODULO          reduce using rule 39 (expr -> ternary_expr .)
    GT              reduce using rule 39 (expr -> ternary_expr .)
    LT              reduce using rule 39 (expr -> ternary_expr .)
    EQ              reduce using rule 39 (expr -> ternary_expr .)
    LE              reduce using rule 39 (expr -> ternary_expr .)
    GE              reduce using rule 39 (expr -> ternary_expr .)
    NE              reduce using rule 39 (expr -> ternary_expr .)
    LOR             reduce using rule 39 (expr -> ternary_expr .)
    LAND            reduce using rule 39 (expr -> ternary_expr .)
    COMMA           reduce using rule 39 (expr -> ternary_expr .)
    RBRACKET        reduce using rule 39 (expr -> ternary_expr .)
    RPAREN          reduce using rule 39 (expr -> ternary_expr .)
    COLON           reduce using rule 39 (expr -> ternary_expr .)
    TO              reduce using rule 39 (expr -> ternary_expr .)


state 52

    (40) expr -> LNOT . expr
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 95
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 53

    (41) expr -> PLUS . expr
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 96
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 54

    (42) expr -> MINUS . expr
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 97
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 55

    (43) expr -> binary_expr .

    SEMI            reduce using rule 43 (expr -> binary_expr .)
    LBRACKET        reduce using rule 43 (expr -> binary_expr .)
    QUESTIONMARK    reduce using rule 43 (expr -> binary_expr .)
    PLUS            reduce using rule 43 (expr -> binary_expr .)
    MINUS           reduce using rule 43 (expr -> binary_expr .)
    TIMES           reduce using rule 43 (expr -> binary_expr .)
    DIVIDE          reduce using rule 43 (expr -> binary_expr .)
    MODULO          reduce using rule 43 (expr -> binary_expr .)
    GT              reduce using rule 43 (expr -> binary_expr .)
    LT              reduce using rule 43 (expr -> binary_expr .)
    EQ              reduce using rule 43 (expr -> binary_expr .)
    LE              reduce using rule 43 (expr -> binary_expr .)
    GE              reduce using rule 43 (expr -> binary_expr .)
    NE              reduce using rule 43 (expr -> binary_expr .)
    LOR             reduce using rule 43 (expr -> binary_expr .)
    LAND            reduce using rule 43 (expr -> binary_expr .)
    COMMA           reduce using rule 43 (expr -> binary_expr .)
    RBRACKET        reduce using rule 43 (expr -> binary_expr .)
    RPAREN          reduce using rule 43 (expr -> binary_expr .)
    COLON           reduce using rule 43 (expr -> binary_expr .)
    TO              reduce using rule 43 (expr -> binary_expr .)


state 56

    (45) expr -> assignment .

    SEMI            reduce using rule 45 (expr -> assignment .)
    LBRACKET        reduce using rule 45 (expr -> assignment .)
    QUESTIONMARK    reduce using rule 45 (expr -> assignment .)
    PLUS            reduce using rule 45 (expr -> assignment .)
    MINUS           reduce using rule 45 (expr -> assignment .)
    TIMES           reduce using rule 45 (expr -> assignment .)
    DIVIDE          reduce using rule 45 (expr -> assignment .)
    MODULO          reduce using rule 45 (expr -> assignment .)
    GT              reduce using rule 45 (expr -> assignment .)
    LT              reduce using rule 45 (expr -> assignment .)
    EQ              reduce using rule 45 (expr -> assignment .)
    LE              reduce using rule 45 (expr -> assignment .)
    GE              reduce using rule 45 (expr -> assignment .)
    NE              reduce using rule 45 (expr -> assignment .)
    LOR             reduce using rule 45 (expr -> assignment .)
    LAND            reduce using rule 45 (expr -> assignment .)
    COMMA           reduce using rule 45 (expr -> assignment .)
    RBRACKET        reduce using rule 45 (expr -> assignment .)
    RPAREN          reduce using rule 45 (expr -> assignment .)
    COLON           reduce using rule 45 (expr -> assignment .)
    TO              reduce using rule 45 (expr -> assignment .)


state 57

    (46) expr -> function_call .

    SEMI            reduce using rule 46 (expr -> function_call .)
    LBRACKET        reduce using rule 46 (expr -> function_call .)
    QUESTIONMARK    reduce using rule 46 (expr -> function_call .)
    PLUS            reduce using rule 46 (expr -> function_call .)
    MINUS           reduce using rule 46 (expr -> function_call .)
    TIMES           reduce using rule 46 (expr -> function_call .)
    DIVIDE          reduce using rule 46 (expr -> function_call .)
    MODULO          reduce using rule 46 (expr -> function_call .)
    GT              reduce using rule 46 (expr -> function_call .)
    LT              reduce using rule 46 (expr -> function_call .)
    EQ              reduce using rule 46 (expr -> function_call .)
    LE              reduce using rule 46 (expr -> function_call .)
    GE              reduce using rule 46 (expr -> function_call .)
    NE              reduce using rule 46 (expr -> function_call .)
    LOR             reduce using rule 46 (expr -> function_call .)
    LAND            reduce using rule 46 (expr -> function_call .)
    COMMA           reduce using rule 46 (expr -> function_call .)
    RBRACKET        reduce using rule 46 (expr -> function_call .)
    RPAREN          reduce using rule 46 (expr -> function_call .)
    COLON           reduce using rule 46 (expr -> function_call .)
    TO              reduce using rule 46 (expr -> function_call .)


state 58

    (47) expr -> NUMBER .

    SEMI            reduce using rule 47 (expr -> NUMBER .)
    LBRACKET        reduce using rule 47 (expr -> NUMBER .)
    QUESTIONMARK    reduce using rule 47 (expr -> NUMBER .)
    PLUS            reduce using rule 47 (expr -> NUMBER .)
    MINUS           reduce using rule 47 (expr -> NUMBER .)
    TIMES           reduce using rule 47 (expr -> NUMBER .)
    DIVIDE          reduce using rule 47 (expr -> NUMBER .)
    MODULO          reduce using rule 47 (expr -> NUMBER .)
    GT              reduce using rule 47 (expr -> NUMBER .)
    LT              reduce using rule 47 (expr -> NUMBER .)
    EQ              reduce using rule 47 (expr -> NUMBER .)
    LE              reduce using rule 47 (expr -> NUMBER .)
    GE              reduce using rule 47 (expr -> NUMBER .)
    NE              reduce using rule 47 (expr -> NUMBER .)
    LOR             reduce using rule 47 (expr -> NUMBER .)
    LAND            reduce using rule 47 (expr -> NUMBER .)
    COMMA           reduce using rule 47 (expr -> NUMBER .)
    RBRACKET        reduce using rule 47 (expr -> NUMBER .)
    RPAREN          reduce using rule 47 (expr -> NUMBER .)
    COLON           reduce using rule 47 (expr -> NUMBER .)
    TO              reduce using rule 47 (expr -> NUMBER .)


state 59

    (48) expr -> STRING .

    SEMI            reduce using rule 48 (expr -> STRING .)
    LBRACKET        reduce using rule 48 (expr -> STRING .)
    QUESTIONMARK    reduce using rule 48 (expr -> STRING .)
    PLUS            reduce using rule 48 (expr -> STRING .)
    MINUS           reduce using rule 48 (expr -> STRING .)
    TIMES           reduce using rule 48 (expr -> STRING .)
    DIVIDE          reduce using rule 48 (expr -> STRING .)
    MODULO          reduce using rule 48 (expr -> STRING .)
    GT              reduce using rule 48 (expr -> STRING .)
    LT              reduce using rule 48 (expr -> STRING .)
    EQ              reduce using rule 48 (expr -> STRING .)
    LE              reduce using rule 48 (expr -> STRING .)
    GE              reduce using rule 48 (expr -> STRING .)
    NE              reduce using rule 48 (expr -> STRING .)
    LOR             reduce using rule 48 (expr -> STRING .)
    LAND            reduce using rule 48 (expr -> STRING .)
    COMMA           reduce using rule 48 (expr -> STRING .)
    RBRACKET        reduce using rule 48 (expr -> STRING .)
    RPAREN          reduce using rule 48 (expr -> STRING .)
    COLON           reduce using rule 48 (expr -> STRING .)
    TO              reduce using rule 48 (expr -> STRING .)


state 60

    (26) defvar -> VAR . TYPE ID
    (27) defvar -> VAR . TYPE ID EQUALS expr

    TYPE            shift and go to state 98


state 61

    (25) return_instr -> RETURN . expr
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 99
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 62

    (20) single_if -> IF . LPAREN expr RPAREN stmt
    (21) if_with_else -> IF . LPAREN expr RPAREN stmt ELSE stmt

    LPAREN          shift and go to state 100


state 63

    (22) while_loop -> WHILE . LPAREN expr RPAREN stmt

    LPAREN          shift and go to state 101


state 64

    (23) for_loop -> FOR . LPAREN ID EQUALS expr TO expr RPAREN stmt

    LPAREN          shift and go to state 102


state 65

    (49) expr_list -> LBRACKET . clist RBRACKET
    (34) clist -> . empty
    (35) clist -> . expr
    (36) clist -> . expr COMMA clist
    (70) empty -> .
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    RBRACKET        reduce using rule 70 (empty -> .)
    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    clist                          shift and go to state 103
    empty                          shift and go to state 104
    expr                           shift and go to state 105
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 66

    (4) func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr . SEMI
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    SEMI            shift and go to state 106
    LBRACKET        shift and go to state 77
    QUESTIONMARK    shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MODULO          shift and go to state 83
    GT              shift and go to state 84
    LT              shift and go to state 85
    EQ              shift and go to state 86
    LE              shift and go to state 87
    GE              shift and go to state 88
    NE              shift and go to state 89
    LOR             shift and go to state 90
    LAND            shift and go to state 91


state 67

    (31) flist -> error ID COMMA flist .

    RPAREN          reduce using rule 31 (flist -> error ID COMMA flist .)


state 68

    (5) func -> DEF TYPE ID LPAREN error RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 107


state 69

    (6) func -> DEF error ID LPAREN flist RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 108


state 70

    (51) operation_on_list -> ID LBRACKET . expr RBRACKET
    (53) assignment -> ID LBRACKET . expr RBRACKET EQUALS expr
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 109
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 71

    (52) assignment -> ID EQUALS . expr
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 110
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 72

    (55) function_call -> ID LPAREN . clist RPAREN
    (56) function_call -> ID LPAREN . error RPAREN
    (34) clist -> . empty
    (35) clist -> . expr
    (36) clist -> . expr COMMA clist
    (70) empty -> .
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    error           shift and go to state 112
    RPAREN          reduce using rule 70 (empty -> .)
    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    clist                          shift and go to state 111
    empty                          shift and go to state 104
    expr                           shift and go to state 105
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 73

    (24) block -> LBRACE body . RBRACE

    RBRACE          shift and go to state 113


state 74

    (3) func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .

    DEF             reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    $end            reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    error           reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    LNOT            reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    PLUS            reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    MINUS           reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    ID              reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    NUMBER          reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    STRING          reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    VAR             reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    RETURN          reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    LBRACE          reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    LBRACKET        reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)
    ELSE            reduce using rule 3 (func -> DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE .)


state 75

    (8) body -> stmt body .

    RBRACE          reduce using rule 8 (body -> stmt body .)


state 76

    (9) stmt -> expr SEMI .

    error           reduce using rule 9 (stmt -> expr SEMI .)
    LNOT            reduce using rule 9 (stmt -> expr SEMI .)
    PLUS            reduce using rule 9 (stmt -> expr SEMI .)
    MINUS           reduce using rule 9 (stmt -> expr SEMI .)
    ID              reduce using rule 9 (stmt -> expr SEMI .)
    NUMBER          reduce using rule 9 (stmt -> expr SEMI .)
    STRING          reduce using rule 9 (stmt -> expr SEMI .)
    VAR             reduce using rule 9 (stmt -> expr SEMI .)
    RETURN          reduce using rule 9 (stmt -> expr SEMI .)
    IF              reduce using rule 9 (stmt -> expr SEMI .)
    WHILE           reduce using rule 9 (stmt -> expr SEMI .)
    FOR             reduce using rule 9 (stmt -> expr SEMI .)
    LBRACE          reduce using rule 9 (stmt -> expr SEMI .)
    DEF             reduce using rule 9 (stmt -> expr SEMI .)
    LBRACKET        reduce using rule 9 (stmt -> expr SEMI .)
    RBRACE          reduce using rule 9 (stmt -> expr SEMI .)
    ELSE            reduce using rule 9 (stmt -> expr SEMI .)


state 77

    (50) operation_on_list -> expr LBRACKET . expr RBRACKET
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 114
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 78

    (54) ternary_expr -> expr QUESTIONMARK . expr COLON expr
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 115
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 79

    (57) binary_expr -> expr PLUS . expr
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 116
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 80

    (58) binary_expr -> expr MINUS . expr
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 117
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 81

    (59) binary_expr -> expr TIMES . expr
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 118
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 82

    (60) binary_expr -> expr DIVIDE . expr
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 119
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 83

    (61) binary_expr -> expr MODULO . expr
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 120
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 84

    (62) binary_expr -> expr GT . expr
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 121
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 85

    (63) binary_expr -> expr LT . expr
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 122
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 86

    (64) binary_expr -> expr EQ . expr
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 123
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 87

    (65) binary_expr -> expr LE . expr
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 124
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 88

    (66) binary_expr -> expr GE . expr
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 125
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 89

    (67) binary_expr -> expr NE . expr
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 126
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 90

    (68) binary_expr -> expr LOR . expr
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 127
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 91

    (69) binary_expr -> expr LAND . expr
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 128
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 92

    (10) stmt -> defvar SEMI .

    error           reduce using rule 10 (stmt -> defvar SEMI .)
    LNOT            reduce using rule 10 (stmt -> defvar SEMI .)
    PLUS            reduce using rule 10 (stmt -> defvar SEMI .)
    MINUS           reduce using rule 10 (stmt -> defvar SEMI .)
    ID              reduce using rule 10 (stmt -> defvar SEMI .)
    NUMBER          reduce using rule 10 (stmt -> defvar SEMI .)
    STRING          reduce using rule 10 (stmt -> defvar SEMI .)
    VAR             reduce using rule 10 (stmt -> defvar SEMI .)
    RETURN          reduce using rule 10 (stmt -> defvar SEMI .)
    IF              reduce using rule 10 (stmt -> defvar SEMI .)
    WHILE           reduce using rule 10 (stmt -> defvar SEMI .)
    FOR             reduce using rule 10 (stmt -> defvar SEMI .)
    LBRACE          reduce using rule 10 (stmt -> defvar SEMI .)
    DEF             reduce using rule 10 (stmt -> defvar SEMI .)
    LBRACKET        reduce using rule 10 (stmt -> defvar SEMI .)
    RBRACE          reduce using rule 10 (stmt -> defvar SEMI .)
    ELSE            reduce using rule 10 (stmt -> defvar SEMI .)


state 93

    (11) stmt -> return_instr SEMI .

    error           reduce using rule 11 (stmt -> return_instr SEMI .)
    LNOT            reduce using rule 11 (stmt -> return_instr SEMI .)
    PLUS            reduce using rule 11 (stmt -> return_instr SEMI .)
    MINUS           reduce using rule 11 (stmt -> return_instr SEMI .)
    ID              reduce using rule 11 (stmt -> return_instr SEMI .)
    NUMBER          reduce using rule 11 (stmt -> return_instr SEMI .)
    STRING          reduce using rule 11 (stmt -> return_instr SEMI .)
    VAR             reduce using rule 11 (stmt -> return_instr SEMI .)
    RETURN          reduce using rule 11 (stmt -> return_instr SEMI .)
    IF              reduce using rule 11 (stmt -> return_instr SEMI .)
    WHILE           reduce using rule 11 (stmt -> return_instr SEMI .)
    FOR             reduce using rule 11 (stmt -> return_instr SEMI .)
    LBRACE          reduce using rule 11 (stmt -> return_instr SEMI .)
    DEF             reduce using rule 11 (stmt -> return_instr SEMI .)
    LBRACKET        reduce using rule 11 (stmt -> return_instr SEMI .)
    RBRACE          reduce using rule 11 (stmt -> return_instr SEMI .)
    ELSE            reduce using rule 11 (stmt -> return_instr SEMI .)


state 94

    (18) stmt -> error SEMI .

    error           reduce using rule 18 (stmt -> error SEMI .)
    LNOT            reduce using rule 18 (stmt -> error SEMI .)
    PLUS            reduce using rule 18 (stmt -> error SEMI .)
    MINUS           reduce using rule 18 (stmt -> error SEMI .)
    ID              reduce using rule 18 (stmt -> error SEMI .)
    NUMBER          reduce using rule 18 (stmt -> error SEMI .)
    STRING          reduce using rule 18 (stmt -> error SEMI .)
    VAR             reduce using rule 18 (stmt -> error SEMI .)
    RETURN          reduce using rule 18 (stmt -> error SEMI .)
    IF              reduce using rule 18 (stmt -> error SEMI .)
    WHILE           reduce using rule 18 (stmt -> error SEMI .)
    FOR             reduce using rule 18 (stmt -> error SEMI .)
    LBRACE          reduce using rule 18 (stmt -> error SEMI .)
    DEF             reduce using rule 18 (stmt -> error SEMI .)
    LBRACKET        reduce using rule 18 (stmt -> error SEMI .)
    RBRACE          reduce using rule 18 (stmt -> error SEMI .)
    ELSE            reduce using rule 18 (stmt -> error SEMI .)


state 95

    (40) expr -> LNOT expr .
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 40 (expr -> LNOT expr .)
    LBRACKET        reduce using rule 40 (expr -> LNOT expr .)
    QUESTIONMARK    reduce using rule 40 (expr -> LNOT expr .)
    PLUS            reduce using rule 40 (expr -> LNOT expr .)
    MINUS           reduce using rule 40 (expr -> LNOT expr .)
    TIMES           reduce using rule 40 (expr -> LNOT expr .)
    DIVIDE          reduce using rule 40 (expr -> LNOT expr .)
    MODULO          reduce using rule 40 (expr -> LNOT expr .)
    GT              reduce using rule 40 (expr -> LNOT expr .)
    LT              reduce using rule 40 (expr -> LNOT expr .)
    EQ              reduce using rule 40 (expr -> LNOT expr .)
    LE              reduce using rule 40 (expr -> LNOT expr .)
    GE              reduce using rule 40 (expr -> LNOT expr .)
    NE              reduce using rule 40 (expr -> LNOT expr .)
    LOR             reduce using rule 40 (expr -> LNOT expr .)
    LAND            reduce using rule 40 (expr -> LNOT expr .)
    COMMA           reduce using rule 40 (expr -> LNOT expr .)
    RBRACKET        reduce using rule 40 (expr -> LNOT expr .)
    RPAREN          reduce using rule 40 (expr -> LNOT expr .)
    COLON           reduce using rule 40 (expr -> LNOT expr .)
    TO              reduce using rule 40 (expr -> LNOT expr .)

  ! LBRACKET        [ shift and go to state 77 ]
  ! QUESTIONMARK    [ shift and go to state 78 ]
  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! TIMES           [ shift and go to state 81 ]
  ! DIVIDE          [ shift and go to state 82 ]
  ! MODULO          [ shift and go to state 83 ]
  ! GT              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! EQ              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! LOR             [ shift and go to state 90 ]
  ! LAND            [ shift and go to state 91 ]


state 96

    (41) expr -> PLUS expr .
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 41 (expr -> PLUS expr .)
    LBRACKET        reduce using rule 41 (expr -> PLUS expr .)
    PLUS            reduce using rule 41 (expr -> PLUS expr .)
    MINUS           reduce using rule 41 (expr -> PLUS expr .)
    GT              reduce using rule 41 (expr -> PLUS expr .)
    LT              reduce using rule 41 (expr -> PLUS expr .)
    EQ              reduce using rule 41 (expr -> PLUS expr .)
    LE              reduce using rule 41 (expr -> PLUS expr .)
    GE              reduce using rule 41 (expr -> PLUS expr .)
    NE              reduce using rule 41 (expr -> PLUS expr .)
    LOR             reduce using rule 41 (expr -> PLUS expr .)
    LAND            reduce using rule 41 (expr -> PLUS expr .)
    COMMA           reduce using rule 41 (expr -> PLUS expr .)
    RBRACKET        reduce using rule 41 (expr -> PLUS expr .)
    RPAREN          reduce using rule 41 (expr -> PLUS expr .)
    COLON           reduce using rule 41 (expr -> PLUS expr .)
    TO              reduce using rule 41 (expr -> PLUS expr .)
    QUESTIONMARK    shift and go to state 78
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MODULO          shift and go to state 83

  ! QUESTIONMARK    [ reduce using rule 41 (expr -> PLUS expr .) ]
  ! TIMES           [ reduce using rule 41 (expr -> PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 41 (expr -> PLUS expr .) ]
  ! MODULO          [ reduce using rule 41 (expr -> PLUS expr .) ]
  ! LBRACKET        [ shift and go to state 77 ]
  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! GT              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! EQ              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! LOR             [ shift and go to state 90 ]
  ! LAND            [ shift and go to state 91 ]


state 97

    (42) expr -> MINUS expr .
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 42 (expr -> MINUS expr .)
    LBRACKET        reduce using rule 42 (expr -> MINUS expr .)
    PLUS            reduce using rule 42 (expr -> MINUS expr .)
    MINUS           reduce using rule 42 (expr -> MINUS expr .)
    TIMES           reduce using rule 42 (expr -> MINUS expr .)
    DIVIDE          reduce using rule 42 (expr -> MINUS expr .)
    MODULO          reduce using rule 42 (expr -> MINUS expr .)
    GT              reduce using rule 42 (expr -> MINUS expr .)
    LT              reduce using rule 42 (expr -> MINUS expr .)
    EQ              reduce using rule 42 (expr -> MINUS expr .)
    LE              reduce using rule 42 (expr -> MINUS expr .)
    GE              reduce using rule 42 (expr -> MINUS expr .)
    NE              reduce using rule 42 (expr -> MINUS expr .)
    LOR             reduce using rule 42 (expr -> MINUS expr .)
    LAND            reduce using rule 42 (expr -> MINUS expr .)
    COMMA           reduce using rule 42 (expr -> MINUS expr .)
    RBRACKET        reduce using rule 42 (expr -> MINUS expr .)
    RPAREN          reduce using rule 42 (expr -> MINUS expr .)
    COLON           reduce using rule 42 (expr -> MINUS expr .)
    TO              reduce using rule 42 (expr -> MINUS expr .)
    QUESTIONMARK    shift and go to state 78

  ! QUESTIONMARK    [ reduce using rule 42 (expr -> MINUS expr .) ]
  ! LBRACKET        [ shift and go to state 77 ]
  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! TIMES           [ shift and go to state 81 ]
  ! DIVIDE          [ shift and go to state 82 ]
  ! MODULO          [ shift and go to state 83 ]
  ! GT              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! EQ              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! LOR             [ shift and go to state 90 ]
  ! LAND            [ shift and go to state 91 ]


state 98

    (26) defvar -> VAR TYPE . ID
    (27) defvar -> VAR TYPE . ID EQUALS expr

    ID              shift and go to state 129


state 99

    (25) return_instr -> RETURN expr .
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 25 (return_instr -> RETURN expr .)
    LBRACKET        shift and go to state 77
    QUESTIONMARK    shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MODULO          shift and go to state 83
    GT              shift and go to state 84
    LT              shift and go to state 85
    EQ              shift and go to state 86
    LE              shift and go to state 87
    GE              shift and go to state 88
    NE              shift and go to state 89
    LOR             shift and go to state 90
    LAND            shift and go to state 91


state 100

    (20) single_if -> IF LPAREN . expr RPAREN stmt
    (21) if_with_else -> IF LPAREN . expr RPAREN stmt ELSE stmt
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 130
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 101

    (22) while_loop -> WHILE LPAREN . expr RPAREN stmt
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 131
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 102

    (23) for_loop -> FOR LPAREN . ID EQUALS expr TO expr RPAREN stmt

    ID              shift and go to state 132


state 103

    (49) expr_list -> LBRACKET clist . RBRACKET

    RBRACKET        shift and go to state 133


state 104

    (34) clist -> empty .

    RBRACKET        reduce using rule 34 (clist -> empty .)
    RPAREN          reduce using rule 34 (clist -> empty .)


state 105

    (35) clist -> expr .
    (36) clist -> expr . COMMA clist
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    RBRACKET        reduce using rule 35 (clist -> expr .)
    RPAREN          reduce using rule 35 (clist -> expr .)
    COMMA           shift and go to state 134
    LBRACKET        shift and go to state 77
    QUESTIONMARK    shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MODULO          shift and go to state 83
    GT              shift and go to state 84
    LT              shift and go to state 85
    EQ              shift and go to state 86
    LE              shift and go to state 87
    GE              shift and go to state 88
    NE              shift and go to state 89
    LOR             shift and go to state 90
    LAND            shift and go to state 91


state 106

    (4) func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .

    DEF             reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    $end            reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    error           reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    LNOT            reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    PLUS            reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    MINUS           reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    ID              reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    NUMBER          reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    STRING          reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    VAR             reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    RETURN          reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    IF              reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    WHILE           reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    FOR             reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    LBRACE          reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    LBRACKET        reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    RBRACE          reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)
    ELSE            reduce using rule 4 (func -> DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI .)


state 107

    (5) func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .

    DEF             reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    $end            reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    error           reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    LNOT            reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    PLUS            reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    MINUS           reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    ID              reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    NUMBER          reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    STRING          reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    VAR             reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    RETURN          reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    LBRACE          reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    LBRACKET        reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)
    ELSE            reduce using rule 5 (func -> DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE .)


state 108

    (6) func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .

    DEF             reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    $end            reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    error           reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    LNOT            reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    PLUS            reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    MINUS           reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    ID              reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    NUMBER          reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    STRING          reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    VAR             reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    RETURN          reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    LBRACE          reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    LBRACKET        reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)
    ELSE            reduce using rule 6 (func -> DEF error ID LPAREN flist RPAREN LBRACE body RBRACE .)


state 109

    (51) operation_on_list -> ID LBRACKET expr . RBRACKET
    (53) assignment -> ID LBRACKET expr . RBRACKET EQUALS expr
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    RBRACKET        shift and go to state 135
    LBRACKET        shift and go to state 77
    QUESTIONMARK    shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MODULO          shift and go to state 83
    GT              shift and go to state 84
    LT              shift and go to state 85
    EQ              shift and go to state 86
    LE              shift and go to state 87
    GE              shift and go to state 88
    NE              shift and go to state 89
    LOR             shift and go to state 90
    LAND            shift and go to state 91


state 110

    (52) assignment -> ID EQUALS expr .
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 52 (assignment -> ID EQUALS expr .)
    LBRACKET        reduce using rule 52 (assignment -> ID EQUALS expr .)
    COMMA           reduce using rule 52 (assignment -> ID EQUALS expr .)
    RBRACKET        reduce using rule 52 (assignment -> ID EQUALS expr .)
    RPAREN          reduce using rule 52 (assignment -> ID EQUALS expr .)
    COLON           reduce using rule 52 (assignment -> ID EQUALS expr .)
    TO              reduce using rule 52 (assignment -> ID EQUALS expr .)
    QUESTIONMARK    shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MODULO          shift and go to state 83
    GT              shift and go to state 84
    LT              shift and go to state 85
    EQ              shift and go to state 86
    LE              shift and go to state 87
    GE              shift and go to state 88
    NE              shift and go to state 89
    LOR             shift and go to state 90
    LAND            shift and go to state 91

  ! QUESTIONMARK    [ reduce using rule 52 (assignment -> ID EQUALS expr .) ]
  ! PLUS            [ reduce using rule 52 (assignment -> ID EQUALS expr .) ]
  ! MINUS           [ reduce using rule 52 (assignment -> ID EQUALS expr .) ]
  ! TIMES           [ reduce using rule 52 (assignment -> ID EQUALS expr .) ]
  ! DIVIDE          [ reduce using rule 52 (assignment -> ID EQUALS expr .) ]
  ! MODULO          [ reduce using rule 52 (assignment -> ID EQUALS expr .) ]
  ! GT              [ reduce using rule 52 (assignment -> ID EQUALS expr .) ]
  ! LT              [ reduce using rule 52 (assignment -> ID EQUALS expr .) ]
  ! EQ              [ reduce using rule 52 (assignment -> ID EQUALS expr .) ]
  ! LE              [ reduce using rule 52 (assignment -> ID EQUALS expr .) ]
  ! GE              [ reduce using rule 52 (assignment -> ID EQUALS expr .) ]
  ! NE              [ reduce using rule 52 (assignment -> ID EQUALS expr .) ]
  ! LOR             [ reduce using rule 52 (assignment -> ID EQUALS expr .) ]
  ! LAND            [ reduce using rule 52 (assignment -> ID EQUALS expr .) ]
  ! LBRACKET        [ shift and go to state 77 ]


state 111

    (55) function_call -> ID LPAREN clist . RPAREN

    RPAREN          shift and go to state 136


state 112

    (56) function_call -> ID LPAREN error . RPAREN

    RPAREN          shift and go to state 137


state 113

    (24) block -> LBRACE body RBRACE .

    error           reduce using rule 24 (block -> LBRACE body RBRACE .)
    LNOT            reduce using rule 24 (block -> LBRACE body RBRACE .)
    PLUS            reduce using rule 24 (block -> LBRACE body RBRACE .)
    MINUS           reduce using rule 24 (block -> LBRACE body RBRACE .)
    ID              reduce using rule 24 (block -> LBRACE body RBRACE .)
    NUMBER          reduce using rule 24 (block -> LBRACE body RBRACE .)
    STRING          reduce using rule 24 (block -> LBRACE body RBRACE .)
    VAR             reduce using rule 24 (block -> LBRACE body RBRACE .)
    RETURN          reduce using rule 24 (block -> LBRACE body RBRACE .)
    IF              reduce using rule 24 (block -> LBRACE body RBRACE .)
    WHILE           reduce using rule 24 (block -> LBRACE body RBRACE .)
    FOR             reduce using rule 24 (block -> LBRACE body RBRACE .)
    LBRACE          reduce using rule 24 (block -> LBRACE body RBRACE .)
    DEF             reduce using rule 24 (block -> LBRACE body RBRACE .)
    LBRACKET        reduce using rule 24 (block -> LBRACE body RBRACE .)
    RBRACE          reduce using rule 24 (block -> LBRACE body RBRACE .)
    ELSE            reduce using rule 24 (block -> LBRACE body RBRACE .)


state 114

    (50) operation_on_list -> expr LBRACKET expr . RBRACKET
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    RBRACKET        shift and go to state 138
    LBRACKET        shift and go to state 77
    QUESTIONMARK    shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MODULO          shift and go to state 83
    GT              shift and go to state 84
    LT              shift and go to state 85
    EQ              shift and go to state 86
    LE              shift and go to state 87
    GE              shift and go to state 88
    NE              shift and go to state 89
    LOR             shift and go to state 90
    LAND            shift and go to state 91


state 115

    (54) ternary_expr -> expr QUESTIONMARK expr . COLON expr
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    COLON           shift and go to state 139
    LBRACKET        shift and go to state 77
    QUESTIONMARK    shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MODULO          shift and go to state 83
    GT              shift and go to state 84
    LT              shift and go to state 85
    EQ              shift and go to state 86
    LE              shift and go to state 87
    GE              shift and go to state 88
    NE              shift and go to state 89
    LOR             shift and go to state 90
    LAND            shift and go to state 91


state 116

    (57) binary_expr -> expr PLUS expr .
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 57 (binary_expr -> expr PLUS expr .)
    LBRACKET        reduce using rule 57 (binary_expr -> expr PLUS expr .)
    PLUS            reduce using rule 57 (binary_expr -> expr PLUS expr .)
    MINUS           reduce using rule 57 (binary_expr -> expr PLUS expr .)
    GT              reduce using rule 57 (binary_expr -> expr PLUS expr .)
    LT              reduce using rule 57 (binary_expr -> expr PLUS expr .)
    EQ              reduce using rule 57 (binary_expr -> expr PLUS expr .)
    LE              reduce using rule 57 (binary_expr -> expr PLUS expr .)
    GE              reduce using rule 57 (binary_expr -> expr PLUS expr .)
    NE              reduce using rule 57 (binary_expr -> expr PLUS expr .)
    LOR             reduce using rule 57 (binary_expr -> expr PLUS expr .)
    LAND            reduce using rule 57 (binary_expr -> expr PLUS expr .)
    COMMA           reduce using rule 57 (binary_expr -> expr PLUS expr .)
    RBRACKET        reduce using rule 57 (binary_expr -> expr PLUS expr .)
    RPAREN          reduce using rule 57 (binary_expr -> expr PLUS expr .)
    COLON           reduce using rule 57 (binary_expr -> expr PLUS expr .)
    TO              reduce using rule 57 (binary_expr -> expr PLUS expr .)
    QUESTIONMARK    shift and go to state 78
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MODULO          shift and go to state 83

  ! QUESTIONMARK    [ reduce using rule 57 (binary_expr -> expr PLUS expr .) ]
  ! TIMES           [ reduce using rule 57 (binary_expr -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 57 (binary_expr -> expr PLUS expr .) ]
  ! MODULO          [ reduce using rule 57 (binary_expr -> expr PLUS expr .) ]
  ! LBRACKET        [ shift and go to state 77 ]
  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! GT              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! EQ              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! LOR             [ shift and go to state 90 ]
  ! LAND            [ shift and go to state 91 ]


state 117

    (58) binary_expr -> expr MINUS expr .
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 58 (binary_expr -> expr MINUS expr .)
    LBRACKET        reduce using rule 58 (binary_expr -> expr MINUS expr .)
    PLUS            reduce using rule 58 (binary_expr -> expr MINUS expr .)
    MINUS           reduce using rule 58 (binary_expr -> expr MINUS expr .)
    GT              reduce using rule 58 (binary_expr -> expr MINUS expr .)
    LT              reduce using rule 58 (binary_expr -> expr MINUS expr .)
    EQ              reduce using rule 58 (binary_expr -> expr MINUS expr .)
    LE              reduce using rule 58 (binary_expr -> expr MINUS expr .)
    GE              reduce using rule 58 (binary_expr -> expr MINUS expr .)
    NE              reduce using rule 58 (binary_expr -> expr MINUS expr .)
    LOR             reduce using rule 58 (binary_expr -> expr MINUS expr .)
    LAND            reduce using rule 58 (binary_expr -> expr MINUS expr .)
    COMMA           reduce using rule 58 (binary_expr -> expr MINUS expr .)
    RBRACKET        reduce using rule 58 (binary_expr -> expr MINUS expr .)
    RPAREN          reduce using rule 58 (binary_expr -> expr MINUS expr .)
    COLON           reduce using rule 58 (binary_expr -> expr MINUS expr .)
    TO              reduce using rule 58 (binary_expr -> expr MINUS expr .)
    QUESTIONMARK    shift and go to state 78
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MODULO          shift and go to state 83

  ! QUESTIONMARK    [ reduce using rule 58 (binary_expr -> expr MINUS expr .) ]
  ! TIMES           [ reduce using rule 58 (binary_expr -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 58 (binary_expr -> expr MINUS expr .) ]
  ! MODULO          [ reduce using rule 58 (binary_expr -> expr MINUS expr .) ]
  ! LBRACKET        [ shift and go to state 77 ]
  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! GT              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! EQ              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! LOR             [ shift and go to state 90 ]
  ! LAND            [ shift and go to state 91 ]


state 118

    (59) binary_expr -> expr TIMES expr .
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 59 (binary_expr -> expr TIMES expr .)
    LBRACKET        reduce using rule 59 (binary_expr -> expr TIMES expr .)
    PLUS            reduce using rule 59 (binary_expr -> expr TIMES expr .)
    MINUS           reduce using rule 59 (binary_expr -> expr TIMES expr .)
    TIMES           reduce using rule 59 (binary_expr -> expr TIMES expr .)
    DIVIDE          reduce using rule 59 (binary_expr -> expr TIMES expr .)
    MODULO          reduce using rule 59 (binary_expr -> expr TIMES expr .)
    GT              reduce using rule 59 (binary_expr -> expr TIMES expr .)
    LT              reduce using rule 59 (binary_expr -> expr TIMES expr .)
    EQ              reduce using rule 59 (binary_expr -> expr TIMES expr .)
    LE              reduce using rule 59 (binary_expr -> expr TIMES expr .)
    GE              reduce using rule 59 (binary_expr -> expr TIMES expr .)
    NE              reduce using rule 59 (binary_expr -> expr TIMES expr .)
    LOR             reduce using rule 59 (binary_expr -> expr TIMES expr .)
    LAND            reduce using rule 59 (binary_expr -> expr TIMES expr .)
    COMMA           reduce using rule 59 (binary_expr -> expr TIMES expr .)
    RBRACKET        reduce using rule 59 (binary_expr -> expr TIMES expr .)
    RPAREN          reduce using rule 59 (binary_expr -> expr TIMES expr .)
    COLON           reduce using rule 59 (binary_expr -> expr TIMES expr .)
    TO              reduce using rule 59 (binary_expr -> expr TIMES expr .)
    QUESTIONMARK    shift and go to state 78

  ! QUESTIONMARK    [ reduce using rule 59 (binary_expr -> expr TIMES expr .) ]
  ! LBRACKET        [ shift and go to state 77 ]
  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! TIMES           [ shift and go to state 81 ]
  ! DIVIDE          [ shift and go to state 82 ]
  ! MODULO          [ shift and go to state 83 ]
  ! GT              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! EQ              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! LOR             [ shift and go to state 90 ]
  ! LAND            [ shift and go to state 91 ]


state 119

    (60) binary_expr -> expr DIVIDE expr .
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 60 (binary_expr -> expr DIVIDE expr .)
    LBRACKET        reduce using rule 60 (binary_expr -> expr DIVIDE expr .)
    PLUS            reduce using rule 60 (binary_expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 60 (binary_expr -> expr DIVIDE expr .)
    TIMES           reduce using rule 60 (binary_expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 60 (binary_expr -> expr DIVIDE expr .)
    MODULO          reduce using rule 60 (binary_expr -> expr DIVIDE expr .)
    GT              reduce using rule 60 (binary_expr -> expr DIVIDE expr .)
    LT              reduce using rule 60 (binary_expr -> expr DIVIDE expr .)
    EQ              reduce using rule 60 (binary_expr -> expr DIVIDE expr .)
    LE              reduce using rule 60 (binary_expr -> expr DIVIDE expr .)
    GE              reduce using rule 60 (binary_expr -> expr DIVIDE expr .)
    NE              reduce using rule 60 (binary_expr -> expr DIVIDE expr .)
    LOR             reduce using rule 60 (binary_expr -> expr DIVIDE expr .)
    LAND            reduce using rule 60 (binary_expr -> expr DIVIDE expr .)
    COMMA           reduce using rule 60 (binary_expr -> expr DIVIDE expr .)
    RBRACKET        reduce using rule 60 (binary_expr -> expr DIVIDE expr .)
    RPAREN          reduce using rule 60 (binary_expr -> expr DIVIDE expr .)
    COLON           reduce using rule 60 (binary_expr -> expr DIVIDE expr .)
    TO              reduce using rule 60 (binary_expr -> expr DIVIDE expr .)
    QUESTIONMARK    shift and go to state 78

  ! QUESTIONMARK    [ reduce using rule 60 (binary_expr -> expr DIVIDE expr .) ]
  ! LBRACKET        [ shift and go to state 77 ]
  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! TIMES           [ shift and go to state 81 ]
  ! DIVIDE          [ shift and go to state 82 ]
  ! MODULO          [ shift and go to state 83 ]
  ! GT              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! EQ              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! LOR             [ shift and go to state 90 ]
  ! LAND            [ shift and go to state 91 ]


state 120

    (61) binary_expr -> expr MODULO expr .
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 61 (binary_expr -> expr MODULO expr .)
    LBRACKET        reduce using rule 61 (binary_expr -> expr MODULO expr .)
    PLUS            reduce using rule 61 (binary_expr -> expr MODULO expr .)
    MINUS           reduce using rule 61 (binary_expr -> expr MODULO expr .)
    TIMES           reduce using rule 61 (binary_expr -> expr MODULO expr .)
    DIVIDE          reduce using rule 61 (binary_expr -> expr MODULO expr .)
    MODULO          reduce using rule 61 (binary_expr -> expr MODULO expr .)
    GT              reduce using rule 61 (binary_expr -> expr MODULO expr .)
    LT              reduce using rule 61 (binary_expr -> expr MODULO expr .)
    EQ              reduce using rule 61 (binary_expr -> expr MODULO expr .)
    LE              reduce using rule 61 (binary_expr -> expr MODULO expr .)
    GE              reduce using rule 61 (binary_expr -> expr MODULO expr .)
    NE              reduce using rule 61 (binary_expr -> expr MODULO expr .)
    LOR             reduce using rule 61 (binary_expr -> expr MODULO expr .)
    LAND            reduce using rule 61 (binary_expr -> expr MODULO expr .)
    COMMA           reduce using rule 61 (binary_expr -> expr MODULO expr .)
    RBRACKET        reduce using rule 61 (binary_expr -> expr MODULO expr .)
    RPAREN          reduce using rule 61 (binary_expr -> expr MODULO expr .)
    COLON           reduce using rule 61 (binary_expr -> expr MODULO expr .)
    TO              reduce using rule 61 (binary_expr -> expr MODULO expr .)
    QUESTIONMARK    shift and go to state 78

  ! QUESTIONMARK    [ reduce using rule 61 (binary_expr -> expr MODULO expr .) ]
  ! LBRACKET        [ shift and go to state 77 ]
  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! TIMES           [ shift and go to state 81 ]
  ! DIVIDE          [ shift and go to state 82 ]
  ! MODULO          [ shift and go to state 83 ]
  ! GT              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! EQ              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! LOR             [ shift and go to state 90 ]
  ! LAND            [ shift and go to state 91 ]


state 121

    (62) binary_expr -> expr GT expr .
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 62 (binary_expr -> expr GT expr .)
    LBRACKET        reduce using rule 62 (binary_expr -> expr GT expr .)
    GT              reduce using rule 62 (binary_expr -> expr GT expr .)
    LT              reduce using rule 62 (binary_expr -> expr GT expr .)
    EQ              reduce using rule 62 (binary_expr -> expr GT expr .)
    LE              reduce using rule 62 (binary_expr -> expr GT expr .)
    GE              reduce using rule 62 (binary_expr -> expr GT expr .)
    NE              reduce using rule 62 (binary_expr -> expr GT expr .)
    LOR             reduce using rule 62 (binary_expr -> expr GT expr .)
    LAND            reduce using rule 62 (binary_expr -> expr GT expr .)
    COMMA           reduce using rule 62 (binary_expr -> expr GT expr .)
    RBRACKET        reduce using rule 62 (binary_expr -> expr GT expr .)
    RPAREN          reduce using rule 62 (binary_expr -> expr GT expr .)
    COLON           reduce using rule 62 (binary_expr -> expr GT expr .)
    TO              reduce using rule 62 (binary_expr -> expr GT expr .)
    QUESTIONMARK    shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MODULO          shift and go to state 83

  ! QUESTIONMARK    [ reduce using rule 62 (binary_expr -> expr GT expr .) ]
  ! PLUS            [ reduce using rule 62 (binary_expr -> expr GT expr .) ]
  ! MINUS           [ reduce using rule 62 (binary_expr -> expr GT expr .) ]
  ! TIMES           [ reduce using rule 62 (binary_expr -> expr GT expr .) ]
  ! DIVIDE          [ reduce using rule 62 (binary_expr -> expr GT expr .) ]
  ! MODULO          [ reduce using rule 62 (binary_expr -> expr GT expr .) ]
  ! LBRACKET        [ shift and go to state 77 ]
  ! GT              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! EQ              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! LOR             [ shift and go to state 90 ]
  ! LAND            [ shift and go to state 91 ]


state 122

    (63) binary_expr -> expr LT expr .
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 63 (binary_expr -> expr LT expr .)
    LBRACKET        reduce using rule 63 (binary_expr -> expr LT expr .)
    GT              reduce using rule 63 (binary_expr -> expr LT expr .)
    LT              reduce using rule 63 (binary_expr -> expr LT expr .)
    EQ              reduce using rule 63 (binary_expr -> expr LT expr .)
    LE              reduce using rule 63 (binary_expr -> expr LT expr .)
    GE              reduce using rule 63 (binary_expr -> expr LT expr .)
    NE              reduce using rule 63 (binary_expr -> expr LT expr .)
    LOR             reduce using rule 63 (binary_expr -> expr LT expr .)
    LAND            reduce using rule 63 (binary_expr -> expr LT expr .)
    COMMA           reduce using rule 63 (binary_expr -> expr LT expr .)
    RBRACKET        reduce using rule 63 (binary_expr -> expr LT expr .)
    RPAREN          reduce using rule 63 (binary_expr -> expr LT expr .)
    COLON           reduce using rule 63 (binary_expr -> expr LT expr .)
    TO              reduce using rule 63 (binary_expr -> expr LT expr .)
    QUESTIONMARK    shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MODULO          shift and go to state 83

  ! QUESTIONMARK    [ reduce using rule 63 (binary_expr -> expr LT expr .) ]
  ! PLUS            [ reduce using rule 63 (binary_expr -> expr LT expr .) ]
  ! MINUS           [ reduce using rule 63 (binary_expr -> expr LT expr .) ]
  ! TIMES           [ reduce using rule 63 (binary_expr -> expr LT expr .) ]
  ! DIVIDE          [ reduce using rule 63 (binary_expr -> expr LT expr .) ]
  ! MODULO          [ reduce using rule 63 (binary_expr -> expr LT expr .) ]
  ! LBRACKET        [ shift and go to state 77 ]
  ! GT              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! EQ              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! LOR             [ shift and go to state 90 ]
  ! LAND            [ shift and go to state 91 ]


state 123

    (64) binary_expr -> expr EQ expr .
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 64 (binary_expr -> expr EQ expr .)
    LBRACKET        reduce using rule 64 (binary_expr -> expr EQ expr .)
    QUESTIONMARK    reduce using rule 64 (binary_expr -> expr EQ expr .)
    PLUS            reduce using rule 64 (binary_expr -> expr EQ expr .)
    MINUS           reduce using rule 64 (binary_expr -> expr EQ expr .)
    TIMES           reduce using rule 64 (binary_expr -> expr EQ expr .)
    DIVIDE          reduce using rule 64 (binary_expr -> expr EQ expr .)
    MODULO          reduce using rule 64 (binary_expr -> expr EQ expr .)
    GT              reduce using rule 64 (binary_expr -> expr EQ expr .)
    LT              reduce using rule 64 (binary_expr -> expr EQ expr .)
    EQ              reduce using rule 64 (binary_expr -> expr EQ expr .)
    LE              reduce using rule 64 (binary_expr -> expr EQ expr .)
    GE              reduce using rule 64 (binary_expr -> expr EQ expr .)
    NE              reduce using rule 64 (binary_expr -> expr EQ expr .)
    LOR             reduce using rule 64 (binary_expr -> expr EQ expr .)
    LAND            reduce using rule 64 (binary_expr -> expr EQ expr .)
    COMMA           reduce using rule 64 (binary_expr -> expr EQ expr .)
    RBRACKET        reduce using rule 64 (binary_expr -> expr EQ expr .)
    RPAREN          reduce using rule 64 (binary_expr -> expr EQ expr .)
    COLON           reduce using rule 64 (binary_expr -> expr EQ expr .)
    TO              reduce using rule 64 (binary_expr -> expr EQ expr .)

  ! LBRACKET        [ shift and go to state 77 ]
  ! QUESTIONMARK    [ shift and go to state 78 ]
  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! TIMES           [ shift and go to state 81 ]
  ! DIVIDE          [ shift and go to state 82 ]
  ! MODULO          [ shift and go to state 83 ]
  ! GT              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! EQ              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! LOR             [ shift and go to state 90 ]
  ! LAND            [ shift and go to state 91 ]


state 124

    (65) binary_expr -> expr LE expr .
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 65 (binary_expr -> expr LE expr .)
    LBRACKET        reduce using rule 65 (binary_expr -> expr LE expr .)
    GT              reduce using rule 65 (binary_expr -> expr LE expr .)
    LT              reduce using rule 65 (binary_expr -> expr LE expr .)
    EQ              reduce using rule 65 (binary_expr -> expr LE expr .)
    LE              reduce using rule 65 (binary_expr -> expr LE expr .)
    GE              reduce using rule 65 (binary_expr -> expr LE expr .)
    NE              reduce using rule 65 (binary_expr -> expr LE expr .)
    LOR             reduce using rule 65 (binary_expr -> expr LE expr .)
    LAND            reduce using rule 65 (binary_expr -> expr LE expr .)
    COMMA           reduce using rule 65 (binary_expr -> expr LE expr .)
    RBRACKET        reduce using rule 65 (binary_expr -> expr LE expr .)
    RPAREN          reduce using rule 65 (binary_expr -> expr LE expr .)
    COLON           reduce using rule 65 (binary_expr -> expr LE expr .)
    TO              reduce using rule 65 (binary_expr -> expr LE expr .)
    QUESTIONMARK    shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MODULO          shift and go to state 83

  ! QUESTIONMARK    [ reduce using rule 65 (binary_expr -> expr LE expr .) ]
  ! PLUS            [ reduce using rule 65 (binary_expr -> expr LE expr .) ]
  ! MINUS           [ reduce using rule 65 (binary_expr -> expr LE expr .) ]
  ! TIMES           [ reduce using rule 65 (binary_expr -> expr LE expr .) ]
  ! DIVIDE          [ reduce using rule 65 (binary_expr -> expr LE expr .) ]
  ! MODULO          [ reduce using rule 65 (binary_expr -> expr LE expr .) ]
  ! LBRACKET        [ shift and go to state 77 ]
  ! GT              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! EQ              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! LOR             [ shift and go to state 90 ]
  ! LAND            [ shift and go to state 91 ]


state 125

    (66) binary_expr -> expr GE expr .
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 66 (binary_expr -> expr GE expr .)
    LBRACKET        reduce using rule 66 (binary_expr -> expr GE expr .)
    GT              reduce using rule 66 (binary_expr -> expr GE expr .)
    LT              reduce using rule 66 (binary_expr -> expr GE expr .)
    EQ              reduce using rule 66 (binary_expr -> expr GE expr .)
    LE              reduce using rule 66 (binary_expr -> expr GE expr .)
    GE              reduce using rule 66 (binary_expr -> expr GE expr .)
    NE              reduce using rule 66 (binary_expr -> expr GE expr .)
    LOR             reduce using rule 66 (binary_expr -> expr GE expr .)
    LAND            reduce using rule 66 (binary_expr -> expr GE expr .)
    COMMA           reduce using rule 66 (binary_expr -> expr GE expr .)
    RBRACKET        reduce using rule 66 (binary_expr -> expr GE expr .)
    RPAREN          reduce using rule 66 (binary_expr -> expr GE expr .)
    COLON           reduce using rule 66 (binary_expr -> expr GE expr .)
    TO              reduce using rule 66 (binary_expr -> expr GE expr .)
    QUESTIONMARK    shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MODULO          shift and go to state 83

  ! QUESTIONMARK    [ reduce using rule 66 (binary_expr -> expr GE expr .) ]
  ! PLUS            [ reduce using rule 66 (binary_expr -> expr GE expr .) ]
  ! MINUS           [ reduce using rule 66 (binary_expr -> expr GE expr .) ]
  ! TIMES           [ reduce using rule 66 (binary_expr -> expr GE expr .) ]
  ! DIVIDE          [ reduce using rule 66 (binary_expr -> expr GE expr .) ]
  ! MODULO          [ reduce using rule 66 (binary_expr -> expr GE expr .) ]
  ! LBRACKET        [ shift and go to state 77 ]
  ! GT              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! EQ              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! LOR             [ shift and go to state 90 ]
  ! LAND            [ shift and go to state 91 ]


state 126

    (67) binary_expr -> expr NE expr .
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 67 (binary_expr -> expr NE expr .)
    LBRACKET        reduce using rule 67 (binary_expr -> expr NE expr .)
    GT              reduce using rule 67 (binary_expr -> expr NE expr .)
    LT              reduce using rule 67 (binary_expr -> expr NE expr .)
    EQ              reduce using rule 67 (binary_expr -> expr NE expr .)
    LE              reduce using rule 67 (binary_expr -> expr NE expr .)
    GE              reduce using rule 67 (binary_expr -> expr NE expr .)
    NE              reduce using rule 67 (binary_expr -> expr NE expr .)
    LOR             reduce using rule 67 (binary_expr -> expr NE expr .)
    LAND            reduce using rule 67 (binary_expr -> expr NE expr .)
    COMMA           reduce using rule 67 (binary_expr -> expr NE expr .)
    RBRACKET        reduce using rule 67 (binary_expr -> expr NE expr .)
    RPAREN          reduce using rule 67 (binary_expr -> expr NE expr .)
    COLON           reduce using rule 67 (binary_expr -> expr NE expr .)
    TO              reduce using rule 67 (binary_expr -> expr NE expr .)
    QUESTIONMARK    shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MODULO          shift and go to state 83

  ! QUESTIONMARK    [ reduce using rule 67 (binary_expr -> expr NE expr .) ]
  ! PLUS            [ reduce using rule 67 (binary_expr -> expr NE expr .) ]
  ! MINUS           [ reduce using rule 67 (binary_expr -> expr NE expr .) ]
  ! TIMES           [ reduce using rule 67 (binary_expr -> expr NE expr .) ]
  ! DIVIDE          [ reduce using rule 67 (binary_expr -> expr NE expr .) ]
  ! MODULO          [ reduce using rule 67 (binary_expr -> expr NE expr .) ]
  ! LBRACKET        [ shift and go to state 77 ]
  ! GT              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! EQ              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! LOR             [ shift and go to state 90 ]
  ! LAND            [ shift and go to state 91 ]


state 127

    (68) binary_expr -> expr LOR expr .
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 68 (binary_expr -> expr LOR expr .)
    LBRACKET        reduce using rule 68 (binary_expr -> expr LOR expr .)
    LOR             reduce using rule 68 (binary_expr -> expr LOR expr .)
    COMMA           reduce using rule 68 (binary_expr -> expr LOR expr .)
    RBRACKET        reduce using rule 68 (binary_expr -> expr LOR expr .)
    RPAREN          reduce using rule 68 (binary_expr -> expr LOR expr .)
    COLON           reduce using rule 68 (binary_expr -> expr LOR expr .)
    TO              reduce using rule 68 (binary_expr -> expr LOR expr .)
    QUESTIONMARK    shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MODULO          shift and go to state 83
    GT              shift and go to state 84
    LT              shift and go to state 85
    EQ              shift and go to state 86
    LE              shift and go to state 87
    GE              shift and go to state 88
    NE              shift and go to state 89
    LAND            shift and go to state 91

  ! QUESTIONMARK    [ reduce using rule 68 (binary_expr -> expr LOR expr .) ]
  ! PLUS            [ reduce using rule 68 (binary_expr -> expr LOR expr .) ]
  ! MINUS           [ reduce using rule 68 (binary_expr -> expr LOR expr .) ]
  ! TIMES           [ reduce using rule 68 (binary_expr -> expr LOR expr .) ]
  ! DIVIDE          [ reduce using rule 68 (binary_expr -> expr LOR expr .) ]
  ! MODULO          [ reduce using rule 68 (binary_expr -> expr LOR expr .) ]
  ! GT              [ reduce using rule 68 (binary_expr -> expr LOR expr .) ]
  ! LT              [ reduce using rule 68 (binary_expr -> expr LOR expr .) ]
  ! EQ              [ reduce using rule 68 (binary_expr -> expr LOR expr .) ]
  ! LE              [ reduce using rule 68 (binary_expr -> expr LOR expr .) ]
  ! GE              [ reduce using rule 68 (binary_expr -> expr LOR expr .) ]
  ! NE              [ reduce using rule 68 (binary_expr -> expr LOR expr .) ]
  ! LAND            [ reduce using rule 68 (binary_expr -> expr LOR expr .) ]
  ! LBRACKET        [ shift and go to state 77 ]
  ! LOR             [ shift and go to state 90 ]


state 128

    (69) binary_expr -> expr LAND expr .
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 69 (binary_expr -> expr LAND expr .)
    LBRACKET        reduce using rule 69 (binary_expr -> expr LAND expr .)
    LOR             reduce using rule 69 (binary_expr -> expr LAND expr .)
    LAND            reduce using rule 69 (binary_expr -> expr LAND expr .)
    COMMA           reduce using rule 69 (binary_expr -> expr LAND expr .)
    RBRACKET        reduce using rule 69 (binary_expr -> expr LAND expr .)
    RPAREN          reduce using rule 69 (binary_expr -> expr LAND expr .)
    COLON           reduce using rule 69 (binary_expr -> expr LAND expr .)
    TO              reduce using rule 69 (binary_expr -> expr LAND expr .)
    QUESTIONMARK    shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MODULO          shift and go to state 83
    GT              shift and go to state 84
    LT              shift and go to state 85
    EQ              shift and go to state 86
    LE              shift and go to state 87
    GE              shift and go to state 88
    NE              shift and go to state 89

  ! QUESTIONMARK    [ reduce using rule 69 (binary_expr -> expr LAND expr .) ]
  ! PLUS            [ reduce using rule 69 (binary_expr -> expr LAND expr .) ]
  ! MINUS           [ reduce using rule 69 (binary_expr -> expr LAND expr .) ]
  ! TIMES           [ reduce using rule 69 (binary_expr -> expr LAND expr .) ]
  ! DIVIDE          [ reduce using rule 69 (binary_expr -> expr LAND expr .) ]
  ! MODULO          [ reduce using rule 69 (binary_expr -> expr LAND expr .) ]
  ! GT              [ reduce using rule 69 (binary_expr -> expr LAND expr .) ]
  ! LT              [ reduce using rule 69 (binary_expr -> expr LAND expr .) ]
  ! EQ              [ reduce using rule 69 (binary_expr -> expr LAND expr .) ]
  ! LE              [ reduce using rule 69 (binary_expr -> expr LAND expr .) ]
  ! GE              [ reduce using rule 69 (binary_expr -> expr LAND expr .) ]
  ! NE              [ reduce using rule 69 (binary_expr -> expr LAND expr .) ]
  ! LBRACKET        [ shift and go to state 77 ]
  ! LOR             [ shift and go to state 90 ]
  ! LAND            [ shift and go to state 91 ]


state 129

    (26) defvar -> VAR TYPE ID .
    (27) defvar -> VAR TYPE ID . EQUALS expr

    SEMI            reduce using rule 26 (defvar -> VAR TYPE ID .)
    EQUALS          shift and go to state 140


state 130

    (20) single_if -> IF LPAREN expr . RPAREN stmt
    (21) if_with_else -> IF LPAREN expr . RPAREN stmt ELSE stmt
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    RPAREN          shift and go to state 141
    LBRACKET        shift and go to state 77
    QUESTIONMARK    shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MODULO          shift and go to state 83
    GT              shift and go to state 84
    LT              shift and go to state 85
    EQ              shift and go to state 86
    LE              shift and go to state 87
    GE              shift and go to state 88
    NE              shift and go to state 89
    LOR             shift and go to state 90
    LAND            shift and go to state 91


state 131

    (22) while_loop -> WHILE LPAREN expr . RPAREN stmt
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    RPAREN          shift and go to state 142
    LBRACKET        shift and go to state 77
    QUESTIONMARK    shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MODULO          shift and go to state 83
    GT              shift and go to state 84
    LT              shift and go to state 85
    EQ              shift and go to state 86
    LE              shift and go to state 87
    GE              shift and go to state 88
    NE              shift and go to state 89
    LOR             shift and go to state 90
    LAND            shift and go to state 91


state 132

    (23) for_loop -> FOR LPAREN ID . EQUALS expr TO expr RPAREN stmt

    EQUALS          shift and go to state 143


state 133

    (49) expr_list -> LBRACKET clist RBRACKET .

    SEMI            reduce using rule 49 (expr_list -> LBRACKET clist RBRACKET .)
    LBRACKET        reduce using rule 49 (expr_list -> LBRACKET clist RBRACKET .)
    QUESTIONMARK    reduce using rule 49 (expr_list -> LBRACKET clist RBRACKET .)
    PLUS            reduce using rule 49 (expr_list -> LBRACKET clist RBRACKET .)
    MINUS           reduce using rule 49 (expr_list -> LBRACKET clist RBRACKET .)
    TIMES           reduce using rule 49 (expr_list -> LBRACKET clist RBRACKET .)
    DIVIDE          reduce using rule 49 (expr_list -> LBRACKET clist RBRACKET .)
    MODULO          reduce using rule 49 (expr_list -> LBRACKET clist RBRACKET .)
    GT              reduce using rule 49 (expr_list -> LBRACKET clist RBRACKET .)
    LT              reduce using rule 49 (expr_list -> LBRACKET clist RBRACKET .)
    EQ              reduce using rule 49 (expr_list -> LBRACKET clist RBRACKET .)
    LE              reduce using rule 49 (expr_list -> LBRACKET clist RBRACKET .)
    GE              reduce using rule 49 (expr_list -> LBRACKET clist RBRACKET .)
    NE              reduce using rule 49 (expr_list -> LBRACKET clist RBRACKET .)
    LOR             reduce using rule 49 (expr_list -> LBRACKET clist RBRACKET .)
    LAND            reduce using rule 49 (expr_list -> LBRACKET clist RBRACKET .)
    COMMA           reduce using rule 49 (expr_list -> LBRACKET clist RBRACKET .)
    RBRACKET        reduce using rule 49 (expr_list -> LBRACKET clist RBRACKET .)
    RPAREN          reduce using rule 49 (expr_list -> LBRACKET clist RBRACKET .)
    COLON           reduce using rule 49 (expr_list -> LBRACKET clist RBRACKET .)
    TO              reduce using rule 49 (expr_list -> LBRACKET clist RBRACKET .)


state 134

    (36) clist -> expr COMMA . clist
    (34) clist -> . empty
    (35) clist -> . expr
    (36) clist -> . expr COMMA clist
    (70) empty -> .
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    RBRACKET        reduce using rule 70 (empty -> .)
    RPAREN          reduce using rule 70 (empty -> .)
    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 105
    clist                          shift and go to state 144
    empty                          shift and go to state 104
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 135

    (51) operation_on_list -> ID LBRACKET expr RBRACKET .
    (53) assignment -> ID LBRACKET expr RBRACKET . EQUALS expr

    SEMI            reduce using rule 51 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    LBRACKET        reduce using rule 51 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    QUESTIONMARK    reduce using rule 51 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 51 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 51 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    TIMES           reduce using rule 51 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 51 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    MODULO          reduce using rule 51 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    GT              reduce using rule 51 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    LT              reduce using rule 51 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    EQ              reduce using rule 51 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    LE              reduce using rule 51 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    GE              reduce using rule 51 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    NE              reduce using rule 51 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    LOR             reduce using rule 51 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    LAND            reduce using rule 51 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 51 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 51 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 51 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    COLON           reduce using rule 51 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    TO              reduce using rule 51 (operation_on_list -> ID LBRACKET expr RBRACKET .)
    EQUALS          shift and go to state 145


state 136

    (55) function_call -> ID LPAREN clist RPAREN .

    SEMI            reduce using rule 55 (function_call -> ID LPAREN clist RPAREN .)
    LBRACKET        reduce using rule 55 (function_call -> ID LPAREN clist RPAREN .)
    QUESTIONMARK    reduce using rule 55 (function_call -> ID LPAREN clist RPAREN .)
    PLUS            reduce using rule 55 (function_call -> ID LPAREN clist RPAREN .)
    MINUS           reduce using rule 55 (function_call -> ID LPAREN clist RPAREN .)
    TIMES           reduce using rule 55 (function_call -> ID LPAREN clist RPAREN .)
    DIVIDE          reduce using rule 55 (function_call -> ID LPAREN clist RPAREN .)
    MODULO          reduce using rule 55 (function_call -> ID LPAREN clist RPAREN .)
    GT              reduce using rule 55 (function_call -> ID LPAREN clist RPAREN .)
    LT              reduce using rule 55 (function_call -> ID LPAREN clist RPAREN .)
    EQ              reduce using rule 55 (function_call -> ID LPAREN clist RPAREN .)
    LE              reduce using rule 55 (function_call -> ID LPAREN clist RPAREN .)
    GE              reduce using rule 55 (function_call -> ID LPAREN clist RPAREN .)
    NE              reduce using rule 55 (function_call -> ID LPAREN clist RPAREN .)
    LOR             reduce using rule 55 (function_call -> ID LPAREN clist RPAREN .)
    LAND            reduce using rule 55 (function_call -> ID LPAREN clist RPAREN .)
    COMMA           reduce using rule 55 (function_call -> ID LPAREN clist RPAREN .)
    RBRACKET        reduce using rule 55 (function_call -> ID LPAREN clist RPAREN .)
    RPAREN          reduce using rule 55 (function_call -> ID LPAREN clist RPAREN .)
    COLON           reduce using rule 55 (function_call -> ID LPAREN clist RPAREN .)
    TO              reduce using rule 55 (function_call -> ID LPAREN clist RPAREN .)


state 137

    (56) function_call -> ID LPAREN error RPAREN .

    SEMI            reduce using rule 56 (function_call -> ID LPAREN error RPAREN .)
    LBRACKET        reduce using rule 56 (function_call -> ID LPAREN error RPAREN .)
    QUESTIONMARK    reduce using rule 56 (function_call -> ID LPAREN error RPAREN .)
    PLUS            reduce using rule 56 (function_call -> ID LPAREN error RPAREN .)
    MINUS           reduce using rule 56 (function_call -> ID LPAREN error RPAREN .)
    TIMES           reduce using rule 56 (function_call -> ID LPAREN error RPAREN .)
    DIVIDE          reduce using rule 56 (function_call -> ID LPAREN error RPAREN .)
    MODULO          reduce using rule 56 (function_call -> ID LPAREN error RPAREN .)
    GT              reduce using rule 56 (function_call -> ID LPAREN error RPAREN .)
    LT              reduce using rule 56 (function_call -> ID LPAREN error RPAREN .)
    EQ              reduce using rule 56 (function_call -> ID LPAREN error RPAREN .)
    LE              reduce using rule 56 (function_call -> ID LPAREN error RPAREN .)
    GE              reduce using rule 56 (function_call -> ID LPAREN error RPAREN .)
    NE              reduce using rule 56 (function_call -> ID LPAREN error RPAREN .)
    LOR             reduce using rule 56 (function_call -> ID LPAREN error RPAREN .)
    LAND            reduce using rule 56 (function_call -> ID LPAREN error RPAREN .)
    COMMA           reduce using rule 56 (function_call -> ID LPAREN error RPAREN .)
    RBRACKET        reduce using rule 56 (function_call -> ID LPAREN error RPAREN .)
    RPAREN          reduce using rule 56 (function_call -> ID LPAREN error RPAREN .)
    COLON           reduce using rule 56 (function_call -> ID LPAREN error RPAREN .)
    TO              reduce using rule 56 (function_call -> ID LPAREN error RPAREN .)


state 138

    (50) operation_on_list -> expr LBRACKET expr RBRACKET .

    SEMI            reduce using rule 50 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    LBRACKET        reduce using rule 50 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    QUESTIONMARK    reduce using rule 50 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 50 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 50 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    TIMES           reduce using rule 50 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 50 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    MODULO          reduce using rule 50 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    GT              reduce using rule 50 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    LT              reduce using rule 50 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    EQ              reduce using rule 50 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    LE              reduce using rule 50 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    GE              reduce using rule 50 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    NE              reduce using rule 50 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    LOR             reduce using rule 50 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    LAND            reduce using rule 50 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 50 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 50 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 50 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    COLON           reduce using rule 50 (operation_on_list -> expr LBRACKET expr RBRACKET .)
    TO              reduce using rule 50 (operation_on_list -> expr LBRACKET expr RBRACKET .)


state 139

    (54) ternary_expr -> expr QUESTIONMARK expr COLON . expr
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 146
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 140

    (27) defvar -> VAR TYPE ID EQUALS . expr
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 147
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 141

    (20) single_if -> IF LPAREN expr RPAREN . stmt
    (21) if_with_else -> IF LPAREN expr RPAREN . stmt ELSE stmt
    (9) stmt -> . expr SEMI
    (10) stmt -> . defvar SEMI
    (11) stmt -> . return_instr SEMI
    (12) stmt -> . single_if
    (13) stmt -> . if_with_else
    (14) stmt -> . while_loop
    (15) stmt -> . for_loop
    (16) stmt -> . block
    (17) stmt -> . func
    (18) stmt -> . error SEMI
    (19) stmt -> . error
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (26) defvar -> . VAR TYPE ID
    (27) defvar -> . VAR TYPE ID EQUALS expr
    (25) return_instr -> . RETURN expr
    (20) single_if -> . IF LPAREN expr RPAREN stmt
    (21) if_with_else -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (22) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (23) for_loop -> . FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
    (24) block -> . LBRACE body RBRACE
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> . DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE
    (6) func -> . DEF error ID LPAREN flist RPAREN LBRACE body RBRACE
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    error           shift and go to state 48
    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    VAR             shift and go to state 60
    RETURN          shift and go to state 61
    IF              shift and go to state 62
    WHILE           shift and go to state 63
    FOR             shift and go to state 64
    LBRACE          shift and go to state 35
    DEF             shift and go to state 4
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 39
    stmt                           shift and go to state 148
    defvar                         shift and go to state 40
    return_instr                   shift and go to state 41
    single_if                      shift and go to state 42
    if_with_else                   shift and go to state 43
    while_loop                     shift and go to state 44
    for_loop                       shift and go to state 45
    block                          shift and go to state 46
    func                           shift and go to state 47
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 142

    (22) while_loop -> WHILE LPAREN expr RPAREN . stmt
    (9) stmt -> . expr SEMI
    (10) stmt -> . defvar SEMI
    (11) stmt -> . return_instr SEMI
    (12) stmt -> . single_if
    (13) stmt -> . if_with_else
    (14) stmt -> . while_loop
    (15) stmt -> . for_loop
    (16) stmt -> . block
    (17) stmt -> . func
    (18) stmt -> . error SEMI
    (19) stmt -> . error
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (26) defvar -> . VAR TYPE ID
    (27) defvar -> . VAR TYPE ID EQUALS expr
    (25) return_instr -> . RETURN expr
    (20) single_if -> . IF LPAREN expr RPAREN stmt
    (21) if_with_else -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (22) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (23) for_loop -> . FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
    (24) block -> . LBRACE body RBRACE
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> . DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE
    (6) func -> . DEF error ID LPAREN flist RPAREN LBRACE body RBRACE
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    error           shift and go to state 48
    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    VAR             shift and go to state 60
    RETURN          shift and go to state 61
    IF              shift and go to state 62
    WHILE           shift and go to state 63
    FOR             shift and go to state 64
    LBRACE          shift and go to state 35
    DEF             shift and go to state 4
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 39
    stmt                           shift and go to state 149
    defvar                         shift and go to state 40
    return_instr                   shift and go to state 41
    single_if                      shift and go to state 42
    if_with_else                   shift and go to state 43
    while_loop                     shift and go to state 44
    for_loop                       shift and go to state 45
    block                          shift and go to state 46
    func                           shift and go to state 47
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 143

    (23) for_loop -> FOR LPAREN ID EQUALS . expr TO expr RPAREN stmt
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 150
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 144

    (36) clist -> expr COMMA clist .

    RBRACKET        reduce using rule 36 (clist -> expr COMMA clist .)
    RPAREN          reduce using rule 36 (clist -> expr COMMA clist .)


state 145

    (53) assignment -> ID LBRACKET expr RBRACKET EQUALS . expr
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 151
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 146

    (54) ternary_expr -> expr QUESTIONMARK expr COLON expr .
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 54 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    LBRACKET        reduce using rule 54 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    QUESTIONMARK    reduce using rule 54 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    PLUS            reduce using rule 54 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    MINUS           reduce using rule 54 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    TIMES           reduce using rule 54 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    DIVIDE          reduce using rule 54 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    MODULO          reduce using rule 54 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    GT              reduce using rule 54 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    LT              reduce using rule 54 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    EQ              reduce using rule 54 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    LE              reduce using rule 54 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    GE              reduce using rule 54 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    NE              reduce using rule 54 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    LOR             reduce using rule 54 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    LAND            reduce using rule 54 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    COMMA           reduce using rule 54 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    RBRACKET        reduce using rule 54 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    RPAREN          reduce using rule 54 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    COLON           reduce using rule 54 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)
    TO              reduce using rule 54 (ternary_expr -> expr QUESTIONMARK expr COLON expr .)

  ! LBRACKET        [ shift and go to state 77 ]
  ! QUESTIONMARK    [ shift and go to state 78 ]
  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! TIMES           [ shift and go to state 81 ]
  ! DIVIDE          [ shift and go to state 82 ]
  ! MODULO          [ shift and go to state 83 ]
  ! GT              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! EQ              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! LOR             [ shift and go to state 90 ]
  ! LAND            [ shift and go to state 91 ]


state 147

    (27) defvar -> VAR TYPE ID EQUALS expr .
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 27 (defvar -> VAR TYPE ID EQUALS expr .)
    LBRACKET        shift and go to state 77
    QUESTIONMARK    shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MODULO          shift and go to state 83
    GT              shift and go to state 84
    LT              shift and go to state 85
    EQ              shift and go to state 86
    LE              shift and go to state 87
    GE              shift and go to state 88
    NE              shift and go to state 89
    LOR             shift and go to state 90
    LAND            shift and go to state 91


state 148

    (20) single_if -> IF LPAREN expr RPAREN stmt .
    (21) if_with_else -> IF LPAREN expr RPAREN stmt . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    error           reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    LNOT            reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    PLUS            reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    MINUS           reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    ID              reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    NUMBER          reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    STRING          reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    VAR             reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    IF              reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    LBRACE          reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    DEF             reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    LBRACKET        reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    RBRACE          reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .)
    ELSE            shift and go to state 152

  ! ELSE            [ reduce using rule 20 (single_if -> IF LPAREN expr RPAREN stmt .) ]


state 149

    (22) while_loop -> WHILE LPAREN expr RPAREN stmt .

    error           reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    LNOT            reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    PLUS            reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    MINUS           reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    ID              reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    NUMBER          reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    STRING          reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    VAR             reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    IF              reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    LBRACE          reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    DEF             reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    LBRACKET        reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    RBRACE          reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    ELSE            reduce using rule 22 (while_loop -> WHILE LPAREN expr RPAREN stmt .)


state 150

    (23) for_loop -> FOR LPAREN ID EQUALS expr . TO expr RPAREN stmt
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    TO              shift and go to state 153
    LBRACKET        shift and go to state 77
    QUESTIONMARK    shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MODULO          shift and go to state 83
    GT              shift and go to state 84
    LT              shift and go to state 85
    EQ              shift and go to state 86
    LE              shift and go to state 87
    GE              shift and go to state 88
    NE              shift and go to state 89
    LOR             shift and go to state 90
    LAND            shift and go to state 91


state 151

    (53) assignment -> ID LBRACKET expr RBRACKET EQUALS expr .
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    SEMI            reduce using rule 53 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    LBRACKET        reduce using rule 53 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    QUESTIONMARK    reduce using rule 53 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    PLUS            reduce using rule 53 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    MINUS           reduce using rule 53 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    TIMES           reduce using rule 53 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    DIVIDE          reduce using rule 53 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    MODULO          reduce using rule 53 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    GT              reduce using rule 53 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    LT              reduce using rule 53 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    EQ              reduce using rule 53 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    LE              reduce using rule 53 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    GE              reduce using rule 53 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    NE              reduce using rule 53 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    LOR             reduce using rule 53 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    LAND            reduce using rule 53 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    COMMA           reduce using rule 53 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    RBRACKET        reduce using rule 53 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    RPAREN          reduce using rule 53 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    COLON           reduce using rule 53 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)
    TO              reduce using rule 53 (assignment -> ID LBRACKET expr RBRACKET EQUALS expr .)

  ! LBRACKET        [ shift and go to state 77 ]
  ! QUESTIONMARK    [ shift and go to state 78 ]
  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! TIMES           [ shift and go to state 81 ]
  ! DIVIDE          [ shift and go to state 82 ]
  ! MODULO          [ shift and go to state 83 ]
  ! GT              [ shift and go to state 84 ]
  ! LT              [ shift and go to state 85 ]
  ! EQ              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GE              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! LOR             [ shift and go to state 90 ]
  ! LAND            [ shift and go to state 91 ]


state 152

    (21) if_with_else -> IF LPAREN expr RPAREN stmt ELSE . stmt
    (9) stmt -> . expr SEMI
    (10) stmt -> . defvar SEMI
    (11) stmt -> . return_instr SEMI
    (12) stmt -> . single_if
    (13) stmt -> . if_with_else
    (14) stmt -> . while_loop
    (15) stmt -> . for_loop
    (16) stmt -> . block
    (17) stmt -> . func
    (18) stmt -> . error SEMI
    (19) stmt -> . error
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (26) defvar -> . VAR TYPE ID
    (27) defvar -> . VAR TYPE ID EQUALS expr
    (25) return_instr -> . RETURN expr
    (20) single_if -> . IF LPAREN expr RPAREN stmt
    (21) if_with_else -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (22) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (23) for_loop -> . FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
    (24) block -> . LBRACE body RBRACE
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> . DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE
    (6) func -> . DEF error ID LPAREN flist RPAREN LBRACE body RBRACE
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    error           shift and go to state 48
    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    VAR             shift and go to state 60
    RETURN          shift and go to state 61
    IF              shift and go to state 62
    WHILE           shift and go to state 63
    FOR             shift and go to state 64
    LBRACE          shift and go to state 35
    DEF             shift and go to state 4
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 39
    stmt                           shift and go to state 154
    defvar                         shift and go to state 40
    return_instr                   shift and go to state 41
    single_if                      shift and go to state 42
    if_with_else                   shift and go to state 43
    while_loop                     shift and go to state 44
    for_loop                       shift and go to state 45
    block                          shift and go to state 46
    func                           shift and go to state 47
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 153

    (23) for_loop -> FOR LPAREN ID EQUALS expr TO . expr RPAREN stmt
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 155
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 154

    (21) if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .

    error           reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    LNOT            reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    PLUS            reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    MINUS           reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    ID              reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    NUMBER          reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    STRING          reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    VAR             reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    RETURN          reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    IF              reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    WHILE           reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FOR             reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    LBRACE          reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    DEF             reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    LBRACKET        reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    RBRACE          reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    ELSE            reduce using rule 21 (if_with_else -> IF LPAREN expr RPAREN stmt ELSE stmt .)


state 155

    (23) for_loop -> FOR LPAREN ID EQUALS expr TO expr . RPAREN stmt
    (50) operation_on_list -> expr . LBRACKET expr RBRACKET
    (54) ternary_expr -> expr . QUESTIONMARK expr COLON expr
    (57) binary_expr -> expr . PLUS expr
    (58) binary_expr -> expr . MINUS expr
    (59) binary_expr -> expr . TIMES expr
    (60) binary_expr -> expr . DIVIDE expr
    (61) binary_expr -> expr . MODULO expr
    (62) binary_expr -> expr . GT expr
    (63) binary_expr -> expr . LT expr
    (64) binary_expr -> expr . EQ expr
    (65) binary_expr -> expr . LE expr
    (66) binary_expr -> expr . GE expr
    (67) binary_expr -> expr . NE expr
    (68) binary_expr -> expr . LOR expr
    (69) binary_expr -> expr . LAND expr

    RPAREN          shift and go to state 156
    LBRACKET        shift and go to state 77
    QUESTIONMARK    shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MODULO          shift and go to state 83
    GT              shift and go to state 84
    LT              shift and go to state 85
    EQ              shift and go to state 86
    LE              shift and go to state 87
    GE              shift and go to state 88
    NE              shift and go to state 89
    LOR             shift and go to state 90
    LAND            shift and go to state 91


state 156

    (23) for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN . stmt
    (9) stmt -> . expr SEMI
    (10) stmt -> . defvar SEMI
    (11) stmt -> . return_instr SEMI
    (12) stmt -> . single_if
    (13) stmt -> . if_with_else
    (14) stmt -> . while_loop
    (15) stmt -> . for_loop
    (16) stmt -> . block
    (17) stmt -> . func
    (18) stmt -> . error SEMI
    (19) stmt -> . error
    (37) expr -> . operation_on_list
    (38) expr -> . expr_list
    (39) expr -> . ternary_expr
    (40) expr -> . LNOT expr
    (41) expr -> . PLUS expr
    (42) expr -> . MINUS expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (26) defvar -> . VAR TYPE ID
    (27) defvar -> . VAR TYPE ID EQUALS expr
    (25) return_instr -> . RETURN expr
    (20) single_if -> . IF LPAREN expr RPAREN stmt
    (21) if_with_else -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (22) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (23) for_loop -> . FOR LPAREN ID EQUALS expr TO expr RPAREN stmt
    (24) block -> . LBRACE body RBRACE
    (3) func -> . DEF TYPE ID LPAREN flist RPAREN LBRACE body RBRACE
    (4) func -> . DEF TYPE ID LPAREN flist RPAREN RETURN expr SEMI
    (5) func -> . DEF TYPE ID LPAREN error RPAREN LBRACE body RBRACE
    (6) func -> . DEF error ID LPAREN flist RPAREN LBRACE body RBRACE
    (50) operation_on_list -> . expr LBRACKET expr RBRACKET
    (51) operation_on_list -> . ID LBRACKET expr RBRACKET
    (49) expr_list -> . LBRACKET clist RBRACKET
    (54) ternary_expr -> . expr QUESTIONMARK expr COLON expr
    (57) binary_expr -> . expr PLUS expr
    (58) binary_expr -> . expr MINUS expr
    (59) binary_expr -> . expr TIMES expr
    (60) binary_expr -> . expr DIVIDE expr
    (61) binary_expr -> . expr MODULO expr
    (62) binary_expr -> . expr GT expr
    (63) binary_expr -> . expr LT expr
    (64) binary_expr -> . expr EQ expr
    (65) binary_expr -> . expr LE expr
    (66) binary_expr -> . expr GE expr
    (67) binary_expr -> . expr NE expr
    (68) binary_expr -> . expr LOR expr
    (69) binary_expr -> . expr LAND expr
    (52) assignment -> . ID EQUALS expr
    (53) assignment -> . ID LBRACKET expr RBRACKET EQUALS expr
    (55) function_call -> . ID LPAREN clist RPAREN
    (56) function_call -> . ID LPAREN error RPAREN

    error           shift and go to state 48
    LNOT            shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    ID              shift and go to state 34
    NUMBER          shift and go to state 58
    STRING          shift and go to state 59
    VAR             shift and go to state 60
    RETURN          shift and go to state 61
    IF              shift and go to state 62
    WHILE           shift and go to state 63
    FOR             shift and go to state 64
    LBRACE          shift and go to state 35
    DEF             shift and go to state 4
    LBRACKET        shift and go to state 65

    expr                           shift and go to state 39
    stmt                           shift and go to state 157
    defvar                         shift and go to state 40
    return_instr                   shift and go to state 41
    single_if                      shift and go to state 42
    if_with_else                   shift and go to state 43
    while_loop                     shift and go to state 44
    for_loop                       shift and go to state 45
    block                          shift and go to state 46
    func                           shift and go to state 47
    operation_on_list              shift and go to state 49
    expr_list                      shift and go to state 50
    ternary_expr                   shift and go to state 51
    binary_expr                    shift and go to state 55
    assignment                     shift and go to state 56
    function_call                  shift and go to state 57

state 157

    (23) for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .

    error           reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    LNOT            reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    PLUS            reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    MINUS           reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    ID              reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    NUMBER          reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    STRING          reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    VAR             reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    RETURN          reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    IF              reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    WHILE           reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    FOR             reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    LBRACE          reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    DEF             reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    LBRACKET        reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    RBRACE          reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)
    ELSE            reduce using rule 23 (for_loop -> FOR LPAREN ID EQUALS expr TO expr RPAREN stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LBRACKET in state 34 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 148 resolved as shift
